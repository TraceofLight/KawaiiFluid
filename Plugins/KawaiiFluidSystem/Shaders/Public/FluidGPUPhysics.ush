// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file FluidGPUPhysics.ush
 * @brief Core SPH GPU particle structures, constants, and shared math helpers.
 */

#pragma once

#include "/Engine/Public/Platform.ush"

//=============================================================================
// GPU Particle Structure (must match FGPUFluidParticle in C++)
//=============================================================================

/**
 * @brief Data layout for FGPUFluidParticle
 */
struct FGPUFluidParticle
{
	float3 Position;           // 12 bytes
	float Mass;                // 4 bytes (total: 16)

	float3 PredictedPosition;  // 12 bytes
	float Density;             // 4 bytes (total: 32)

	float3 Velocity;           // 12 bytes
	float Lambda;              // 4 bytes (total: 48)

	int ParticleID;            // 4 bytes
	int SourceID;              // 4 bytes - Source Component ID (-1 = invalid)
	uint Flags;                // 4 bytes
	uint NeighborCount;        // 4 bytes (total: 64)
};

//=============================================================================
// GPU Particle Flags
//=============================================================================

#define GPU_PARTICLE_FLAG_NONE                0
#define GPU_PARTICLE_FLAG_IS_ATTACHED         (1 << 0)
#define GPU_PARTICLE_FLAG_IS_SURFACE          (1 << 1)
#define GPU_PARTICLE_FLAG_JUST_DETACHED       (1 << 2)  // Must match C++ EGPUParticleFlags::JustDetached
#define GPU_PARTICLE_FLAG_NEAR_GROUND         (1 << 3)  // Must match C++ EGPUParticleFlags::NearGround
#define GPU_PARTICLE_FLAG_HAS_COLLIDED        (1 << 4)  // Must match C++ EGPUParticleFlags::HasCollided
#define GPU_PARTICLE_FLAG_IS_SLEEPING         (1 << 5)  // Must match C++ EGPUParticleFlags::IsSleeping
#define GPU_PARTICLE_FLAG_NEAR_BOUNDARY       (1 << 6)  // Must match C++ EGPUParticleFlags::NearBoundary


//=============================================================================
// Constants
//=============================================================================

#ifndef PI
#define PI 3.14159265359f
#endif

#ifndef SMALL_NUMBER
#define SMALL_NUMBER 0.0001f
#endif

//=============================================================================
// Unit Conversion Constants
// Unreal uses centimeters, SPH physics uses meters
// Kernel coefficients are precomputed in meters (C++ side)
//=============================================================================
#define CM_TO_M 0.01f
#define CM_TO_M_SQ 0.0001f  // (0.01)^2

//=============================================================================
// SPH Kernel Functions
// Based on: Müller et al. "Particle-Based Fluid Simulation for Interactive Applications"
//=============================================================================

/**
 * @brief Poly6 kernel (for density calculation)
 * W(r, h) = 315 / (64 * PI * h^9) * (h^2 - r^2)^3
 *
 * @param r2 - Squared distance between particles
 * @param h2 - Squared smoothing radius
 * @return Kernel value (NOT multiplied by coefficient)
 */
float Poly6Kernel(float r2, float h2)
{
	float diff = h2 - r2;
	return (diff > 0.0f) ? diff * diff * diff : 0.0f;
}

/**
 * @brief Optimized Spiky gradient using rsqrt (faster inverse square root)
 * Uses rsqrt(r2) instead of sqrt(r2) for better GPU performance
 *
 * @param r - Vector from neighbor to particle (particle.pos - neighbor.pos)
 * @param r2 - Squared length of r (pre-computed)
 * @param h - Smoothing radius
 * @param h2 - Squared smoothing radius (pre-computed)
 * @return Gradient vector (NOT multiplied by coefficient)
 */
float3 SpikyGradientFast(float3 r, float r2, float h, float h2)
{
	// Early exit for particles too close (avoid div by zero)
	if (r2 < SMALL_NUMBER * SMALL_NUMBER)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	// rsqrt is faster than sqrt on GPU (uses special function unit)
	// rLenInv = 1 / sqrt(r2)
	float rLenInv = rsqrt(r2);
	float rLen = r2 * rLenInv;  // rLen = r2 / sqrt(r2) = sqrt(r2)

	float diff = h - rLen;
	if (diff <= 0.0f)
	{
		return float3(0.0f, 0.0f, 0.0f);
	}

	// Normalized direction using rsqrt: r * (1/|r|) = r * rsqrt(r2)
	float3 dir = r * rLenInv;
	return dir * (diff * diff);
}

/**
 * @brief Viscosity kernel Laplacian (for viscosity calculation)
 * ∇²W(r, h) = 45 / (PI * h^6) * (h - |r|)
 *
 * @param rLen - Distance between particles
 * @param h - Smoothing radius
 * @param coeff - Precomputed coefficient (45 / (PI * h^6))
 */
float ViscosityLaplacian(float rLen, float h, float coeff)
{
	float diff = h - rLen;
	return (diff > 0.0f) ? coeff * diff : 0.0f;
}

//=============================================================================
// Cohesion / Adhesion Kernels (Akinci et al. 2013)
// "Versatile Surface Tension and Adhesion for SPH Fluids"
//=============================================================================

/**
 * @brief Akinci Cohesion Spline Function C(r)
 * Provides attraction at h/2 and repulsion at close range
 *
 * C(r) = 32/(πh^9) * {
 *   (h-r)³ * r³                    if h/2 < r ≤ h   (attraction)
 *   2*(h-r)³ * r³ - h⁶/64          if 0 < r ≤ h/2   (repulsion)
 * }
 *
 * Key properties:
 * - Maximum attraction at r ≈ h/2 (particle rest distance)
 * - Repulsion at close range prevents clustering
 * - Smooth transition, no discontinuities
 *
 * @param rLen - Distance between particles
 * @param h - Smoothing radius
 * @return Spline value (positive = attraction, negative = repulsion)
 */
float AkinciCohesionSpline(float rLen, float h)
{
	if (rLen > h || rLen < SMALL_NUMBER)
	{
		return 0.0f;
	}

	float h2 = h * h;
	float h3 = h2 * h;
	float h6 = h3 * h3;
	float h9 = h6 * h3;
	float coeff = 32.0f / (PI * h9);

	float halfH = h * 0.5f;
	float diff = h - rLen;
	float diff3 = diff * diff * diff;
	float r3 = rLen * rLen * rLen;

	if (rLen > halfH)
	{
		// Attraction region: (h-r)³ * r³
		return coeff * diff3 * r3;
	}
	else
	{
		// Repulsion region: 2*(h-r)³ * r³ - h⁶/64
		return coeff * (2.0f * diff3 * r3 - h6 / 64.0f);
	}
}

/**
 * @brief Legacy cohesion kernel (kept for compatibility)
 */
float CohesionKernel(float rLen, float h)
{
	return AkinciCohesionSpline(rLen, h);
}

/**
 * @brief Simple adhesion kernel for boundary adhesion (legacy)
 * Linear falloff: r=0 → max, r=h → 0
 */
float AdhesionKernel(float rLen, float h)
{
	if (rLen > h || rLen < 0.0001f)
	{
		return 0.0f;
	}

	// Linear falloff: r=0 → 1 (max), r=h → 0 (escape)
	return 1.0f - (rLen / h);
}

/**
 * @brief Convert flag check to bool
 */
bool HasFlag(uint flags, uint flag)
{
	return (flags & flag) != 0;
}

/**
 * @brief Set flag
 */
uint SetFlag(uint flags, uint flag)
{
	return flags | flag;
}

/**
 * @brief Clear flag
 */
uint ClearFlag(uint flags, uint flag)
{
	return flags & ~flag;
}

//=============================================================================
// GPU Collision Feedback Structure (must match FGPUCollisionFeedback in C++)
// Used for particle -> player interaction readback
// 80 bytes total for drag-based force calculation + impact offset
//=============================================================================

/**
 * @brief Data layout for FGPUCollisionFeedback
 */
struct FGPUCollisionFeedback
{
	// Row 1: 16 bytes
	int ParticleIndex;       // 4 bytes - Index of the colliding particle
	int ColliderIndex;       // 4 bytes - Index of the collider
	int ColliderType;        // 4 bytes - 0=Sphere, 1=Capsule, 2=Box, 3=Convex
	float Density;           // 4 bytes - Particle density at collision time

	// Row 2: 16 bytes
	float3 ImpactNormal;     // 12 bytes - Collision surface normal
	float Penetration;       // 4 bytes - Penetration depth (cm)

	// Row 3: 16 bytes
	float3 ParticleVelocity; // 12 bytes - Particle velocity (for drag calculation)
	int ColliderOwnerID;     // 4 bytes - Unique ID of collider owner (actor/component)

	// Row 4: 16 bytes 
	int ParticleSourceID;    // 4 bytes - Particle's SourceID (PresetIndex | ComponentIndex << 16)
	int ParticleActorID;     // 4 bytes - Unique ID of particle's owner actor (reserved)
	int BoneIndex;           // 4 bytes - Bone index for per-bone force calculation (-1 = no bone)
	int Padding1;            // 4 bytes - Alignment padding

	// Row 5: 16 bytes
	float3 ImpactOffset;     // 12 bytes - Impact position in bone-local space
	int Padding2;            // 4 bytes - Alignment padding

	// Row 6: 16 bytes
	float3 ParticlePosition; // 12 bytes - Particle world position (for buoyancy center)
	int Padding3;            // 4 bytes - Alignment padding

};

// Collision primitive type constants
#define COLLIDER_TYPE_SPHERE   0
#define COLLIDER_TYPE_CAPSULE  1
#define COLLIDER_TYPE_BOX      2
#define COLLIDER_TYPE_CONVEX   3

//=============================================================================
// Half Precision Packing Utilities (B Plan Bandwidth Optimization)
// Used by SoA buffers to reduce memory bandwidth by 50%
//=============================================================================

/**
 * @brief Pack two floats into one uint (2x float16)
 * @param v - float2 to pack
 * @return Packed uint containing two half-precision values
 */
uint PackHalf2(float2 v)
{
	return f32tof16(v.x) | (f32tof16(v.y) << 16);
}

/**
 * @brief Unpack one uint into two floats
 * @param packed - uint containing two half-precision values
 * @return float2 with unpacked values
 */
float2 UnpackHalf2(uint packed)
{
	return float2(f16tof32(packed), f16tof32(packed >> 16));
}

/**
 * @brief Pack float3 velocity into uint2 (half4: xy in .x, z+padding in .y)
 * Total: 12 bytes → 8 bytes (33% bandwidth reduction)
 * @param vel - float3 velocity to pack
 * @return uint2 with packed half-precision velocity
 */
uint2 PackVelocity(float3 vel)
{
	uint2 packed;
	packed.x = PackHalf2(float2(vel.x, vel.y));
	packed.y = PackHalf2(float2(vel.z, 0.0f));
	return packed;
}

/**
 * @brief Unpack uint2 into float3 velocity
 * @param packed - uint2 containing packed velocity
 * @return float3 unpacked velocity
 */
float3 UnpackVelocity(uint2 packed)
{
	float2 xy = UnpackHalf2(packed.x);
	float2 zw = UnpackHalf2(packed.y);
	return float3(xy.x, xy.y, zw.x);
}

/**
 * @brief Pack Density + Lambda into one uint (half2)
 * Total: 8 bytes → 4 bytes (50% bandwidth reduction)
 * @param density - particle density
 * @param lambda - PBF lambda constraint multiplier
 * @return uint with packed half-precision values
 */
uint PackDensityLambda(float density, float lambda)
{
	return PackHalf2(float2(density, lambda));
}

/**
 * @brief Unpack uint into Density and Lambda
 * @param packed - uint containing packed density/lambda
 * @param density - output density
 * @param lambda - output lambda
 */
void UnpackDensityLambda(uint packed, out float density, out float lambda)
{
	float2 dl = UnpackHalf2(packed);
	density = dl.x;
	lambda = dl.y;
}
