// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file FluidMortonUtils.ush
 * @brief Morton-code (Z-order) utilities for grid indexing and cell traversal.
 *
 * MORTON_GRID_AXIS_BITS is configured by C++ permutation setup
 * (ModifyCompilationEnvironment / FGridResolutionDim).
 */

#pragma once

//=============================================================================
// Z-Order Sorting Configuration
//=============================================================================

#ifndef MORTON_GRID_AXIS_BITS
#define MORTON_GRID_AXIS_BITS 7  // Default: Medium (7 bits per axis)
#endif

#define MORTON_GRID_SIZE (1 << MORTON_GRID_AXIS_BITS)
#define MORTON_MAX_VALUE (MORTON_GRID_SIZE - 1)

#ifndef MAX_CELLS
#define MAX_CELLS (MORTON_GRID_SIZE * MORTON_GRID_SIZE * MORTON_GRID_SIZE)
#endif

#define INVALID_INDEX 0xFFFFFFFF

//=============================================================================
// Morton Code Expansion Functions (6-bit, 7-bit, 8-bit)
// All use the same 8/4/2 shift pattern with different input masks
//=============================================================================

/**
 * @brief 6-bit expansion: 0-63 -> 18-bit interleaved
 */
uint MortonExpandBits6(uint v)
{
	v = v & 0x3Fu;  // 63 max (6 bits)
	v = (v | (v << 8)) & 0x0000F00Fu;
	v = (v | (v << 4)) & 0x000C30C3u;
	v = (v | (v << 2)) & 0x00249249u;
	return v;
}

/**
 * @brief 7-bit expansion: 0-127 -> 21-bit interleaved
 */
uint MortonExpandBits7(uint v)
{
	v = v & 0x7Fu;  // 127 max (7 bits)
	v = (v | (v << 8)) & 0x0000F00Fu;
	v = (v | (v << 4)) & 0x000C30C3u;
	v = (v | (v << 2)) & 0x00249249u;
	return v;
}

/**
 * @brief 8-bit expansion: 0-255 -> 24-bit interleaved
 */
uint MortonExpandBits8(uint v)
{
	v = v & 0xFFu;  // 255 max (8 bits)
	v = (v | (v << 8)) & 0x0000F00Fu;
	v = (v | (v << 4)) & 0x000C30C3u;
	v = (v | (v << 2)) & 0x00249249u;
	return v;
}

//=============================================================================
// Morton3D Functions (6-bit, 7-bit, 8-bit)
//=============================================================================

/**
 * @brief Computes a 6-bit-per-axis Morton code
 */
uint Morton3D_6bit(uint x, uint y, uint z)
{
	x = min(x, 63u);
	y = min(y, 63u);
	z = min(z, 63u);
	return (MortonExpandBits6(z) << 2) | (MortonExpandBits6(y) << 1) | MortonExpandBits6(x);
}

/**
 * @brief Computes a 7-bit-per-axis Morton code
 */
uint Morton3D_7bit(uint x, uint y, uint z)
{
	x = min(x, 127u);
	y = min(y, 127u);
	z = min(z, 127u);
	return (MortonExpandBits7(z) << 2) | (MortonExpandBits7(y) << 1) | MortonExpandBits7(x);
}

/**
 * @brief Computes an 8-bit-per-axis Morton code
 */
uint Morton3D_8bit(uint x, uint y, uint z)
{
	x = min(x, 255u);
	y = min(y, 255u);
	z = min(z, 255u);
	return (MortonExpandBits8(z) << 2) | (MortonExpandBits8(y) << 1) | MortonExpandBits8(x);
}

//=============================================================================
// Generic Morton3D - Selects function based on MORTON_GRID_AXIS_BITS
//=============================================================================

/**
 * @brief Computes a Morton code using current grid-bit configuration
 */
uint Morton3D(uint x, uint y, uint z)
{
#if MORTON_GRID_AXIS_BITS == 6
	return Morton3D_6bit(x, y, z);
#elif MORTON_GRID_AXIS_BITS == 8
	return Morton3D_8bit(x, y, z);
#else  // Default to 7-bit (Medium)
	return Morton3D_7bit(x, y, z);
#endif
}

//=============================================================================
// Cell ID Calculation
//=============================================================================

/**
 * @brief Compute Morton-based cell ID from cell coordinates
 * Automatically uses the correct bit-width based on MORTON_GRID_AXIS_BITS
 */
uint GetMortonCellIDFromCellCoord(int3 cellCoord, float3 boundsMin, float cellSize)
{
	int3 gridMin = int3(floor(boundsMin / cellSize));
	int3 offset = cellCoord - gridMin;
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Hybrid Tiled Z-Order Functions
// Enables unlimited simulation range by combining:
// - TileHash (3 bits): Spatial hash of tile coordinates (8 buckets)
// - LocalMorton (18 bits): Z-Order within tile (64³ cells, cache-coherent)
//
// 21-bit Sort Key Structure (matches MAX_CELLS for correct CellStart/CellEnd):
// ┌─────────────────────┬───────────────────────────────────────┐
// │   TileHash (3bit)   │        LocalMorton (18bit)            │
// │   (bits 18-20)      │        (bits 0-17)                    │
// └─────────────────────┴───────────────────────────────────────┘
//
// CRITICAL: Key is exactly 21 bits to match MAX_CELLS (2^21 = 2,097,152)
// This ensures particles with same cell ID are CONTIGUOUS after sorting,
// which is required for correct CellStart/CellEnd building.
// The 8 tile buckets (3 bits) provide tile separation; hash collisions
// are filtered by distance check (r² < h²) in neighbor search.
//=============================================================================

#define HYBRID_TILE_BITS 6           // 6 bits per axis = 64 cells per tile
#define HYBRID_TILE_SIZE 64          // 2^6 = 64 cells per tile axis
#define HYBRID_TILE_MASK 0x3F        // 63 (lower 6 bits mask)
#define HYBRID_LOCAL_MORTON_BITS 18  // 6 bits × 3 axes = 18 bits
#define HYBRID_TILE_HASH_BITS 3      // 3 bits for tile hash (8 buckets, matches MAX_CELLS)
#define HYBRID_TILE_HASH_MASK 0x7    // 7 (3-bit mask)

/**
 * @brief Spatial hash function for tile coordinates
 * Uses large primes to minimize collisions
 * Handles negative coordinates automatically via unsigned casting
 */
uint HashTile(int3 tilePos)
{
	const uint p1 = 73856093u;
	const uint p2 = 19349663u;
	const uint p3 = 83492791u;
	return (uint(tilePos.x) * p1) ^ (uint(tilePos.y) * p2) ^ (uint(tilePos.z) * p3);
}

// Compute Hybrid Tiled Z-Order Key (21-bit, matches MAX_CELLS)
// Input: gridPos = cell coordinate (can be any integer, including negative)
// Output: 21-bit sort key with TileHash in upper 3 bits, LocalMorton in lower 18 bits
//
// CRITICAL: The 21-bit key ensures particles with the same key are CONTIGUOUS
// after sorting. This is required for correct CellStart/CellEnd building.
// With 32-bit keys and 21-bit truncation, particles could be scattered in the
// sorted array, causing CellStart/CellEnd corruption and "lost" particles.
/**
 * @brief Computes the hybrid tiled Morton key
 */
uint ComputeHybridTiledKey(int3 gridPos)
{
	// Step 1: Extract local position within tile (lower 6 bits per axis)
	// Bitwise AND with TILE_MASK handles negative coordinates correctly:
	//   (-5) & 0x3F = 0xFFFFFFFB & 0x3F = 59 (valid local coordinate)
	uint3 localPos = uint3(
		uint(gridPos.x) & HYBRID_TILE_MASK,
		uint(gridPos.y) & HYBRID_TILE_MASK,
		uint(gridPos.z) & HYBRID_TILE_MASK
	);

	// Step 2: Compute 18-bit local Morton code using existing 6-bit function
	uint localMorton = Morton3D_6bit(localPos.x, localPos.y, localPos.z);

	// Step 3: Compute tile coordinates (upper bits = tile index)
	// Arithmetic right shift preserves sign for negative coordinates:
	//   (-5) >> 6 = -1 (correct tile index)
	int3 tilePos = int3(
		gridPos.x >> HYBRID_TILE_BITS,
		gridPos.y >> HYBRID_TILE_BITS,
		gridPos.z >> HYBRID_TILE_BITS
	);

	// Step 4: Hash tile coordinates to 3-bit value (8 buckets)
	// The 3 bits provide tile separation; collisions are filtered by distance check
	uint tileHash = HashTile(tilePos) & HYBRID_TILE_HASH_MASK;

	// Step 5: Combine into 21-bit key (matches MAX_CELLS = 2^21)
	// TileHash in upper 3 bits + LocalMorton in lower 18 bits = 21 bits total
	// No truncation needed: key == cellID, ensuring contiguous particles per cell
	return (tileHash << HYBRID_LOCAL_MORTON_BITS) | localMorton;
}
