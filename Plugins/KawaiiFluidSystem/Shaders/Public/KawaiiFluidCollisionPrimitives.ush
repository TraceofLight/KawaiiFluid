// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidCollisionPrimitives.ush
 * @brief Defines GPU collision primitive data and SDF/collision helper functions.
 */

#pragma once

//=============================================================================
// Primitive Structures (must match C++ definitions)
//=============================================================================

/**
 * @brief Data layout for FGPUCollisionSphere
 */
struct FGPUCollisionSphere
{
	float3 Center;
	float Radius;
	float Friction;
	float Restitution;
	int BoneIndex;     // Index into bone transform buffer (-1 = no bone)
	int FluidTagID;    // Fluid tag hash for event identification
	int OwnerID;       // Unique ID of collider owner (actor/component)
	int bHasFluidInteraction; // 1 if from FluidInteraction component, 0 if from WorldCollision
};

/**
 * @brief Data layout for FGPUCollisionCapsule
 */
struct FGPUCollisionCapsule
{
	float3 Start;
	float Radius;
	float3 End;
	float Friction;
	float Restitution;
	int BoneIndex;     // Index into bone transform buffer (-1 = no bone)
	int FluidTagID;    // Fluid tag hash for event identification
	int OwnerID;       // Unique ID of collider owner (actor/component)
	int bHasFluidInteraction; // 1 if from FluidInteraction component, 0 if from WorldCollision
	int Padding;       // Alignment padding
};

/**
 * @brief Data layout for FGPUCollisionBox
 */
struct FGPUCollisionBox
{
	float3 Center;
	float Friction;
	float3 Extent;
	float Restitution;
	float4 Rotation;  // Quaternion (x, y, z, w)
	int BoneIndex;    // Index into bone transform buffer (-1 = no bone)
	int FluidTagID;   // Fluid tag hash for event identification
	int OwnerID;      // Unique ID of collider owner (actor/component)
	int bHasFluidInteraction; // 1 if from FluidInteraction component, 0 if from WorldCollision
};

/**
 * @brief Data layout for FGPUCollisionConvex
 */
struct FGPUCollisionConvex
{
	float3 Center;
	float BoundingRadius;
	int PlaneStartIndex;
	int PlaneCount;
	float Friction;
	float Restitution;
	int BoneIndex;    // Index into bone transform buffer (-1 = no bone)
	int FluidTagID;   // Fluid tag hash for event identification
	int OwnerID;      // Unique ID of collider owner (actor/component)
	int bHasFluidInteraction; // 1 if from FluidInteraction component, 0 if from WorldCollision
};

/**
 * @brief Data layout for FGPUConvexPlane
 */
struct FGPUConvexPlane
{
	float3 Normal;
	float Distance;
};

//=============================================================================
// Bone Transform Structure (must match C++ FGPUBoneTransform)
//=============================================================================

/**
 * @brief Data layout for FGPUBoneTransform
 */
struct FGPUBoneTransform
{
	float3 Position;      // Bone world position
	float Scale;          // Uniform scale
	float4 Rotation;      // Quaternion (x, y, z, w)
	float3 PreviousPos;   // Previous frame position
	float Padding1;
	float4 PreviousRot;   // Previous frame rotation
};

//=============================================================================
// Particle Attachment Structure (must match C++ FGPUParticleAttachment)
//=============================================================================

/**
 * @brief Data layout for FGPUParticleAttachment
 */
struct FGPUParticleAttachment
{
	int PrimitiveType;      // 0=Sphere, 1=Capsule, 2=Box, 3=Convex, -1=None
	int PrimitiveIndex;     // Index in primitive buffer
	int BoneIndex;          // Index in bone transform buffer
	float AdhesionStrength; // Current adhesion strength
	float3 LocalOffset;     // Position in bone-local space
	float AttachmentTime;   // Time when attached
	float3 RelativeVelocity;  // Velocity relative to bone (for anisotropy)
	float Padding;          // Alignment padding
};

//=============================================================================
// Quaternion Utilities (must be defined before Bone Transform Utilities)
//=============================================================================

/**
 * @brief Rotate vector by quaternion
 */
float3 RotateByQuat(float3 V, float4 Q)
{
	float3 T = 2.0f * cross(Q.xyz, V);
	return V + Q.w * T + cross(Q.xyz, T);
}

/**
 * @brief Inverse rotate vector by quaternion
 */
float3 InverseRotateByQuat(float3 V, float4 Q)
{
	// Conjugate of quaternion: (x,y,z,w) -> (-x,-y,-z,w)
	return RotateByQuat(V, float4(-Q.xyz, Q.w));
}

//=============================================================================
// Bone Transform Utilities
//=============================================================================

/**
 * @brief Transform position from bone-local to world space
 */
float3 BoneLocalToWorld(float3 LocalPos, FGPUBoneTransform Bone)
{
	float3 Scaled = LocalPos * Bone.Scale;
	float3 Rotated = RotateByQuat(Scaled, Bone.Rotation);
	return Rotated + Bone.Position;
}

/**
 * @brief Transform position from world to bone-local space
 */
float3 WorldToBoneLocal(float3 WorldPos, FGPUBoneTransform Bone)
{
	float3 Relative = WorldPos - Bone.Position;
	float3 Rotated = InverseRotateByQuat(Relative, Bone.Rotation);
	return Rotated / Bone.Scale;
}

/**
 * @brief Calculate bone velocity at a local position
 */
float3 CalcBoneVelocity(float3 LocalPos, FGPUBoneTransform Bone, float DeltaTime)
{
	if (DeltaTime < 0.0001f) return float3(0, 0, 0);

	// Current world position
	float3 CurrentWorld = BoneLocalToWorld(LocalPos, Bone);

	// Previous world position (using previous bone transform)
	FGPUBoneTransform PrevBone;
	PrevBone.Position = Bone.PreviousPos;
	PrevBone.Rotation = Bone.PreviousRot;
	PrevBone.Scale = Bone.Scale;
	float3 PrevWorld = BoneLocalToWorld(LocalPos, PrevBone);

	return (CurrentWorld - PrevWorld) / DeltaTime;
}

//=============================================================================
// SDF Functions
//=============================================================================

/**
 * @brief Sphere SDF
 */
float sdSphere(float3 P, float3 Center, float Radius)
{
	return length(P - Center) - Radius;
}

/**
 * @brief Capsule SDF (line segment with radius)
 */
float sdCapsule(float3 P, float3 A, float3 B, float Radius)
{
	float3 PA = P - A;
	float3 BA = B - A;
	float H = saturate(dot(PA, BA) / dot(BA, BA));
	return length(PA - BA * H) - Radius;
}

/**
 * @brief Axis-aligned box SDF (in local space)
 */
float sdBoxLocal(float3 P, float3 HalfExtent)
{
	float3 Q = abs(P) - HalfExtent;
	return length(max(Q, 0.0f)) + min(max(Q.x, max(Q.y, Q.z)), 0.0f);
}

/**
 * @brief Oriented box SDF
 */
float sdBox(float3 P, float3 Center, float3 HalfExtent, float4 Rotation)
{
	// Transform point to local space
	float3 LocalP = InverseRotateByQuat(P - Center, Rotation);
	return sdBoxLocal(LocalP, HalfExtent);
}

/**
 * @brief Convex hull SDF (intersection of half-spaces)
 */
float sdConvex(
	float3 P,
	float3 Center,
	float BoundingRadius,
	int PlaneStart,
	int PlaneCount,
	StructuredBuffer<FGPUConvexPlane> Planes)
{
	// Early out with bounding sphere - return large value to skip collision
	// (Main shader already does bounding sphere check with particle radius)
	float BoundDist = length(P - Center) - BoundingRadius;
	if (BoundDist > 0.0f)
	{
		// Return large positive value so collision won't trigger
		// (effectiveDist = largeValue - ParticleRadius will still be large)
		return 1000.0f;
	}

	// Find maximum signed distance to all planes
	float MaxDist = -1e10f;
	for (int I = 0; I < PlaneCount; ++I)
	{
		FGPUConvexPlane Plane = Planes[PlaneStart + I];
		float Dist = dot(P, Plane.Normal) - Plane.Distance;
		MaxDist = max(MaxDist, Dist);
	}
	return MaxDist;
}

//=============================================================================
// Collision Response
//=============================================================================

/**
 * @brief Numerical gradient for more accurate normal
 */
float3 CalcNumericalGradient_Sphere(float3 P, float3 Center, float Radius)
{
	const float Eps = 0.1f;
	float3 Gradient;
	Gradient.x = sdSphere(P + float3(Eps, 0, 0), Center, Radius)
	           - sdSphere(P - float3(Eps, 0, 0), Center, Radius);
	Gradient.y = sdSphere(P + float3(0, Eps, 0), Center, Radius)
	           - sdSphere(P - float3(0, Eps, 0), Center, Radius);
	Gradient.z = sdSphere(P + float3(0, 0, Eps), Center, Radius)
	           - sdSphere(P - float3(0, 0, Eps), Center, Radius);
	return normalize(Gradient);
}

/**
 * @brief Calculates numerical SDF gradient for a capsule
 */
float3 CalcNumericalGradient_Capsule(float3 P, float3 A, float3 B, float Radius)
{
	const float Eps = 0.1f;
	float3 Gradient;
	Gradient.x = sdCapsule(P + float3(Eps, 0, 0), A, B, Radius)
	           - sdCapsule(P - float3(Eps, 0, 0), A, B, Radius);
	Gradient.y = sdCapsule(P + float3(0, Eps, 0), A, B, Radius)
	           - sdCapsule(P - float3(0, Eps, 0), A, B, Radius);
	Gradient.z = sdCapsule(P + float3(0, 0, Eps), A, B, Radius)
	           - sdCapsule(P - float3(0, 0, Eps), A, B, Radius);
	return normalize(Gradient);
}

/**
 * @brief Calculates numerical SDF gradient for a box
 */
float3 CalcNumericalGradient_Box(float3 P, float3 Center, float3 Extent, float4 Rotation)
{
	const float Eps = 0.1f;
	float3 Gradient;
	Gradient.x = sdBox(P + float3(Eps, 0, 0), Center, Extent, Rotation)
	           - sdBox(P - float3(Eps, 0, 0), Center, Extent, Rotation);
	Gradient.y = sdBox(P + float3(0, Eps, 0), Center, Extent, Rotation)
	           - sdBox(P - float3(0, Eps, 0), Center, Extent, Rotation);
	Gradient.z = sdBox(P + float3(0, 0, Eps), Center, Extent, Rotation)
	           - sdBox(P - float3(0, 0, Eps), Center, Extent, Rotation);
	return normalize(Gradient);
}

/**
 * @brief Apply position-level friction (Unified Particle Physics, Macklin et al. 2014)
 *
 * This function applies friction at the position level rather than velocity level.
 * This is critical for PBF because FinalizePositions overwrites velocity with:
 *   v = (x* - x) / dt
 *
 * By modifying the position displacement, we ensure friction is preserved.
 *
 * Static friction:  |Δx_t| < μs * d → Δx_t = 0 (particle stops)
 * Kinetic friction: Δx_t *= min(μk * d / |Δx_t|, 1) (sliding with resistance)
 *
 * @param PredictedPos - Predicted position (will be modified)
 * @param OriginalPos - Original position before this timestep
 * @param Normal - Collision surface normal (pointing outward)
 * @param Penetration - Penetration depth (positive value)
 * @param StaticFriction - Static friction coefficient (μs)
 * @param KineticFriction - Kinetic friction coefficient (μk), typically same as friction param
 */
void ApplyPositionLevelFriction(
	inout float3 PredictedPos,
	float3 OriginalPos,
	float3 Normal,
	float Penetration,
	float StaticFriction,
	float KineticFriction)
{
	// Push out of collision first
	PredictedPos += Normal * (Penetration + 0.1f);

	// Calculate total displacement from original position
	float3 DeltaX = PredictedPos - OriginalPos;

	// Decompose into normal and tangent components
	float DeltaXNormal = dot(DeltaX, Normal);
	float3 DeltaXNormalVec = DeltaXNormal * Normal;
	float3 DeltaXTangent = DeltaX - DeltaXNormalVec;

	float TangentLength = length(DeltaXTangent);

	// Apply friction only if there's tangent movement
	if (TangentLength > SMALL_NUMBER)
	{
		// d = penetration depth (contact distance)
		// Using penetration as the reference for friction force scaling
		float D = max(Penetration, 0.1f);

		// Static friction threshold
		float StaticThreshold = StaticFriction * D;

		if (TangentLength < StaticThreshold)
		{
			// Static friction: stop tangent movement completely
			DeltaXTangent = float3(0, 0, 0);
		}
		else
		{
			// Kinetic friction: reduce tangent displacement
			float FrictionScale = min(KineticFriction * D / TangentLength, 1.0f);
			DeltaXTangent *= (1.0f - FrictionScale);
		}
	}

	// Reconstruct position with friction-adjusted displacement
	PredictedPos = OriginalPos + DeltaXNormalVec + DeltaXTangent;
}

/**
 * @brief Apply collision response with position-level friction
 *
 * @param PredictedPos - Predicted position (will be modified for push-out and friction)
 * @param OriginalPos - Original position before this timestep (for friction calculation)
 * @param Velocity - Velocity (only used for restitution direction check, modified for bounce)
 * @param Normal - Collision surface normal
 * @param Penetration - Penetration depth
 * @param Friction - Friction coefficient (used for both static and kinetic)
 * @param Restitution - Bounce coefficient
 */
void ApplyCollisionResponseWithFriction(
	inout float3 PredictedPos,
	float3 OriginalPos,
	inout float3 Velocity,
	float3 Normal,
	float Penetration,
	float Friction,
	float Restitution)
{
	// Apply position-level friction (handles push-out internally)
	ApplyPositionLevelFriction(PredictedPos, OriginalPos, Normal, Penetration, Friction, Friction);

	// Apply restitution to velocity for bounce effect
	// This affects the NEXT timestep's prediction, not current position
	float VelNormal = dot(Velocity, Normal);
	if (VelNormal < 0.0f)
	{
		// Reflect normal velocity component
		Velocity -= (1.0f + Restitution) * VelNormal * Normal;
	}
}
