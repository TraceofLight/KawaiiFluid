// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file FluidForceAccumulation.ush
 * @brief Unified cohesion and viscosity force accumulation utilities.
 *
 * This file combines cohesion, XSPH viscosity, and Laplacian viscosity in
 * a single neighbor traversal for improved memory efficiency.
 */

#pragma once

#include "/Plugin/KawaiiFluidSystem/Public/FluidGPUPhysics.ush"

//=============================================================================
// Force Accumulation Result Structure
// Contains all forces calculated in a single neighbor loop
//=============================================================================
/**
 * @brief Data layout for FForceAccumulationResult
 */
struct FForceAccumulationResult
{
    float3 CohesionAccel;       // Cohesion acceleration (cm/s^2)
    float3 ViscosityCorrection; // XSPH velocity correction (unnormalized)
    float3 LaplacianForce;      // Laplacian viscosity force
    float WeightSum;            // For XSPH normalization
};

//=============================================================================
// Unified Force Accumulation Function
//
// Calculates Cohesion + Viscosity forces in a single neighbor loop using
// previous frame's neighbor cache (double buffering).
//
// Parameters:
//   idx                  - Current particle index
//   position             - Current particle position (cm)
//   velocity             - Current particle velocity (cm/s)
//   mass                 - Current particle mass (kg)
//   density              - Current particle density (kg/m^3)
//   cohesionStrength     - Surface tension strength coefficient
//   maxCohesionForce     - Stability clamp for cohesion
//   restDensity          - Rest density for K_ij correction (kg/m^3)
//   viscosityCoefficient - Viscosity strength (0~1)
//   poly6Coeff           - Poly6 kernel coefficient
//   viscLaplacianCoeff   - Laplacian viscosity coefficient (45 / PI * h^6)
//   smoothingRadius      - SPH kernel radius (cm)
//   prevNeighborList     - Previous frame neighbor indices
//   prevNeighborCounts   - Previous frame neighbor counts per particle
//   particleCount        - Current frame particle count
//   prevParticleCount    - Previous frame particle count (bounds check)
//   particles            - Particle buffer (for neighbor data access)
//
// Returns:
//   FForceAccumulationResult containing all calculated forces
//=============================================================================

/**
 * @brief Computes per-particle force accumulation
 */
FForceAccumulationResult CalculateForceAccumulation(
    uint idx,
    float3 position,
    float3 velocity,
    float mass,
    float density,
    // Cohesion params
    float cohesionStrength,
    float maxCohesionForce,
    float restDensity,
    // Viscosity params
    float viscosityCoefficient,
    float poly6Coeff,
    float viscLaplacianCoeff,
    // Common params
    float smoothingRadius,
    // Buffers
    StructuredBuffer<uint> prevNeighborList,
    StructuredBuffer<uint> prevNeighborCounts,
    int particleCount,
    int prevParticleCount,
    RWStructuredBuffer<FGPUFluidParticle> particles)
{
    FForceAccumulationResult result;
    result.CohesionAccel = float3(0.0f, 0.0f, 0.0f);
    result.ViscosityCorrection = float3(0.0f, 0.0f, 0.0f);
    result.LaplacianForce = float3(0.0f, 0.0f, 0.0f);
    result.WeightSum = 0.0f;

    // Pre-compute kernel parameters
    float h_m = smoothingRadius * CM_TO_M;  // Convert cm to m for kernel
    float h2 = h_m * h_m;
    float smoothingRadiusSq_cm = smoothingRadius * smoothingRadius;

    // Particle properties
    float m_i = mass;
    float rho_i = max(density, SMALL_NUMBER);

    // Accumulators
    float3 cohesionForce = float3(0.0f, 0.0f, 0.0f);

    // Cache validity mask: idx must be < prevParticleCount
    float cacheValidMask = step((float)idx + 0.5f, (float)prevParticleCount);

    // Safe index for neighbor count access (clamp to valid range)
    uint safeIdx = min(idx, max((uint)prevParticleCount - 1, 0u));
    uint cachedCount = prevNeighborCounts[safeIdx];
    // If cache invalid, force cachedCount to 0
    cachedCount = (uint)((float)cachedCount * cacheValidMask);

    uint baseIdx = idx * MAX_NEIGHBORS_PER_PARTICLE;

    // Safe particle count for clamping (at least 1 to avoid issues)
    uint maxSafeIdx = max((uint)particleCount - 1, 0u);

    //=========================================================================
    // Single Neighbor Loop: Process all forces together
    // FULLY BRANCHLESS: All conditions handled via *mask multiplication
    //=========================================================================
    for (uint n = 0; n < cachedCount; ++n)
    {
        uint neighborIdx = prevNeighborList[baseIdx + n];

        //=====================================================================
        // Validity Masks (branchless)
        //=====================================================================
        // 1. Self mask: neighborIdx != idx
        float selfMask = 1.0f - step((float)idx - 0.5f, (float)neighborIdx)
                              * step((float)neighborIdx, (float)idx + 0.5f);

        // 2. Bounds mask: neighborIdx < particleCount
        float boundsMask = step((float)neighborIdx + 0.5f, (float)particleCount);

        // Combined validity mask
        float validMask = selfMask * boundsMask;

        // Safe memory access: clamp to valid range (prevents crash)
        uint safeNeighborIdx = min(neighborIdx, maxSafeIdx);
        FGPUFluidParticle neighbor = particles[safeNeighborIdx];

        // 3. Attached mask: skip CPU-attached neighbors
        float attachedMask = 1.0f - (float)HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
        validMask *= attachedMask;

        // Use current frame's Position (not PredictedPosition which isn't computed yet)
        float3 r_cm = position - neighbor.Position;
        float r2_cm = dot(r_cm, r_cm);

        // 4. Distance mask: SMALL_NUMBER <= r2_cm <= smoothingRadiusSq_cm
        float distMinMask = step(SMALL_NUMBER, r2_cm);
        float distMaxMask = step(r2_cm, smoothingRadiusSq_cm);
        validMask *= distMinMask * distMaxMask;

        // Safe rsqrt: avoid div by zero (r2_cm could be 0 if masked out)
        float safeR2_cm = max(r2_cm, SMALL_NUMBER);
        float rLenInv_cm = rsqrt(safeR2_cm);
        float dist_cm = safeR2_cm * rLenInv_cm;
        float dist_m = dist_cm * CM_TO_M;
        float r2_m = dist_m * dist_m;

        // 5. Kernel range mask: dist_m < h_m (redundant but kept for safety)
        float kernelMask = step(dist_m + SMALL_NUMBER, h_m);
        validMask *= kernelMask;

        //=====================================================================
        // 1. Cohesion Force (Akinci 2013)
        //=====================================================================
        float m_j = neighbor.Mass;
        float rho_j = max(neighbor.Density, SMALL_NUMBER);

        // K_ij correction factor for particle deficiency (Akinci 2013)
        float K_ij = (2.0f * restDensity) / (rho_i + rho_j);
        K_ij = clamp(K_ij, 0.5f, 2.0f);

        // Cohesion kernel: attractive force that peaks at ~0.5h
        float cohesionWeight = CohesionKernel(dist_m, h_m);

        // Direction: particle -> neighbor (attraction)
        float3 direction = -r_cm * rLenInv_cm;

        // Force magnitude with mask
        float forceMag = m_i * m_j * cohesionWeight;
        cohesionForce += K_ij * cohesionStrength * forceMag * direction * validMask;

        //=====================================================================
        // 2. XSPH Viscosity (Velocity Smoothing)
        //=====================================================================
        float w = Poly6Kernel(r2_m, h2) * poly6Coeff;
        float3 velDiff = neighbor.Velocity - velocity;

        result.ViscosityCorrection += velDiff * w * validMask;
        result.WeightSum += w * validMask;

        //=====================================================================
        // 3. Laplacian Viscosity (Physical Drag)
        //=====================================================================
        float laplacian = ViscosityLaplacian(dist_m, h_m, viscLaplacianCoeff);
        float neighborDensity = max(neighbor.Density, 0.001f);
        result.LaplacianForce += velDiff * laplacian * neighbor.Mass / neighborDensity * validMask;
    }

    //=========================================================================
    // Finalize Cohesion Force
    // No branch: when cohesionStrength=0, cohesionForce is already zero
    //=========================================================================
    // Clamp for stability (branchless using min)
    float forceLen = length(cohesionForce);
    float clampScale = min(1.0f, maxCohesionForce / max(forceLen, SMALL_NUMBER));
    cohesionForce *= clampScale;

    // Convert to acceleration (cm/s^2)
    // cohesionForce is in (kg * kg * kernel) space, divide by mass for acceleration
    // Then multiply by 100 to convert m/s^2 to cm/s^2
    // When cohesionStrength=0, cohesionForce=0 so result is 0
    result.CohesionAccel = (cohesionForce / max(m_i, SMALL_NUMBER)) * 100.0f;

    return result;
}
