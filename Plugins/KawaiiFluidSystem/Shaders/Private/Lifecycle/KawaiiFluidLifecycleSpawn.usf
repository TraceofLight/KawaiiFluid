// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidLifecycleSpawn.usf
 * @brief Lifecycle spawn and append copy shaders
 */

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidGPUPhysics.ush"

//=============================================================================
// CopyParticlesCS parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> SourceParticles;
RWStructuredBuffer<FGPUFluidParticle> DestParticles;
StructuredBuffer<uint> ParticleCountBuffer;
int SourceOffset;
int DestOffset;
int CopyCount;
int bReadCountFromGPU;

/**
 * @brief Copy existing particles into destination buffer
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CopyParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Index = DispatchThreadId.x;
	uint EffectiveCopyCount = bReadCountFromGPU ? ParticleCountBuffer[6] : (uint)CopyCount;
	if (Index >= EffectiveCopyCount)
	{
		return;
	}

	uint SourceIndex = SourceOffset + Index;
	uint DestIndex = DestOffset + Index;
	DestParticles[DestIndex] = SourceParticles[SourceIndex];
}

//=============================================================================
// SpawnParticlesCS parameters
//=============================================================================

/**
 * @brief Data layout for spawn request (must match C++ FGPUSpawnRequest)
 */
struct FSpawnRequest
{
	float3 Position;
	float Radius;
	float3 Velocity;
	float Mass;
	int SourceID;
	int ActorID;
	int Reserved1;
	int Reserved2;
};

StructuredBuffer<FSpawnRequest> SpawnRequests;
RWStructuredBuffer<FGPUFluidParticle> Particles;
RWStructuredBuffer<uint> ParticleCounter;
RWStructuredBuffer<uint> SourceCounters;

int SpawnRequestCount;
int MaxParticleCount;
int NextParticleID;
int MaxSourceCount;
float DefaultRadius;
float DefaultMass;

/**
 * @brief Spawn new particles from requests
 */
[numthreads(64, 1, 1)]
void SpawnParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint RequestIndex = DispatchThreadId.x;
	if (RequestIndex >= (uint)SpawnRequestCount)
	{
		return;
	}

	FSpawnRequest Request = SpawnRequests[RequestIndex];

	uint ParticleIndex;
	InterlockedAdd(ParticleCounter[0], 1, ParticleIndex);
	if (ParticleIndex >= (uint)MaxParticleCount)
	{
		InterlockedAdd(ParticleCounter[0], -1);
		return;
	}

	FGPUFluidParticle NewParticle;
	NewParticle.Position = Request.Position;
	NewParticle.PredictedPosition = Request.Position;
	NewParticle.Velocity = Request.Velocity;
	NewParticle.Mass = (Request.Mass > 0.0f) ? Request.Mass : DefaultMass;
	NewParticle.Density = 0.0f;
	NewParticle.Lambda = 0.0f;
	NewParticle.ParticleID = NextParticleID + (int)RequestIndex;
	NewParticle.SourceID = Request.SourceID;
	NewParticle.Flags = GPU_PARTICLE_FLAG_NONE;
	NewParticle.NeighborCount = 0;

	Particles[ParticleIndex] = NewParticle;

	int SourceIndex = Request.SourceID;
	if (SourceIndex >= 0 && SourceIndex < MaxSourceCount)
	{
		InterlockedAdd(SourceCounters[SourceIndex], 1);
	}
}
