// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidLifecycleDespawn.usf
 * @brief Lifecycle despawn marking, compaction, and counter update shaders
 */

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

/**
 * @brief Data layout for brush despawn request
 */
struct FDespawnBrushRequest
{
	float3 Center;
	float RadiusSq;
};

// Shared resources across despawn kernels
StructuredBuffer<FDespawnBrushRequest> BrushRequests;
StructuredBuffer<int> DespawnSourceIDs;
StructuredBuffer<FGPUFluidParticle> Particles;
RWStructuredBuffer<uint> OutAliveMask;
StructuredBuffer<uint> ParticleCountBuffer;
int BrushRequestCount;
int DespawnSourceIDCount;

StructuredBuffer<uint> PerSourceExcess;
int FilterSourceID;
RWStructuredBuffer<uint> IDHistogram;
int IDShiftBits;
RWStructuredBuffer<uint> OldestThreshold;
RWStructuredBuffer<uint> BoundaryCounter;

StructuredBuffer<uint> AliveMask;
RWStructuredBuffer<uint> SourceCounters;
int MaxSourceCount;

StructuredBuffer<uint> MarkedFlags;
StructuredBuffer<uint> PrefixSums;
RWStructuredBuffer<FGPUFluidParticle> CompactedParticles;
RWStructuredBuffer<uint> OutTotalCount;
int ParticleCount;

groupshared uint SharedHist[256];

/**
 * @brief Initialize alive mask to 1 for all current particles
 */
[numthreads(256, 1, 1)]
void InitAliveMaskCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;
	if (Index < ParticleCountBuffer[6])
	{
		OutAliveMask[Index] = 1;
	}
}

/**
 * @brief Mark particles inside any brush as dead
 */
[numthreads(256, 1, 1)]
void MarkDespawnByBrushCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;
	const uint Count = ParticleCountBuffer[6];
	if (Index >= Count)
	{
		return;
	}

	float3 Pos = Particles[Index].Position;
	for (int BrushIndex = 0; BrushIndex < BrushRequestCount; ++BrushIndex)
	{
		float3 Delta = Pos - BrushRequests[BrushIndex].Center;
		if (dot(Delta, Delta) <= BrushRequests[BrushIndex].RadiusSq)
		{
			OutAliveMask[Index] = 0;
			return;
		}
	}
}

/**
 * @brief Mark particles that belong to despawn source IDs as dead
 */
[numthreads(256, 1, 1)]
void MarkDespawnBySourceCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;
	const uint Count = ParticleCountBuffer[6];
	if (Index >= Count)
	{
		return;
	}

	int SourceId = Particles[Index].SourceID;
	for (int SourceIndex = 0; SourceIndex < DespawnSourceIDCount; ++SourceIndex)
	{
		if (SourceId == DespawnSourceIDs[SourceIndex])
		{
			OutAliveMask[Index] = 0;
			return;
		}
	}
}

/**
 * @brief Build 256-bucket histogram of particle IDs for oldest-despawn
 */
[numthreads(256, 1, 1)]
void BuildIDHistogramCS(uint3 GroupId : SV_GroupID, uint3 GroupThreadId : SV_GroupThreadID, uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint ThreadIndex = GroupThreadId.x;
	const uint Count = ParticleCountBuffer[6];

	SharedHist[ThreadIndex] = 0;
	GroupMemoryBarrierWithGroupSync();

	const uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex < Count && Particles[ParticleIndex].SourceID == FilterSourceID)
	{
		uint ParticleId = (uint)Particles[ParticleIndex].ParticleID;
		uint Bucket = ParticleId >> (uint)IDShiftBits;
		Bucket = min(Bucket, 255u);
		InterlockedAdd(SharedHist[Bucket], 1);
	}

	GroupMemoryBarrierWithGroupSync();
	if (SharedHist[ThreadIndex] > 0)
	{
		InterlockedAdd(IDHistogram[ThreadIndex], SharedHist[ThreadIndex]);
	}
}

/**
 * @brief Find threshold bucket for oldest-despawn
 */
[numthreads(1, 1, 1)]
void FindOldestThresholdCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	int RemoveCount = (int)PerSourceExcess[FilterSourceID];
	if (RemoveCount <= 0)
	{
		OldestThreshold[0] = 0;
		OldestThreshold[1] = 0;
		return;
	}

	uint AccumulatedCount = 0;
	for (uint BucketIndex = 0; BucketIndex < 256; ++BucketIndex)
	{
		uint BucketCount = IDHistogram[BucketIndex];
		if (AccumulatedCount + BucketCount >= (uint)RemoveCount)
		{
			OldestThreshold[0] = BucketIndex;
			OldestThreshold[1] = (uint)RemoveCount - AccumulatedCount;
			return;
		}
		AccumulatedCount += BucketCount;
	}

	OldestThreshold[0] = 255;
	OldestThreshold[1] = (uint)RemoveCount - AccumulatedCount;
}

/**
 * @brief Mark oldest particles for removal using threshold and boundary atomic
 */
[numthreads(256, 1, 1)]
void MarkOldestParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;
	const uint Count = ParticleCountBuffer[6];
	if (Index >= Count)
	{
		return;
	}

	if (Particles[Index].SourceID != FilterSourceID)
	{
		return;
	}

	uint ParticleId = (uint)Particles[Index].ParticleID;
	uint Bucket = ParticleId >> (uint)IDShiftBits;
	Bucket = min(Bucket, 255u);

	uint ThresholdBucket = OldestThreshold[0];
	uint RemainingCount = OldestThreshold[1];

	if (Bucket < ThresholdBucket)
	{
		OutAliveMask[Index] = 0;
	}
	else if (Bucket == ThresholdBucket && RemainingCount > 0)
	{
		uint PreviousCount;
		InterlockedAdd(BoundaryCounter[0], 1, PreviousCount);
		if (PreviousCount < RemainingCount)
		{
			OutAliveMask[Index] = 0;
		}
	}
}

/**
 * @brief Decrement source counters for dead particles
 */
[numthreads(256, 1, 1)]
void UpdateSourceCountersDespawnCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;
	const uint Count = ParticleCountBuffer[6];
	if (Index >= Count)
	{
		return;
	}

	if (AliveMask[Index] == 0)
	{
		int SourceId = Particles[Index].SourceID;
		if (SourceId >= 0 && SourceId < MaxSourceCount)
		{
			InterlockedAdd(SourceCounters[SourceId], -1);
		}
	}
}

/**
 * @brief Compact alive particles into contiguous buffer
 */
[numthreads(256, 1, 1)]
void CompactParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;
	if (Index >= (uint)ParticleCount)
	{
		return;
	}

	if (MarkedFlags[Index] == 1)
	{
		uint NewIndex = PrefixSums[Index];
		CompactedParticles[NewIndex] = Particles[Index];
	}
}

/**
 * @brief Write total dead count after compaction
 */
[numthreads(1, 1, 1)]
void WriteTotalCountCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (ParticleCount > 0)
	{
		uint LastIndex = ParticleCount - 1;
		uint TotalAlive = PrefixSums[LastIndex] + MarkedFlags[LastIndex];
		OutTotalCount[0] = ParticleCount - TotalAlive;
	}
	else
	{
		OutTotalCount[0] = 0;
	}
}


