// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidSimulationDataLayout.usf
 * @brief Shader implementation for KawaiiFluidSimulationDataLayout
 */

// Particle SoA (Structure of Arrays) Conversion Shaders
//
// Memory bandwidth optimization:
// 1. Split AoS FGPUFluidParticle into separate field buffers
// 2. Half-precision packing for Velocity/Density/Lambda (50% bandwidth reduction)
// 3. Uniform Mass (removed from per-particle storage)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

// Half Precision Packing Utilities: defined in KawaiiFluidParticleCore.ush
// PackHalf2, UnpackHalf2, PackVelocity, UnpackVelocity, PackDensityLambda, UnpackDensityLambda

//=============================================================================
// Split Pass: AoS → SoA
// Converts FGPUFluidParticle (64 bytes) into separate field buffers
// With half-precision packing for bandwidth optimization
//=============================================================================

StructuredBuffer<FGPUFluidParticle> SourceParticles;

// Full precision (Position is critical for simulation stability)
RWBuffer<float> OutPositions;              // float3 packed as 3 floats
RWBuffer<float> OutPredictedPositions;     // float3 packed as 3 floats

// Half precision packed (bandwidth optimization)
RWBuffer<uint2> OutPackedVelocities;       // uint2 = half4 (vel.xy, vel.z, padding)
RWBuffer<uint> OutPackedDensityLambda;     // uint = half2 (density, lambda)

// Other fields
RWBuffer<uint> OutFlags;                   // uint
RWBuffer<uint> OutNeighborCounts;          // uint
RWBuffer<int> OutParticleIDs;              // int
RWBuffer<int> OutSourceIDs;                // int

int SplitParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

/**
 * @brief Compute shader entry point for SplitAoSToSoACS
 */
[numthreads(256, 1, 1)]
void SplitAoSToSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
		return;

	FGPUFluidParticle P = SourceParticles[Idx];

	// Position: full Precision (float3 Stored as 3 consecutive floats)
	uint Idx3 = Idx * 3;
	OutPositions[Idx3 + 0] = P.Position.x;
	OutPositions[Idx3 + 1] = P.Position.y;
	OutPositions[Idx3 + 2] = P.Position.z;

	OutPredictedPositions[Idx3 + 0] = P.PredictedPosition.x;
	OutPredictedPositions[Idx3 + 1] = P.PredictedPosition.y;
	OutPredictedPositions[Idx3 + 2] = P.PredictedPosition.z;

	// Velocity: half Precision packed (12B → 8B) for SolveDensityPressure
	OutPackedVelocities[Idx] = PackVelocity(P.Velocity);

	// Density + Lambda: half Precision packed (8B → 4B)
	OutPackedDensityLambda[Idx] = PackDensityLambda(P.Density, P.Lambda);

	// Other fields: unchanged
	OutFlags[Idx] = P.Flags;
	OutNeighborCounts[Idx] = P.NeighborCount;
	OutParticleIDs[Idx] = P.ParticleID;
	OutSourceIDs[Idx] = P.SourceID;
}

//=============================================================================
// Merge Pass: SoA → AoS
// Converts separate field buffers back into FGPUFluidParticle (64 bytes)
// Unpacks half-precision data back to full precision
//=============================================================================

Buffer<float> InPositions;
Buffer<float> InPredictedPositions;
// Half precision packed (bandwidth optimization)
Buffer<uint2> InPackedVelocities;
Buffer<uint> InPackedDensityLambda;
Buffer<uint> InFlags;
Buffer<uint> InNeighborCounts;
Buffer<int> InParticleIDs;
Buffer<int> InSourceIDs;

// Uniform mass for all particles (from Preset)
float MergeUniformParticleMass;

RWStructuredBuffer<FGPUFluidParticle> TargetParticles;

int MergeParticleCount;

/**
 * @brief Compute shader entry point for MergeSoAToAoSCS
 */
[numthreads(256, 1, 1)]
void MergeSoAToAoSCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
		return;

	// Read from separate field buffers
	uint Idx3 = Idx * 3;

	FGPUFluidParticle P;

	// Position: full precision
	P.Position.x = InPositions[Idx3 + 0];
	P.Position.y = InPositions[Idx3 + 1];
	P.Position.z = InPositions[Idx3 + 2];

	P.PredictedPosition.x = InPredictedPositions[Idx3 + 0];
	P.PredictedPosition.y = InPredictedPositions[Idx3 + 1];
	P.PredictedPosition.z = InPredictedPositions[Idx3 + 2];

	// Velocity: unpack from half-precision (8B packed)
	P.Velocity = UnpackVelocity(InPackedVelocities[Idx]);

	// Density + Lambda: unpack from half-precision (4B packed)
	float Density, lambda;
	UnpackDensityLambda(InPackedDensityLambda[Idx], Density, lambda);
	P.Density = Density;
	P.Lambda = lambda;

	// Mass: uniform constant (same for all particles)
	P.Mass = MergeUniformParticleMass;

	// Other fields: unchanged
	P.Flags = InFlags[Idx];
	P.NeighborCount = InNeighborCounts[Idx];
	P.ParticleID = InParticleIDs[Idx];
	P.SourceID = InSourceIDs[Idx];

	TargetParticles[Idx] = P;
}

//=============================================================================
// Stats Compact Pass (Merged from FluidStatsCompact.usf)
//=============================================================================
//=============================================================================
// Compact Stats Structure - Basic (must match C++ FCompactParticleStats)
// 32 bytes per particle - for non-ISM/non-Shadow mode
//=============================================================================
/**
 * @brief Data layout for FCompactParticleStats
 */
struct FCompactParticleStats
{
    float3 Position;    // 12 bytes
    int ParticleID;     // 4 bytes (16)
    int SourceID;       // 4 bytes
    uint NeighborCount; // 4 bytes
    uint Flags;         // 4 bytes
    float Padding;      // 4 bytes (32)
};

//=============================================================================
// Compact Stats Structure - Extended (must match C++ FCompactParticleStatsEx)
// 48 bytes per particle - includes Velocity for ISM/Shadow
//=============================================================================
/**
 * @brief Data layout for FCompactParticleStatsEx
 */
struct FCompactParticleStatsEx
{
    float3 Position;    // 12 bytes
    int ParticleID;     // 4 bytes (16)
    float3 Velocity;    // 12 bytes
    int SourceID;       // 4 bytes (32)
    uint NeighborCount; // 4 bytes
    float3 Padding;     // 12 bytes (48)
};

//=============================================================================
// Shader Parameters
//=============================================================================
StructuredBuffer<FGPUFluidParticle> InParticles;

// Output buffer - one of these will be bound depending on mode
RWStructuredBuffer<FCompactParticleStats> OutCompactStats;
RWStructuredBuffer<FCompactParticleStatsEx> OutCompactStatsEx;

//=============================================================================
// Main Compute Shader - Basic Mode (32 bytes output)
// Extracts: Position, ParticleID, SourceID, NeighborCount
//=============================================================================
#define THREAD_GROUP_SIZE 256

/**
 * @brief Compute shader entry point for CompactStatsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CompactStatsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint Idx = DispatchThreadId.x;
    if (Idx >= ParticleCountBuffer[6])
    {
        return;
    }

    FGPUFluidParticle Particle = InParticles[Idx];

    FCompactParticleStats Compact;
    Compact.Position = Particle.Position;
    Compact.ParticleID = Particle.ParticleID;
    Compact.SourceID = Particle.SourceID;
    Compact.NeighborCount = Particle.NeighborCount;
    Compact.Flags = Particle.Flags;
    Compact.Padding = 0.0f;

    OutCompactStats[Idx] = Compact;
}

//=============================================================================
// Main Compute Shader - Extended Mode (48 bytes output)
// Extracts: Position, ParticleID, Velocity, SourceID, NeighborCount
//=============================================================================
/**
 * @brief Compute shader entry point for CompactStatsExCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CompactStatsExCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint Idx = DispatchThreadId.x;
    if (Idx >= ParticleCountBuffer[6])
    {
        return;
    }

    FGPUFluidParticle Particle = InParticles[Idx];

    FCompactParticleStatsEx Compact;
    Compact.Position = Particle.Position;
    Compact.ParticleID = Particle.ParticleID;
    Compact.Velocity = Particle.Velocity;
    Compact.SourceID = Particle.SourceID;
    Compact.NeighborCount = Particle.NeighborCount;
    Compact.Padding = float3(0, 0, 0);

    OutCompactStatsEx[Idx] = Compact;
}
