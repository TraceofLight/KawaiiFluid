// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidSimulationDensityPressure.usf
 * @brief Shader implementation for KawaiiFluidSimulationDensityPressure
 */

// GPU Fluid Physics - Combined Density and Pressure Pass
// Merges ComputeDensity and SolvePressure into single neighbor traversal
//
// Optimizations:
// 1. Pass Integration: Reduces neighbor search from 2x to 1x per iteration
// 2. rsqrt: Uses fast inverse square root instead of sqrt
// 3. Loop Unroll: Explicit 27-cell unrolling for cellRadius=1 case
// 4. Neighbor Caching: First iteration builds neighbor list, subsequent iterations reuse
// 5. Half Precision: Velocity/Density/Lambda as FP16 (50% bandwidth reduction)
// 6. Uniform Mass: Single mass constant instead of per-particle buffer (4B/neighbor saved)
// 7. Shared Memory (LDS): Tile-based caching for 256 spatially adjacent particles
// 8. ALU Optimization: Inline kernels, single rsqrt, branchless tensile/ST, precomputed constants
//
// NOTE: Wave Intrinsics removed - unsafe in divergent loops (thread retire causes garbage reads)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryParticles.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidSpatialHash.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidMortonUtils.ush"  // Unified Morton code functions

// Half Precision Packing Utilities: defined in KawaiiFluidParticleCore.ush
// PackHalf2, UnpackHalf2, PackVelocity, UnpackVelocity, PackDensityLambda, UnpackDensityLambda

//=============================================================================
// Shared Memory (LDS) for Tile-Based Caching
// Thread Group (256 threads) processes spatially adjacent particles (Z-Order sorted)
// When neighbor is in same tile, read from LDS (~20x faster than Global Memory)
//
// Memory hierarchy:
// 1. Shared Memory (LDS): ~20 cycles, same tile (256 particles) - SAFE
// 2. Global Memory: ~400 cycles, different tile - SAFE
//
// NOTE: Wave Intrinsics removed - unsafe in divergent neighbor loops.
// When threads finish at different times (due to varying neighbor counts),
// WaveReadLaneAt can read garbage from retired thread registers.
// LDS data persists until entire Thread Group completes, so it's always safe.
//=============================================================================
#define TILE_SIZE THREAD_GROUP_SIZE  // 256

groupshared float3 GsPositions[TILE_SIZE];
groupshared float  GsLambdas[TILE_SIZE];
groupshared uint   GsFlags[TILE_SIZE];

/**
 * @brief Data layout for FNeighborParticleData
 */
struct FNeighborParticleData
{
	float3 Position;
	float Lambda;
	uint Flags;
};

/**
 * @brief Get neighbor data with LDS + Global Memory hierarchy
 * LDS is safe because data persists until Thread Group completes
 */
FNeighborParticleData GetNeighborDataWithTile(
	uint NeighborIdx,
	uint TileStartIdx,
	RWBuffer<float> InPredictedPositions,
	RWBuffer<uint> InPackedDensityLambda,
	RWBuffer<uint> InFlags)
{
	FNeighborParticleData Result;

	// 1. Tile (LDS) check - FAST And SAFE (~20 cycles)
	uint TileOffset = NeighborIdx - TileStartIdx;
	if (TileOffset < TILE_SIZE)
	{
		Result.Position = GsPositions[TileOffset];
		Result.Lambda = GsLambdas[TileOffset];
		Result.Flags = GsFlags[TileOffset];
		return Result;
	}

	// 2. Global Memory - SLOW but SAFE (~400 cycles)
	uint NeighborIdx3 = NeighborIdx * 3;
	Result.Position = float3(
		InPredictedPositions[NeighborIdx3],
		InPredictedPositions[NeighborIdx3 + 1],
		InPredictedPositions[NeighborIdx3 + 2]);

	float NeighborDensity;
	UnpackDensityLambda(InPackedDensityLambda[NeighborIdx], NeighborDensity, Result.Lambda);
	Result.Flags = InFlags[NeighborIdx];

	return Result;
}

//=============================================================================
// Shader Parameters
//=============================================================================

// SoA (Structure of Arrays) Particle Buffers
RWBuffer<float> Positions;                     // [ParticleCount * 3] float3 as 3 consecutive floats
RWBuffer<float> PredictedPositions;            // [ParticleCount * 3] float3 as 3 consecutive floats

// Half-precision packed buffers for bandwidth optimization
RWBuffer<uint2> PackedVelocities;              // [ParticleCount] uint2 = half3 velocity (xy in .x, z in .y)
RWBuffer<uint> PackedDensityLambda;            // [ParticleCount] uint = half2 (density, lambda)

// Uniform particle mass (all particles same mass, from Preset)
float UniformParticleMass;

RWBuffer<uint> Flags;                          // [ParticleCount] uint
RWBuffer<uint> NeighborCountsBuffer;           // [ParticleCount] uint

// Hash table mode (legacy)
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

// Z-Order sorted mode (new)
StructuredBuffer<uint> CellStart;   // CellStart[cellID] = first particle index
StructuredBuffer<uint> CellEnd;     // CellEnd[cellID] = last particle index
int bUseZOrderSorting;              // 1 = use CellStart/End, 0 = use CellCounts/ParticleIndices

// Neighbor caching buffers
RWStructuredBuffer<uint> NeighborList;    // [ParticleCount * MAX_NEIGHBORS_PER_PARTICLE]
RWStructuredBuffer<uint> NeighborCounts;  // [ParticleCount]

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float SmoothingRadius;
float RestDensity;
float Poly6Coeff;
float SpikyCoeff;
float CellSize;
float Compliance;
float DeltaTimeSq;

// Cohesion via Artificial Pressure (PBF paper Eq.13-14)
// TensileK = Cohesion coefficient (scaled 100x from user-facing value)
//            User sets Cohesion=0.1 in editor → TensileK=10 here
// TensileN = CohesionExponent from Physics|Simulation|Cohesion (n value)
// InvW_DeltaQ = precomputed from CohesionDeltaQ (Δq value)
int bEnableTensileInstability;  // 1 if Cohesion > 0
float TensileK;                 // Scaled cohesion (Cohesion * 100, e.g., 5~20)
int TensileN;                   // Cohesion exponent (n = 1~8, typically 4)
float InvW_DeltaQ;              // 1/W(Δq*h), precomputed on CPU

// Iteration control
int IterationIndex;

// Z-Order (Morton Code) bounds for cell ID calculation
// Must match the bounds used in KawaiiFluidSortingPipeline.usf
float3 MortonBoundsMin;     // Simulation bounds minimum
float3 MortonBoundsExtent;  // Simulation bounds extent (Max - Min)

// Hybrid Tiled Z-Order mode flag
// When enabled, uses 21-bit Hybrid keys (3-bit TileHash + 18-bit LocalMorton)
// for unlimited simulation range. Must match KawaiiFluidSortingPipeline.usf
int bUseHybridTiledZOrder;

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;
int bUseBoundaryDensity;

// Z-Order sorted boundary particles (Akinci 2012 + Z-Order optimization)
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int bUseBoundaryZOrder;

// Relative Velocity Pressure Damping (prevents fluid flying away from fast boundaries)
int bEnableRelativeVelocityDamping;
float RelativeVelocityDampingStrength;

// Boundary Velocity Transfer (moved from FluidApplyViscosity for optimization)
// Fluid following moving boundaries - applied during boundary density loop
int bEnableBoundaryVelocityTransfer;
float BoundaryVelocityTransferStrength;
float BoundaryDetachSpeedThreshold;
float BoundaryMaxDetachSpeed;
float BoundaryAdhesionStrength;  // Clamped adhesion (0~1)
int SolverIterationCount;        // Total iterations for strength scaling

// Position-Based Surface Tension (NVIDIA Flex style)
// Creates rounded droplets by minimizing surface area
// bEnablePositionBasedSurfaceTension: 0 = Akinci force-based (default), 1 = Position-Based (experimental)
int bEnablePositionBasedSurfaceTension;
float SurfaceTensionStrength;
float SurfaceTensionActivationDistance;   // cm (h * ratio)
float SurfaceTensionFalloffDistance;      // cm (h * ratio)
int SurfaceTensionSurfaceThreshold;       // Surface particles get stronger ST
float SurfaceTensionVelocityDamping;      // 0~1, under-relaxation (0=full correction, 1=no correction)
float SurfaceTensionTolerance;            // cm, dead zone around activation distance (prevents oscillation)

// Surface Tension max correction
float MaxSurfaceTensionCorrection;        // Max correction per iteration (cm)

//=============================================================================
// Z-Order Cell ID Calculation (uses shader parameters)
// Morton code functions are provided by KawaiiFluidMortonUtils.ush
//=============================================================================

/**
 * @brief Compute Morton-based cell ID from cell coordinates (integer)
 * This version uses shader parameters (MortonBoundsMin, CellSize) directly.
 * IMPORTANT: Must match KawaiiFluidSortingPipeline.usf's ComputeMortonCodesCellBasedCS
 * IMPORTANT: Result is truncated to fit CellStart/CellEnd buffer size (MAX_CELLS)
 */
uint GetMortonCellIDFromCellCoord(int3 CellCoord)
{
	// Hybrid mode: 21-bit key (3-bit TileHash + 18-bit LocalMorton)
	if (bUseHybridTiledZOrder)
	{
		// ComputeHybridTiledKey returns 21-bit key matching MAX_CELLS
		// Mask is a no-op but kept for consistency
		// Hash collisions (8 tile buckets) are filtered by distance check
		return ComputeHybridTiledKey(CellCoord) & (MAX_CELLS - 1);
	}

	// Classic mode: Use bounded Morton code
	// Compute grid minimum cell (same as in KawaiiFluidSortingPipeline.usf)
	int3 GridMin = int3(floor(MortonBoundsMin / CellSize));

	// Offset cell coordinates to make them positive (relative to grid min)
	int3 Offset = CellCoord - GridMin;

	// Clamp to valid range for current preset
	uint3 UOffset = uint3(max(Offset, int3(0, 0, 0)));
	UOffset = min(UOffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

	// Compute Morton code using preset-specific function from KawaiiFluidMortonUtils.ush
	return Morton3D(UOffset.x, UOffset.y, UOffset.z);
}

// NOTE: Legacy macros BUILD_AND_PROCESS_CELL_ZORDER and BUILD_AND_PROCESS_CELL removed.
// All neighbor processing now uses GetNeighborDataWithTile() with:
// 1. Shared Memory (LDS): Same tile (256 particles) - ~20 cycles
// 2. Wave Intrinsics: Same warp (32/64 particles) - ~4 cycles
// 3. Global Memory: Different tile - ~400 cycles

//=============================================================================
// Main Compute Shader - Combined Density + Pressure with Neighbor Caching
//=============================================================================

/**
 * @brief Compute shader entry point for SolveDensityPressureCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void SolveDensityPressureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;

	//=========================================================================
	// PHASE 1: Load data to Shared Memory (ALL threads must participate)
	// This includes threads beyond ParticleCount - they load zeros
	// GroupMemoryBarrierWithGroupSync requires ALL threads to reach it
	//=========================================================================
	uint LocalIdx = Idx % TILE_SIZE;
	uint TileStartIdx = Idx - LocalIdx;

	// Read particle data (or zeros if beyond ParticleCount)
	uint Idx3 = Idx * 3;
	float3 Pos = float3(0.0f, 0.0f, 0.0f);
	uint ParticleFlags = 0;
	float PrevDensity = 0.0f;
	float LambdaIPrev = 0.0f;
	float3 Vel = float3(0.0f, 0.0f, 0.0f);

	if (Idx < ParticleCountBuffer[6])
	{
		Pos = float3(PredictedPositions[Idx3], PredictedPositions[Idx3 + 1], PredictedPositions[Idx3 + 2]);
		ParticleFlags = Flags[Idx];
		UnpackDensityLambda(PackedDensityLambda[Idx], PrevDensity, LambdaIPrev);
		Vel = UnpackVelocity(PackedVelocities[Idx]);
	}

	// Load to Shared Memory (LDS)
	GsPositions[LocalIdx] = Pos;
	GsLambdas[LocalIdx] = LambdaIPrev;
	GsFlags[LocalIdx] = ParticleFlags;

	// Synchronize - ALL threads must hit this barrier
	GroupMemoryBarrierWithGroupSync();

	//=========================================================================
	// PHASE 2: Early returns (AFTER barrier - safe to diverge now)
	//=========================================================================
	if (Idx >= ParticleCountBuffer[6])
	{
		return;
	}

	// Skip attached particles
	if (HasFlag(ParticleFlags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		PackedDensityLambda[Idx] = PackDensityLambda(RestDensity, 0.0f);
		return;
	}

	// Skip sleeping particles - they are excluded from constraint solving
	if (HasFlag(ParticleFlags, GPU_PARTICLE_FLAG_IS_SLEEPING))
	{
		PackedDensityLambda[Idx] = PackDensityLambda(RestDensity, 0.0f);
		return;
	}

	// NEAR_BOUNDARY flag check - used later to skip position corrections
	bool bIsNearBoundary = HasFlag(ParticleFlags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);

	// Convert smoothing radius from cm to m for kernel calculations
	float H = SmoothingRadius * CM_TO_M;
	float H2 = H * H;

	// Accumulators
	float Density = 0.0f;
	float3 GradCI = float3(0.0f, 0.0f, 0.0f);
	float SumGradC2 = 0.0f;
	float3 DeltaP = float3(0.0f, 0.0f, 0.0f);
	uint NeighborCount = 0;
	uint ConstraintCount = 0;  // Averaged Position Update: Count constraints for averaging

	// Position-Based Surface Tension accumulator (surface particles only)
	float3 SurfaceTensionCorrection = float3(0.0f, 0.0f, 0.0f);
	uint SurfaceTensionConstraintCount = 0;

	// Pre-compute inverse RestDensity to convert divisions to multiplications
	// Division is expensive on GPU (~20-30 cycles), multiplication is cheap (~4 cycles)
	float InvRestDensity = 1.0f / RestDensity;

	// Artificial Pressure (PBF Eq.13-14) for Tensile Instability Correction
	// TensileK = Artificial Pressure strength from Physics|Simulation|Stability
	// Higher value = stronger anti-clumping = particles spread evenly
	// When bEnableTensileInstability = 0, TensileKScaled = 0, making Scorr = 0
	float TensileKScaled = TensileK * (float)bEnableTensileInstability;

	// Precompute Tensile exponent multipliers (branchless)
	// TensileN=2: mult4=0, mult6=0 → Ratio^2
	// TensileN=4: mult4=1, mult6=0 → Ratio^4
	// TensileN=6: mult4=1, mult6=1 → Ratio^6
	float TensileMult4 = (TensileN >= 4) ? 1.0f : 0.0f;
	float TensileMult6 = (TensileN >= 6) ? 1.0f : 0.0f;

	// Precompute Surface Tension constants (avoid repeated additions in hot loop)
	float StActivationWithTolerance = SurfaceTensionActivationDistance + SurfaceTensionTolerance;
	float StFalloffRange = SmoothingRadius - SurfaceTensionFalloffDistance;
	float StInvFalloffRange = 1.0f / max(StFalloffRange, 0.001f);
	float StToleranceRange = SurfaceTensionFalloffDistance - StActivationWithTolerance;
	float StInvToleranceRange = 1.0f / max(StToleranceRange, 0.001f);
	bool bDoSurfaceTension = bEnablePositionBasedSurfaceTension && (SurfaceTensionStrength > 0.0f);

	// Precompute combined coefficients
	float MassPoly6 = UniformParticleMass * Poly6Coeff;
	float SpikyScale = SpikyCoeff * CM_TO_M;

	//=========================================================================
	// Branch based on iteration index for neighbor caching
	//=========================================================================
	if (IterationIndex == 0)
	{
		//=====================================================================
		// First Iteration: Build neighbor cache + Compute
		//=====================================================================
		uint CachedCount = 0;

		int3 CenterCell = WorldToCell(Pos, CellSize);
		int CellRadius = (int)ceil(SmoothingRadius / CellSize);

		// Alternate traversal direction per iteration to eliminate Jacobi bias
		// All threads use same direction (no warp divergence), but direction flips each iteration
		int Dir = (IterationIndex & 1) ? -1 : 1;
		int StartR = (Dir > 0) ? -CellRadius : CellRadius;
		int EndR = -StartR + Dir;

		if (bUseZOrderSorting)
		{
			//=================================================================
			// Z-Order Mode: Sequential memory access via CellStart/End
			// Uniform direction per iteration (no warp divergence + no Jacobi bias)
			//=================================================================
			for (int Dz = StartR; Dz != EndR; Dz += Dir)
			{
				for (int Dy = StartR; Dy != EndR; Dy += Dir)
				{
					for (int Dx = StartR; Dx != EndR; Dx += Dir)
					{
						int3 NeighborCell = CenterCell + int3(Dx, Dy, Dz);
						uint CellID = GetMortonCellIDFromCellCoord(NeighborCell);
						uint CellStartIdx = CellStart[CellID];
						uint CellEndIdx = CellEnd[CellID];

						// CRITICAL: Check BOTH CellStart AND CellEnd to prevent infinite loop
						if (CellStartIdx == INVALID_INDEX || CellEndIdx == INVALID_INDEX) continue;

						uint MaxNeighborIdx = min(CellEndIdx, ParticleCountBuffer[6] - 1);
						for (uint NeighborIdx = CellStartIdx; NeighborIdx <= MaxNeighborIdx; ++NeighborIdx)
						{
							// Get neighbor data: LDS first, then Global Memory
							FNeighborParticleData NeighborData = GetNeighborDataWithTile(
								NeighborIdx, TileStartIdx,
								PredictedPositions, PackedDensityLambda, Flags);

							// Skip attached neighbors - they cluster at bone and cause explosion
							if (HasFlag(NeighborData.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
							{
								continue;
							}

							float3 RCm = Pos - NeighborData.Position;
							float R2Cm = dot(RCm, RCm);
							float R2 = R2Cm * CM_TO_M_SQ;

							if (R2 < H2)
							{
								if (CachedCount < MAX_NEIGHBORS_PER_PARTICLE)
								{
									uint CacheIdx = Idx * MAX_NEIGHBORS_PER_PARTICLE + CachedCount;
									NeighborList[CacheIdx] = NeighborIdx;
									CachedCount++;
								}

								//=============================================================
								// ALU Optimized: Inline kernels, single rsqrt, branchless math
								//=============================================================

								// Poly6: inline without branch (already checked R2 < H2)
								float Diff = H2 - R2;
								float Diff3 = Diff * Diff * Diff;
								Density += MassPoly6 * Diff3;
								if (NeighborIdx != Idx) NeighborCount++;

								// Compute rsqrt ONCE - reuse for gradient and surface tension
								float R2Safe = R2 + SMALL_NUMBER;
								float RLenInv = rsqrt(R2Safe);
								float RLen = R2Safe * RLenInv;  // sqrt(R2)

								// Spiky gradient: inline (H - RLen already > 0 since R2 < H2)
								float DiffSpiky = H - RLen;
								float3 R = RCm * CM_TO_M;
								float3 GradW = (R * RLenInv) * (DiffSpiky * DiffSpiky * SpikyScale);

								float3 GradCJ = -GradW * InvRestDensity;
								SumGradC2 += dot(GradCJ, GradCJ);
								GradCI += GradW * InvRestDensity;

								if (NeighborIdx != Idx)
								{
									// Branchless tensile instability
									float Ratio = Diff3 * InvW_DeltaQ;
									float Ratio2 = Ratio * Ratio;
									// RatioN = Ratio2 * (Ratio2^mult4) * (Ratio2^mult6)
									// When mult=0: Ratio2^0 = 1, When mult=1: Ratio2^1 = Ratio2
									float RatioN = Ratio2 * lerp(1.0f, Ratio2, TensileMult4) * lerp(1.0f, Ratio2, TensileMult6);
									float Scorr = -TensileKScaled * RatioN;
									DeltaP += (LambdaIPrev + NeighborData.Lambda + Scorr) * GradW;
									ConstraintCount++;

									// Surface Tension: reuse rsqrt, branchless falloff
									if (bDoSurfaceTension)
									{
										float DistCm = R2Cm * rsqrt(R2Cm + SMALL_NUMBER);  // sqrt approximation
										float3 PullDirection = -RCm * RLenInv * CM_TO_M;  // reuse RLenInv (scaled)

										// Branchless activation check
										float DistFromActivation = DistCm - StActivationWithTolerance;
										float ActivationMask = step(0.0f, DistFromActivation);

										// Branchless falloff
										float FalloffT = saturate((DistCm - SurfaceTensionFalloffDistance) * StInvFalloffRange);
										float StStrength = SurfaceTensionStrength * (1.0f - FalloffT);

										// Quadratic easing
										float NormalizedDist = saturate(DistFromActivation * StInvToleranceRange);
										float EasedStrength = NormalizedDist * NormalizedDist;

										float StCorrectionMag = DistFromActivation * StStrength * EasedStrength * ActivationMask;
										SurfaceTensionCorrection += PullDirection * StCorrectionMag;
										SurfaceTensionConstraintCount += (uint)ActivationMask;
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			//=================================================================
			// Legacy Hash Table Mode
			// Uniform direction per iteration (no warp divergence + no Jacobi bias)
			//=================================================================
			for (int Dz = StartR; Dz != EndR; Dz += Dir)
			{
				for (int Dy = StartR; Dy != EndR; Dy += Dir)
				{
					for (int Dx = StartR; Dx != EndR; Dx += Dir)
					{
						int3 NeighborCell = CenterCell + int3(Dx, Dy, Dz);
						uint Hash = HashCell(NeighborCell);
						uint Count = min(CellCounts[Hash], (uint)MAX_PARTICLES_PER_CELL);
						uint StartIdx = Hash * MAX_PARTICLES_PER_CELL;

						for (uint I = 0; I < Count; ++I)
						{
							uint NeighborIdx = ParticleIndices[StartIdx + I];
							if (NeighborIdx >= ParticleCountBuffer[6])
							{
								continue;
							}

							// Get neighbor data: LDS first, then Global Memory
							FNeighborParticleData NeighborData = GetNeighborDataWithTile(
								NeighborIdx, TileStartIdx,
								PredictedPositions, PackedDensityLambda, Flags);

							// Skip attached neighbors - they cluster at bone and cause explosion
							if (HasFlag(NeighborData.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
							{
								continue;
							}

							float3 RCm = Pos - NeighborData.Position;
							float R2Cm = dot(RCm, RCm);
							float R2 = R2Cm * CM_TO_M_SQ;

							if (R2 < H2)
							{
								// Cache this neighbor
								if (CachedCount < MAX_NEIGHBORS_PER_PARTICLE)
								{
									uint CacheIdx = Idx * MAX_NEIGHBORS_PER_PARTICLE + CachedCount;
									NeighborList[CacheIdx] = NeighborIdx;
									CachedCount++;
								}

								//=============================================================
								// ALU Optimized: Inline kernels, single rsqrt, branchless math
								//=============================================================

								// Poly6: inline without branch
								float Diff = H2 - R2;
								float Diff3 = Diff * Diff * Diff;
								Density += MassPoly6 * Diff3;
								if (NeighborIdx != Idx) NeighborCount++;

								// Compute rsqrt ONCE
								float R2Safe = R2 + SMALL_NUMBER;
								float RLenInv = rsqrt(R2Safe);
								float RLen = R2Safe * RLenInv;

								// Spiky gradient: inline
								float DiffSpiky = H - RLen;
								float3 R = RCm * CM_TO_M;
								float3 GradW = (R * RLenInv) * (DiffSpiky * DiffSpiky * SpikyScale);

								float3 GradCJ = -GradW * InvRestDensity;
								SumGradC2 += dot(GradCJ, GradCJ);
								GradCI += GradW * InvRestDensity;

								if (NeighborIdx != Idx)
								{
									// Branchless tensile instability
									float Ratio = Diff3 * InvW_DeltaQ;
									float Ratio2 = Ratio * Ratio;
									float RatioN = Ratio2 * lerp(1.0f, Ratio2, TensileMult4) * lerp(1.0f, Ratio2, TensileMult6);
									float Scorr = -TensileKScaled * RatioN;
									DeltaP += (LambdaIPrev + NeighborData.Lambda + Scorr) * GradW;
									ConstraintCount++;

									// Surface Tension: reuse rsqrt, branchless falloff
									if (bDoSurfaceTension)
									{
										float DistCm = R2Cm * rsqrt(R2Cm + SMALL_NUMBER);
										float3 PullDirection = -RCm * RLenInv * CM_TO_M;

										float DistFromActivation = DistCm - StActivationWithTolerance;
										float ActivationMask = step(0.0f, DistFromActivation);

										float FalloffT = saturate((DistCm - SurfaceTensionFalloffDistance) * StInvFalloffRange);
										float StStrength = SurfaceTensionStrength * (1.0f - FalloffT);

										float NormalizedDist = saturate(DistFromActivation * StInvToleranceRange);
										float EasedStrength = NormalizedDist * NormalizedDist;

										float StCorrectionMag = DistFromActivation * StStrength * EasedStrength * ActivationMask;
										SurfaceTensionCorrection += PullDirection * StCorrectionMag;
										SurfaceTensionConstraintCount += (uint)ActivationMask;
									}
								}
							}
						}
					}
				}
			}
		}

		// Store cached neighbor Count
		NeighborCounts[Idx] = CachedCount;
	}
	else
	{
		//=====================================================================
		// Subsequent Iterations: Use cached neighbor list (NO Hash lookup!)
		// Alternate iteration direction to eliminate Jacobi bias
		//=====================================================================
		uint CachedCount = NeighborCounts[Idx];
		uint BaseIdx = Idx * MAX_NEIGHBORS_PER_PARTICLE;

		// Alternate direction through cached list based on iteration
		// Even iterations: forward (0 → Count), Odd iterations: reverse (Count → 0)
		bool bReverseOrder = (IterationIndex & 1) != 0;

		for (uint Ni = 0; Ni < CachedCount; ++Ni)
		{
			uint N = bReverseOrder ? (CachedCount - 1 - Ni) : Ni;
			uint NeighborIdx = NeighborList[BaseIdx + N];

			// Get neighbor data: LDS first, then Global Memory
			// LDS is refreshed each iteration via GroupMemoryBarrierWithGroupSync.
			FNeighborParticleData NeighborData = GetNeighborDataWithTile(
				NeighborIdx, TileStartIdx,
				PredictedPositions, PackedDensityLambda, Flags);

			// Skip attached neighbors - they cluster at bone and cause explosion
			if (HasFlag(NeighborData.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
			{
				continue;
			}

			float3 RCm = Pos - NeighborData.Position;
			float R2Cm = dot(RCm, RCm);
			float R2 = R2Cm * CM_TO_M_SQ;

			// Still need distance check as positions changed
			if (R2 < H2)
			{
				//=============================================================
				// ALU Optimized: Inline kernels, single rsqrt, branchless math
				//=============================================================

				// Poly6: inline without branch
				float Diff = H2 - R2;
				float Diff3 = Diff * Diff * Diff;
				Density += MassPoly6 * Diff3;
				if (NeighborIdx != Idx) NeighborCount++;

				// Compute rsqrt ONCE
				float R2Safe = R2 + SMALL_NUMBER;
				float RLenInv = rsqrt(R2Safe);
				float RLen = R2Safe * RLenInv;

				// Spiky gradient: inline
				float DiffSpiky = H - RLen;
				float3 R = RCm * CM_TO_M;
				float3 GradW = (R * RLenInv) * (DiffSpiky * DiffSpiky * SpikyScale);

				float3 GradCJ = -GradW * InvRestDensity;
				SumGradC2 += dot(GradCJ, GradCJ);
				GradCI += GradW * InvRestDensity;

				if (NeighborIdx != Idx)
				{
					// Branchless tensile instability
					float Ratio = Diff3 * InvW_DeltaQ;
					float Ratio2 = Ratio * Ratio;
					float RatioN = Ratio2 * lerp(1.0f, Ratio2, TensileMult4) * lerp(1.0f, Ratio2, TensileMult6);
					float Scorr = -TensileKScaled * RatioN;
					DeltaP += (LambdaIPrev + NeighborData.Lambda + Scorr) * GradW;
					ConstraintCount++;

					// Surface Tension: reuse rsqrt, branchless falloff
					if (bDoSurfaceTension)
					{
						float DistCm = R2Cm * rsqrt(R2Cm + SMALL_NUMBER);
						float3 PullDirection = -RCm * RLenInv * CM_TO_M;

						float DistFromActivation = DistCm - StActivationWithTolerance;
						float ActivationMask = step(0.0f, DistFromActivation);

						float FalloffT = saturate((DistCm - SurfaceTensionFalloffDistance) * StInvFalloffRange);
						float StStrength = SurfaceTensionStrength * (1.0f - FalloffT);

						float NormalizedDist = saturate(DistFromActivation * StInvToleranceRange);
						float EasedStrength = NormalizedDist * NormalizedDist;

						float StCorrectionMag = DistFromActivation * StStrength * EasedStrength * ActivationMask;
						SurfaceTensionCorrection += PullDirection * StCorrectionMag;
						SurfaceTensionConstraintCount += (uint)ActivationMask;
					}
				}
			}
		}
	}

	// Self Contribution to gradient sum
	SumGradC2 += dot(GradCI, GradCI);

	//=========================================================================
	// Boundary Particles Contribution (Akinci 2012)
	// 1. Density: ρ_i += Σ_k ψ_k W(|x_i - x_k|, H)
	// 2. Pressure gradient: Δx_i += λ_i * ψ_k * ∇W(x_i - x_k) / ρ_0
	// 3. Velocity Transfer: Fluid Following moving boundaries (moved from FluidApplyViscosity)
	// This makes fluid particles "see" the Boundary as solid, preventing penetration
	// AND pushes fluid away from boundaries (prevents wall climbing)
	//
	// Two modes:
	// 1. Z-Order Mode: O(K) neighbor search using Morton-sorted BoundaryCellStart/End
	// 2. Legacy Mode: O(M) brute-force (fallback)
	//=========================================================================
	
	// Boundary Velocity Transfer accumulators (XSPH-style smoothing with Boundary)
	float3 BoundaryVelCorrection = float3(0.0f, 0.0f, 0.0f);
	float BoundaryVelWeight = 0.0f;
	
	if (bUseBoundaryDensity && BoundaryParticleCount > 0)
	{
		// Alternate traversal direction per iteration to eliminate Jacobi bias
		int BDir = (IterationIndex & 1) ? -1 : 1;
		int3 BoundaryCenterCell = WorldToCell(Pos, CellSize);
		int BCellRadius = (int)ceil(SmoothingRadius / CellSize);
		int BStartR = (BDir > 0) ? -BCellRadius : BCellRadius;
		int BEndR = -BStartR + BDir;

		if (bUseBoundaryZOrder)
		{
			//=================================================================
			// Z-Order Mode: O(K) neighbor search using Morton code
			// SortedBoundaryParticles are sorted by Morton code
			// Uniform direction per iteration (no warp divergence + no Jacobi bias)
			//=================================================================
			for (int Dz = BStartR; Dz != BEndR; Dz += BDir)
			{
				for (int Dy = BStartR; Dy != BEndR; Dy += BDir)
				{
					for (int Dx = BStartR; Dx != BEndR; Dx += BDir)
					{
						int3 NeighborCell = BoundaryCenterCell + int3(Dx, Dy, Dz);
						uint CellID = GetMortonCellIDFromCellCoord(NeighborCell);
						uint BCellStart = BoundaryCellStart[CellID];
						uint BCellEnd = BoundaryCellEnd[CellID];

						// Skip empty cells
						if (BCellStart == INVALID_INDEX || BCellEnd == INVALID_INDEX)
							continue;

						// Iterate through Boundary particles in this cell
						for (uint Bi = BCellStart; Bi <= BCellEnd; ++Bi)
						{
							FGPUBoundaryParticle Boundary = SortedBoundaryParticles[Bi];
							float3 RCm = Pos - Boundary.Position;
							float R2Cm = dot(RCm, RCm);
							float R2 = R2Cm * CM_TO_M_SQ;

							if (R2 < H2 && R2 > SMALL_NUMBER)
							{
								// Poly6 kernel for Density
								float W = Poly6Kernel(R2, H2);
								Density += Boundary.Psi * Poly6Coeff * W;

								// Pressure gradient Contribution from Boundary
								float3 R = RCm * CM_TO_M;
								float3 GradW = SpikyGradientFast(R, R2, H, H2);
								GradW *= SpikyCoeff * CM_TO_M;

								// Relative velocity damping: reduce pressure when Boundary approaches fluid
								float PressureDampFactor = 1.0f;
								if (bEnableRelativeVelocityDamping)
								{
									float RLen = sqrt(R2Cm);
									if (RLen > SMALL_NUMBER)
									{
										float3 RDir = RCm / RLen;  // Direction from Boundary to fluid
										float3 RelVel = Vel - Boundary.Velocity;

										// Negative dot = Boundary catching up (approaching)
										float ApproachSpeed = -dot(RelVel, RDir);

										// Damp pressure only when approaching (ApproachSpeed > 0)
										if (ApproachSpeed > 0.0f)
										{
											// Smooth falloff based on approach speed (cm/s)
											float DampAmount = saturate(ApproachSpeed / 1000.0f);
											PressureDampFactor = 1.0f - DampAmount * RelativeVelocityDampingStrength;
										}
									}
								}

								DeltaP += PressureDampFactor * LambdaIPrev * Boundary.Psi * GradW;
								
								//=============================================================
								// Boundary Velocity Transfer (moved from FluidApplyViscosity)
								// Fluid Following moving boundaries - XSPH-style smoothing
								//=============================================================
								if (bEnableBoundaryVelocityTransfer && BoundaryAdhesionStrength > 0.0f)
								{
									float3 RelativeVelocity = Vel - Boundary.Velocity;
									float RelativeSpeed = length(RelativeVelocity);

									// Detach factor: high relative speed = less transfer
									float DetachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, RelativeSpeed);
									float TransferFactor = (1.0f - DetachFactor) * BoundaryVelocityTransferStrength;

									float3 VelDiff = Boundary.Velocity - Vel;
									float Contribution = W * Boundary.Psi * BoundaryAdhesionStrength * TransferFactor;
									BoundaryVelCorrection += VelDiff * Contribution;
									BoundaryVelWeight += Contribution;
								}
							}
						}
					}
				}
			}
		}
		else
		{
			//=================================================================
			// Legacy Mode: O(M) brute-force (fallback)
			//=================================================================
			for (int Bi = 0; Bi < BoundaryParticleCount; ++Bi)
			{
				FGPUBoundaryParticle Boundary = BoundaryParticles[Bi];
				float3 RCm = Pos - Boundary.Position;
				float R2Cm = dot(RCm, RCm);
				float R2 = R2Cm * CM_TO_M_SQ;

			if (R2 < H2 && R2 > SMALL_NUMBER)
				{
					// Poly6 kernel for Density
					float W = Poly6Kernel(R2, H2);
					Density += Boundary.Psi * Poly6Coeff * W;

					// Pressure gradient Contribution from Boundary
					float3 R = RCm * CM_TO_M;
					float3 GradW = SpikyGradientFast(R, R2, H, H2);
					GradW *= SpikyCoeff * CM_TO_M;

					// Relative velocity damping: reduce pressure when Boundary approaches fluid
					float PressureDampFactor = 1.0f;
					if (bEnableRelativeVelocityDamping)
					{
						float RLen = sqrt(R2Cm);
						if (RLen > SMALL_NUMBER)
						{
							float3 RDir = RCm / RLen;  // Direction from Boundary to fluid
							float3 RelVel = Vel - Boundary.Velocity;

							// Negative dot = Boundary catching up (approaching)
							float ApproachSpeed = -dot(RelVel, RDir);

							// Damp pressure only when approaching (ApproachSpeed > 0)
							if (ApproachSpeed > 0.0f)
							{
								// Smooth falloff based on approach speed (cm/s)
								float DampAmount = saturate(ApproachSpeed / 1000.0f);
								PressureDampFactor = 1.0f - DampAmount * RelativeVelocityDampingStrength;
							}
						}
					}

					DeltaP += PressureDampFactor * LambdaIPrev * Boundary.Psi * GradW;
					
					//=============================================================
					// Boundary Velocity Transfer (moved from FluidApplyViscosity)
					// Fluid Following moving boundaries - XSPH-style smoothing
					//=============================================================
					if (bEnableBoundaryVelocityTransfer && BoundaryAdhesionStrength > 0.0f)
					{
						float3 RelativeVelocity = Vel - Boundary.Velocity;
						float RelativeSpeed = length(RelativeVelocity);

						// Detach factor: high relative speed = less transfer
						float DetachFactor = smoothstep(BoundaryDetachSpeedThreshold, BoundaryMaxDetachSpeed, RelativeSpeed);
						float TransferFactor = (1.0f - DetachFactor) * BoundaryVelocityTransferStrength;

						float3 VelDiff = Boundary.Velocity - Vel;
						float Contribution = W * Boundary.Psi * BoundaryAdhesionStrength * TransferFactor;
						BoundaryVelCorrection += VelDiff * Contribution;
						BoundaryVelWeight += Contribution;
					}
				}
			}
		}
	}
	
	//=========================================================================
	// Apply Boundary Velocity Transfer
	// Scale by 1/SolverIterationCount to avoid over-application in multi-iteration solver
	// Skip for NEAR_BOUNDARY particles (they follow bone velocity)
	//=========================================================================
	if (BoundaryVelWeight > SMALL_NUMBER && SolverIterationCount > 0 && !bIsNearBoundary)
	{
		float IterationScale = 1.0f / (float)SolverIterationCount;
		Vel += (BoundaryVelCorrection / BoundaryVelWeight) * IterationScale;
	}

	//=========================================
	// Calculate NEW Lambda (XPBD formulation)
	//=========================================
	float C = (Density * InvRestDensity) - 1.0f;
	float AlphaTilde = Compliance / max(DeltaTimeSq, 0.00001f);

	float Lambda = LambdaIPrev;
	if (C > 0.0f)
	{
		float DeltaLambda = (-C - AlphaTilde * LambdaIPrev) / (SumGradC2 + AlphaTilde);
		Lambda = LambdaIPrev + DeltaLambda;
	}
	// If C <= 0, keep previous Lambda

	//=========================================
	// Apply position correction
	// PBF formula: Δp = (1/ρ₀) × Σⱼ (λᵢ + λⱼ + s_corr) × ∇W
	// This is a SUM over neighbors, not an average
	float3 DeltaPCm = DeltaP * InvRestDensity;
	Pos += DeltaPCm;

	//=========================================
	// Apply Position-Based Surface Tension
	// SurfaceTensionSurfaceThreshold > 0: Surface particles only (water-like)
	// SurfaceTensionSurfaceThreshold == 0: All particles (jelly-like)
	// Skip for NEAR_BOUNDARY particles (they follow bone position)
	//=========================================
	float DeltaTime = sqrt(max(DeltaTimeSq, 0.0001f));  // Recover DeltaTime from DeltaTimeSq
	float InvDeltaTime = 1.0f / DeltaTime;

	if (SurfaceTensionConstraintCount > 0 && !bIsNearBoundary)
	{
		float3 AvgSTCorrection = SurfaceTensionCorrection / (float)SurfaceTensionConstraintCount;

		// Clamp for stability
		float StCorrLen = length(AvgSTCorrection);
		if (StCorrLen > MaxSurfaceTensionCorrection && StCorrLen > SMALL_NUMBER)
		{
			AvgSTCorrection = AvgSTCorrection * (MaxSurfaceTensionCorrection / StCorrLen);
		}

		// Surface scaling: only when SurfaceTensionSurfaceThreshold > 0
		float SurfaceScale = 1.0f;
		if (SurfaceTensionSurfaceThreshold > 0)
		{
			// Surface particles (fewer neighbors) get full ST, interior gets less
			float SurfaceRatio = saturate((float)NeighborCount / (float)SurfaceTensionSurfaceThreshold);
			SurfaceScale = 1.0f - SurfaceRatio;
			SurfaceScale = sqrt(SurfaceScale);  // Smooth transition
		}
		// When SurfaceTensionSurfaceThreshold == 0, SurfaceScale = 1.0 (all particles)

		if (SurfaceScale > 0.01f)
		{
			float Relaxation = 1.0f - SurfaceTensionVelocityDamping;
			float3 PosCorrection = AvgSTCorrection * SurfaceScale * Relaxation;
			Pos += PosCorrection;
			// Also update velocity to match position change (for viscosity compatibility)
			Vel += PosCorrection * InvDeltaTime;
		}
	}

	// Write back to SOA buffers
	// Position: still float3 (precision critical for simulation stability)
	PredictedPositions[Idx3] = Pos.x;
	PredictedPositions[Idx3 + 1] = Pos.y;
	PredictedPositions[Idx3 + 2] = Pos.z;

	// Velocity: packed half3 (bandwidth optimization)
	PackedVelocities[Idx] = PackVelocity(Vel);

	// Density + Lambda: packed half2 (bandwidth optimization)
	PackedDensityLambda[Idx] = PackDensityLambda(Density, Lambda);

	NeighborCountsBuffer[Idx] = NeighborCount;
}
