// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidSimulationPostStep.usf
 * @brief Shader implementation for KawaiiFluidSimulationPostStep
 */

// GPU Fluid Physics - Finalize Positions Pass
// Updates positions from predictions and recalculates velocities

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

//=============================================================================
// Shader Parameters (SoA - Structure of Arrays)
//=============================================================================

RWBuffer<float> Positions;              // float3 as 3 floats
RWBuffer<float> PredictedPositions;     // float3 as 3 floats
RWBuffer<uint2> PackedVelocities;       // half3 packed as uint2 (B plan optimization)
RWBuffer<uint> Flags;

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float DeltaTime;
float MaxVelocity;      // Safety clamp to prevent divergence
float GlobalDamping;    // Velocity damping per substep (1.0 = no damping)

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for FinalizePositionsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void FinalizePositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
	{
		return;
	}

	uint Idx3 = Idx * 3;
	uint ParticleFlags = Flags[Idx];

	// Read current values
	float3 Position = float3(Positions[Idx3], Positions[Idx3 + 1], Positions[Idx3 + 2]);
	float3 PredictedPosition = float3(PredictedPositions[Idx3], PredictedPositions[Idx3 + 1], PredictedPositions[Idx3 + 2]);
	float3 Velocity = UnpackVelocity(PackedVelocities[Idx]);

	// Skip CPU-attached particles (they follow bone Position directly)
	if (HasFlag(ParticleFlags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		// For CPU-attached particles, just sync Position
		Positions[Idx3] = PredictedPosition.x;
		Positions[Idx3 + 1] = PredictedPosition.y;
		Positions[Idx3 + 2] = PredictedPosition.z;
		return;
	}

	// NEAR_BOUNDARY particles: Position and Velocity already set by ApplyBoneTransform
	// Don't recalculate Velocity from Position change (would cause explosion)
	if (HasFlag(ParticleFlags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY))
	{
		Positions[Idx3] = PredictedPosition.x;
		Positions[Idx3 + 1] = PredictedPosition.y;
		Positions[Idx3 + 2] = PredictedPosition.z;

		// Keep bone Velocity, just apply damping
		Velocity *= GlobalDamping;
		PackedVelocities[Idx] = PackVelocity(Velocity);

		Flags[Idx] = ClearFlag(ParticleFlags, GPU_PARTICLE_FLAG_JUST_DETACHED);
		return;
	}

	// Store old Position for Velocity calculation
	float3 OldPosition = Position;

	// Update Position from predicted Position
	Position = PredictedPosition;

	// Recalculate Velocity from Position change (pure PBF formula per paper Algorithm 1 line 22)
	// v = (x* - x) / dt
	float InvDt = 1.0f / max(DeltaTime, 0.0001f);
	Velocity = (Position - OldPosition) * InvDt;

	// Safety clamp: prevent extreme velocities that could cause divergence
	float VelocityMag = length(Velocity);
	if (VelocityMag > MaxVelocity)
	{
		Velocity = (Velocity / VelocityMag) * MaxVelocity;
	}

	// Apply global damping to dissipate energy
	// GlobalDamping of 0.995 means 0.5% energy loss per substep
	Velocity *= GlobalDamping;

	// Clear frame-specific Flags
	ParticleFlags = ClearFlag(ParticleFlags, GPU_PARTICLE_FLAG_JUST_DETACHED);

	// Write back
	Positions[Idx3] = Position.x;
	Positions[Idx3 + 1] = Position.y;
	Positions[Idx3 + 2] = Position.z;

	PackedVelocities[Idx] = PackVelocity(Velocity);

	Flags[Idx] = ParticleFlags;
}

//=============================================================================
// Extract Positions Pass (Merged from FluidExtractPositions.usf)
//=============================================================================
//=============================================================================
// Shader Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> ExtractParticles;
RWStructuredBuffer<float3> ExtractedPositions;
int bUsePredictedPosition;

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractPositionsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
	{
		return;
	}

	FGPUFluidParticle Particle = ExtractParticles[Idx];

	// Extract either current position or predicted position
	if (bUsePredictedPosition)
	{
		ExtractedPositions[Idx] = Particle.PredictedPosition;
	}
	else
	{
		ExtractedPositions[Idx] = Particle.Position;
	}
}




//=============================================================================
// Particle Sleeping Pass (Merged from FluidParticleSleeping.usf)
//=============================================================================
//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> SleepingParticles;
RWBuffer<uint> SleepCounters;  // Per-particle sleep frame counter

float SleepVelocityThreshold;    // cm/s, velocity below which particles may sleep
int SleepFrameThreshold;         // Frames of low velocity before sleeping
float WakeVelocityThreshold;     // cm/s, velocity for wake-up

// Neighbor data for wake-up propagation
StructuredBuffer<uint> NeighborList;
StructuredBuffer<uint> NeighborCounts;

#define THREAD_GROUP_SIZE 256
#define MAX_NEIGHBORS_PER_PARTICLE 64

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for UpdateParticleSleepingCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateParticleSleepingCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
	{
		return;
	}

	FGPUFluidParticle Particle = SleepingParticles[Idx];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles participate in sleeping logic normally
	if (HasFlag(Particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		// Clear sleeping flag for CPU-attached particles
		Particle.Flags = ClearFlag(Particle.Flags, GPU_PARTICLE_FLAG_IS_SLEEPING);
		SleepCounters[Idx] = 0;
		SleepingParticles[Idx] = Particle;
		return;
	}

	float Speed = length(Particle.Velocity);
	bool bWasSleeping = HasFlag(Particle.Flags, GPU_PARTICLE_FLAG_IS_SLEEPING);
	uint SleepCounter = SleepCounters[Idx];

	//=========================================================================
	// Wake-up check (for sleeping particles)
	//=========================================================================
	if (bWasSleeping)
	{
		bool bShouldWake = false;

		// 1. Direct velocity check (external force applied)
		if (Speed > WakeVelocityThreshold)
		{
			bShouldWake = true;
		}

		// 2. Collision wake-up
		if (HasFlag(Particle.Flags, GPU_PARTICLE_FLAG_HAS_COLLIDED))
		{
			bShouldWake = true;
		}

		// 3. Neighbor wake-up (propagation)
		// If any Neighbor is awake and moving fast, wake up this Particle
		if (!bShouldWake)
		{
			uint NeighborCount = NeighborCounts[Idx];
			uint BaseIdx = Idx * MAX_NEIGHBORS_PER_PARTICLE;

			for (uint N = 0; N < NeighborCount && N < MAX_NEIGHBORS_PER_PARTICLE; ++N)
			{
				uint NeighborIdx = NeighborList[BaseIdx + N];
				if (NeighborIdx < ParticleCountBuffer[6] && NeighborIdx != Idx)
				{
					FGPUFluidParticle Neighbor = SleepingParticles[NeighborIdx];

					// Wake up if Neighbor is awake and moving
					bool bNeighborSleeping = HasFlag(Neighbor.Flags, GPU_PARTICLE_FLAG_IS_SLEEPING);
					float NeighborSpeed = length(Neighbor.Velocity);

					if (!bNeighborSleeping && NeighborSpeed > WakeVelocityThreshold)
					{
						bShouldWake = true;
						break;
					}
				}
			}
		}

		if (bShouldWake)
		{
			// Wake up!
			Particle.Flags = ClearFlag(Particle.Flags, GPU_PARTICLE_FLAG_IS_SLEEPING);
			SleepCounters[Idx] = 0;
		}
		// else: remain sleeping
	}
	//=========================================================================
	// Sleep check (for awake particles)
	//=========================================================================
	else
	{
		if (Speed < SleepVelocityThreshold)
		{
			// Increment sleep counter
			SleepCounter++;

			if (SleepCounter >= (uint)SleepFrameThreshold)
			{
				// Enter sleep state
				Particle.Flags = SetFlag(Particle.Flags, GPU_PARTICLE_FLAG_IS_SLEEPING);
				// Clamp velocity to zero to prevent drift
				Particle.Velocity = float3(0.0f, 0.0f, 0.0f);
			}

			SleepCounters[Idx] = SleepCounter;
		}
		else
		{
			// Reset sleep counter - Particle is moving
			SleepCounters[Idx] = 0;
		}
	}

	// Clear collision flag (processed)
	Particle.Flags = ClearFlag(Particle.Flags, GPU_PARTICLE_FLAG_HAS_COLLIDED);

	SleepingParticles[Idx] = Particle;
}
