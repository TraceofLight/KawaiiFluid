// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file FluidPredictPositions.usf
 * @brief Shader implementation for FluidPredictPositions
 */

// GPU Fluid Physics - Predict Positions Pass
//
// Phase 2 of PBF/XPBD simulation:
// 1. Force Accumulation (Gravity + External + Cohesion + Viscosity)
// 2. Velocity Update (V += F/m * dt + Viscosity corrections)
// 3. Position Prediction (P_pred = P + V * dt)
//
// OPTIMIZED: Cohesion + Viscosity are now calculated in a single neighbor loop
// using previous frame's neighbor cache. This reduces memory bandwidth by ~50%.
//
// This follows NVIDIA Flex / standard PBF approach where forces are applied
// before constraint solving to prevent jittering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float DeltaTime;
float3 Gravity;
float3 ExternalForce;

// Cohesion Force parameters (Akinci 2013)
// Uses C(r) spline kernel with K_ij correction
float CohesionStrength;      // Cohesion strength (0~50, 0 = disabled)
float SmoothingRadius;       // SPH kernel radius (cm)
float RestDensity;           // Rest density (kg/m^3) for K_ij correction
float MaxCohesionForce;      // Stability clamp

// Viscosity parameters (moved from PostSimulation Phase 5)
float ViscosityCoefficient;  // Viscosity strength (0 = disabled)
float Poly6Coeff;            // Poly6 kernel coefficient
float ViscLaplacianCoeff;    // 45 / (PI * h^6) for Laplacian viscosity

// Viscosity tuning constants (legacy values retained for compatibility)
#define LAPLACIAN_VISCOSITY_SCALE 0.0001f
#define VELOCITY_DRAG_SCALE 5.0f

// Previous frame neighbor cache (double buffering for force calculation)
StructuredBuffer<uint> PrevNeighborList;
StructuredBuffer<uint> PrevNeighborCounts;
int bUsePrevNeighborCache;   // 0 = skip forces (first frame)
int PrevParticleCount;       // Safety: bounds check

//=============================================================================
// Force Accumulation Helpers
//=============================================================================

/**
 * @brief Data layout for accumulated force outputs
 */
struct FForceAccumulationResult
{
    float3 CohesionAccel;
    float3 ViscosityCorrection;
    float3 LaplacianForce;
    float WeightSum;
};

/**
 * @brief Computes cohesion and viscosity terms in one neighbor pass
 */
FForceAccumulationResult CalculateForceAccumulation(
    uint idx,
    float3 position,
    float3 velocity,
    float mass,
    float density,
    float cohesionStrength,
    float maxCohesionForce,
    float restDensity,
    float poly6Coeff,
    float viscLaplacianCoeff,
    float smoothingRadius,
    StructuredBuffer<uint> prevNeighborList,
    StructuredBuffer<uint> prevNeighborCounts,
    int particleCount,
    int prevParticleCount,
    RWStructuredBuffer<FGPUFluidParticle> particles)
{
    FForceAccumulationResult result;
    result.CohesionAccel = float3(0.0f, 0.0f, 0.0f);
    result.ViscosityCorrection = float3(0.0f, 0.0f, 0.0f);
    result.LaplacianForce = float3(0.0f, 0.0f, 0.0f);
    result.WeightSum = 0.0f;

    float h_m = smoothingRadius * CM_TO_M;
    float h2 = h_m * h_m;
    float smoothingRadiusSq_cm = smoothingRadius * smoothingRadius;

    float m_i = mass;
    float rho_i = max(density, SMALL_NUMBER);
    float3 cohesionForce = float3(0.0f, 0.0f, 0.0f);

    float cacheValidMask = step((float)idx + 0.5f, (float)prevParticleCount);
    uint safeIdx = min(idx, max((uint)prevParticleCount - 1, 0u));
    uint cachedCount = prevNeighborCounts[safeIdx];
    cachedCount = (uint)((float)cachedCount * cacheValidMask);
    uint baseIdx = idx * MAX_NEIGHBORS_PER_PARTICLE;
    uint maxSafeIdx = max((uint)particleCount - 1, 0u);

    for (uint n = 0; n < cachedCount; ++n)
    {
        uint neighborIdx = prevNeighborList[baseIdx + n];

        float selfMask = 1.0f - step((float)idx - 0.5f, (float)neighborIdx)
                              * step((float)neighborIdx, (float)idx + 0.5f);
        float boundsMask = step((float)neighborIdx + 0.5f, (float)particleCount);
        float validMask = selfMask * boundsMask;

        uint safeNeighborIdx = min(neighborIdx, maxSafeIdx);
        FGPUFluidParticle neighbor = particles[safeNeighborIdx];
        float attachedMask = 1.0f - (float)HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
        validMask *= attachedMask;

        float3 r_cm = position - neighbor.Position;
        float r2_cm = dot(r_cm, r_cm);
        float distMinMask = step(SMALL_NUMBER, r2_cm);
        float distMaxMask = step(r2_cm, smoothingRadiusSq_cm);
        validMask *= distMinMask * distMaxMask;

        float safeR2_cm = max(r2_cm, SMALL_NUMBER);
        float rLenInv_cm = rsqrt(safeR2_cm);
        float dist_cm = safeR2_cm * rLenInv_cm;
        float dist_m = dist_cm * CM_TO_M;
        float r2_m = dist_m * dist_m;
        float kernelMask = step(dist_m + SMALL_NUMBER, h_m);
        validMask *= kernelMask;

        float m_j = neighbor.Mass;
        float rho_j = max(neighbor.Density, SMALL_NUMBER);
        float K_ij = (2.0f * restDensity) / (rho_i + rho_j);
        K_ij = clamp(K_ij, 0.5f, 2.0f);

        float cohesionWeight = CohesionKernel(dist_m, h_m);
        float3 direction = -r_cm * rLenInv_cm;
        float forceMag = m_i * m_j * cohesionWeight;
        cohesionForce += K_ij * cohesionStrength * forceMag * direction * validMask;

        float w = Poly6Kernel(r2_m, h2) * poly6Coeff;
        float3 velDiff = neighbor.Velocity - velocity;
        result.ViscosityCorrection += velDiff * w * validMask;
        result.WeightSum += w * validMask;

        float laplacian = ViscosityLaplacian(dist_m, h_m, viscLaplacianCoeff);
        float neighborDensity = max(neighbor.Density, 0.001f);
        result.LaplacianForce += velDiff * laplacian * neighbor.Mass / neighborDensity * validMask;
    }

    float forceLen = length(cohesionForce);
    float clampScale = min(1.0f, maxCohesionForce / max(forceLen, SMALL_NUMBER));
    cohesionForce *= clampScale;
    result.CohesionAccel = (cohesionForce / max(m_i, SMALL_NUMBER)) * 100.0f;

    return result;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for PredictPositionsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PredictPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;

    // Bounds check - this one branch is unavoidable (prevents out-of-bounds write)
    // Writing to invalid indices could corrupt memory or crash
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    FGPUFluidParticle particle = Particles[idx];

    //=========================================================================
    // Attached Mask: CPU-attached particles only update PredictedPosition
    // BRANCHLESS: All paths computed, result selected via lerp
    //=========================================================================
    float attachedMask = (float)HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
    float activeMask = 1.0f - attachedMask;

    //=========================================================================
    // 1. Force Accumulation (Cohesion + Viscosity in single neighbor loop)
    // OPTIMIZED: Always call, *0 masking handles disabled features
    //=========================================================================

    // bUsePrevNeighborCache: first frame has no cache, multiply by 0 to skip
    float cacheValid = (float)bUsePrevNeighborCache * activeMask;

    // Cohesion Force (Akinci 2013)
    // Always use CohesionStrength for force-based cohesion
    // Surface Tension is handled separately in SolveDensityPressure (Position-Based)

    FForceAccumulationResult forceResult = CalculateForceAccumulation(
        idx,
        particle.Position,
        particle.Velocity,
        particle.Mass,
        particle.Density,
        // Cohesion params (Akinci 2013)
        CohesionStrength * cacheValid,
        MaxCohesionForce,
        RestDensity,
        // Viscosity params
        Poly6Coeff,
        ViscLaplacianCoeff,
        // Common params
        SmoothingRadius,
        // Buffers
        PrevNeighborList,
        PrevNeighborCounts,
        ParticleCount,
        PrevParticleCount,
        Particles
    );

    // Apply cache validity mask
    float3 cohesionAccel = forceResult.CohesionAccel;  // Already masked via CohesionStrength * cacheValid
    float3 viscosityCorrection = forceResult.ViscosityCorrection * cacheValid;
    float3 laplacianForce = forceResult.LaplacianForce * cacheValid;
    float viscosityWeightSum = forceResult.WeightSum * cacheValid;

    //=========================================================================
    // 2. Apply Forces to Velocity (only for active particles via activeMask)
    //=========================================================================

    // Total acceleration: Gravity + External + Cohesion
    float3 totalAcceleration = Gravity + ExternalForce + cohesionAccel;

    // Apply acceleration (Semi-implicit Euler) - masked for active particles only
    particle.Velocity += totalAcceleration * DeltaTime * activeMask;

    //=========================================================================
    // 3. Apply Viscosity to Velocity
    // OPTIMIZED: No branches - uses *0 masking and safe division
    //=========================================================================

    // XSPH velocity smoothing (branchless, matches original logic)
    // When WeightSum < SMALL_NUMBER: no neighbors, skip correction (multiply by 0)
    float weightMask = step(SMALL_NUMBER, viscosityWeightSum);  // 1 if WeightSum >= SMALL_NUMBER, else 0
    float safeWeightSum = max(viscosityWeightSum, SMALL_NUMBER);
    viscosityCorrection = (viscosityCorrection / safeWeightSum) * weightMask;
    // When ViscosityCoefficient=0 or attached, this adds 0
    particle.Velocity += ViscosityCoefficient * viscosityCorrection * activeMask;

    // Laplacian viscosity (drag force) - masked
    float mu = ViscosityCoefficient * ViscosityCoefficient * LAPLACIAN_VISCOSITY_SCALE;
    particle.Velocity += mu * laplacianForce * DeltaTime * activeMask;

    // Velocity drag (air resistance) - use lerp for branchless damping
    float dragCoeff = ViscosityCoefficient * ViscosityCoefficient * VELOCITY_DRAG_SCALE;
    float damping = max(1.0f - dragCoeff * DeltaTime, 0.0f);
    // Active: apply damping, Attached: keep velocity unchanged (damping = 1.0)
    float effectiveDamping = lerp(damping, 1.0f, attachedMask);
    particle.Velocity *= effectiveDamping;

    //=========================================================================
    // 4. Position Prediction
    // Active: Position + Velocity * DeltaTime
    // Attached: Position (no movement)
    //=========================================================================
    float3 activePredicted = particle.Position + particle.Velocity * DeltaTime;
    float3 attachedPredicted = particle.Position;
    particle.PredictedPosition = lerp(activePredicted, attachedPredicted, attachedMask);

    // XPBD Warm Starting: Preserve Lambda with damping (only for active)
    // Attached: Lambda unchanged (multiply by 1.0)
    float lambdaDamping = lerp(0.9f, 1.0f, attachedMask);
    particle.Lambda *= lambdaDamping;

    // Store back
    Particles[idx] = particle;
}


