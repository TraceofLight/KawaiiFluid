// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidSimulationPredict.usf
 * @brief Shader implementation for KawaiiFluidSimulationPredict
 */

// GPU Fluid Physics - Predict Positions Pass
//
// Phase 2 of PBF/XPBD simulation:
// 1. Force Accumulation (Gravity + External + Cohesion + Viscosity)
// 2. Velocity Update (V += F/m * dt + Viscosity corrections)
// 3. Position Prediction (P_pred = P + V * dt)
//
// OPTIMIZED: Cohesion + Viscosity are now calculated in a single neighbor loop
// using previous frame's neighbor cache. This reduces memory bandwidth by ~50%.
//
// This follows NVIDIA Flex / standard PBF approach where forces are applied
// before constraint solving to prevent jittering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float DeltaTime;
float3 Gravity;
float3 ExternalForce;

// Cohesion Force parameters (Akinci 2013)
// Uses C(r) spline kernel with K_ij correction
float CohesionStrength;      // Cohesion strength (0~50, 0 = disabled)
float SmoothingRadius;       // SPH kernel radius (cm)
float RestDensity;           // Rest density (kg/m^3) for K_ij correction
float MaxCohesionForce;      // Stability clamp

// Viscosity parameters (moved from PostSimulation Phase 5)
float ViscosityCoefficient;  // Viscosity strength (0 = disabled)
float Poly6Coeff;            // Poly6 kernel coefficient
float ViscLaplacianCoeff;    // 45 / (PI * h^6) for Laplacian viscosity

// Viscosity tuning constants (legacy values retained for compatibility)
#define LAPLACIAN_VISCOSITY_SCALE 0.0001f
#define VELOCITY_DRAG_SCALE 5.0f

// Previous frame neighbor cache (double buffering for force calculation)
StructuredBuffer<uint> PrevNeighborList;
StructuredBuffer<uint> PrevNeighborCounts;
int bUsePrevNeighborCache;   // 0 = skip forces (first frame)
int PrevParticleCount;       // Safety: bounds check

//=============================================================================
// Force Accumulation Helpers
//=============================================================================

/**
 * @brief Data layout for accumulated force outputs
 */
struct FForceAccumulationResult
{
    float3 CohesionAccel;
    float3 ViscosityCorrection;
    float3 LaplacianForce;
    float WeightSum;
};

/**
 * @brief Computes cohesion and viscosity terms in one neighbor pass
 */
FForceAccumulationResult CalculateForceAccumulation(
    uint Idx,
    float3 Position,
    float3 Velocity,
    float Mass,
    float Density,
    float CohesionStrength,
    float MaxCohesionForce,
    float RestDensity,
    float Poly6Coeff,
    float ViscLaplacianCoeff,
    float SmoothingRadius,
    StructuredBuffer<uint> PrevNeighborList,
    StructuredBuffer<uint> PrevNeighborCounts,
    int ParticleCount,
    int PrevParticleCount,
    RWStructuredBuffer<FGPUFluidParticle> InParticles)
{
    FForceAccumulationResult Result;
    Result.CohesionAccel = float3(0.0f, 0.0f, 0.0f);
    Result.ViscosityCorrection = float3(0.0f, 0.0f, 0.0f);
    Result.LaplacianForce = float3(0.0f, 0.0f, 0.0f);
    Result.WeightSum = 0.0f;

    float HM = SmoothingRadius * CM_TO_M;
    float H2 = HM * HM;
    float SmoothingRadiusSqCm = SmoothingRadius * SmoothingRadius;

    float MI = Mass;
    float RhoI = max(Density, SMALL_NUMBER);
    float3 CohesionForce = float3(0.0f, 0.0f, 0.0f);

    float CacheValidMask = step((float)Idx + 0.5f, (float)PrevParticleCount);
    uint SafeIdx = min(Idx, max((uint)PrevParticleCount - 1, 0u));
    uint CachedCount = PrevNeighborCounts[SafeIdx];
    CachedCount = (uint)((float)CachedCount * CacheValidMask);
    uint BaseIdx = Idx * MAX_NEIGHBORS_PER_PARTICLE;
    uint MaxSafeIdx = max((uint)ParticleCount - 1, 0u);

    for (uint N = 0; N < CachedCount; ++N)
    {
        uint NeighborIdx = PrevNeighborList[BaseIdx + N];

        float SelfMask = 1.0f - step((float)Idx - 0.5f, (float)NeighborIdx)
                              * step((float)NeighborIdx, (float)Idx + 0.5f);
        float BoundsMask = step((float)NeighborIdx + 0.5f, (float)ParticleCount);
        float ValidMask = SelfMask * BoundsMask;

        uint SafeNeighborIdx = min(NeighborIdx, MaxSafeIdx);
        FGPUFluidParticle Neighbor = InParticles[SafeNeighborIdx];
        float AttachedMask = 1.0f - (float)HasFlag(Neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
        ValidMask *= AttachedMask;

        float3 RCm = Position - Neighbor.Position;
        float R2Cm = dot(RCm, RCm);
        float DistMinMask = step(SMALL_NUMBER, R2Cm);
        float DistMaxMask = step(R2Cm, SmoothingRadiusSqCm);
        ValidMask *= DistMinMask * DistMaxMask;

        float SafeR2Cm = max(R2Cm, SMALL_NUMBER);
        float RLenInvCm = rsqrt(SafeR2Cm);
        float DistCm = SafeR2Cm * RLenInvCm;
        float DistM = DistCm * CM_TO_M;
        float R2M = DistM * DistM;
        float KernelMask = step(DistM + SMALL_NUMBER, HM);
        ValidMask *= KernelMask;

        float MJ = Neighbor.Mass;
        float RhoJ = max(Neighbor.Density, SMALL_NUMBER);
        float K_ij = (2.0f * RestDensity) / (RhoI + RhoJ);
        K_ij = clamp(K_ij, 0.5f, 2.0f);

        float CohesionWeight = CohesionKernel(DistM, HM);
        float3 Direction = -RCm * RLenInvCm;
        float ForceMag = MI * MJ * CohesionWeight;
        CohesionForce += K_ij * CohesionStrength * ForceMag * Direction * ValidMask;

        float W = Poly6Kernel(R2M, H2) * Poly6Coeff;
        float3 VelDiff = Neighbor.Velocity - Velocity;
        Result.ViscosityCorrection += VelDiff * W * ValidMask;
        Result.WeightSum += W * ValidMask;

        float Laplacian = ViscosityLaplacian(DistM, HM, ViscLaplacianCoeff);
        float NeighborDensity = max(Neighbor.Density, 0.001f);
        Result.LaplacianForce += VelDiff * Laplacian * Neighbor.Mass / NeighborDensity * ValidMask;
    }

    float ForceLen = length(CohesionForce);
    float ClampScale = min(1.0f, MaxCohesionForce / max(ForceLen, SMALL_NUMBER));
    CohesionForce *= ClampScale;
    Result.CohesionAccel = (CohesionForce / max(MI, SMALL_NUMBER)) * 100.0f;

    return Result;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for PredictPositionsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PredictPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint Idx = DispatchThreadId.x;

    // Bounds check - this one branch is unavoidable (prevents out-of-bounds write)
    // Writing To invalid indices could corrupt memory or crash
    if (Idx >= ParticleCountBuffer[6])
    {
        return;
    }

    FGPUFluidParticle Particle = Particles[Idx];

    //=========================================================================
    // Attached Mask: CPU-attached particles only update PredictedPosition
    // BRANCHLESS: All paths computed, result selected via lerp
    //=========================================================================
    float AttachedMask = (float)HasFlag(Particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
    float ActiveMask = 1.0f - AttachedMask;

    //=========================================================================
    // 1. Force Accumulation (Cohesion + Viscosity in single neighbor loop)
    // OPTIMIZED: Always call, *0 masking handles disabled features
    //=========================================================================

    // bUsePrevNeighborCache: first frame has no cache, multiply by 0 To skip
    float CacheValid = (float)bUsePrevNeighborCache * ActiveMask;

    // Cohesion Force (Akinci 2013)
    // Always use CohesionStrength for force-based cohesion
    // Surface Tension is handled separately in SolveDensityPressure (Position-Based)

    FForceAccumulationResult ForceResult = CalculateForceAccumulation(
        Idx,
        Particle.Position,
        Particle.Velocity,
        Particle.Mass,
        Particle.Density,
        // Cohesion params (Akinci 2013)
        CohesionStrength * CacheValid,
        MaxCohesionForce,
        RestDensity,
        // Viscosity params
        Poly6Coeff,
        ViscLaplacianCoeff,
        // Common params
        SmoothingRadius,
        // Buffers
        PrevNeighborList,
        PrevNeighborCounts,
        ParticleCount,
        PrevParticleCount,
        Particles
    );

    // Apply cache validity mask
    float3 CohesionAccel = ForceResult.CohesionAccel;  // Already masked via CohesionStrength * CacheValid
    float3 ViscosityCorrection = ForceResult.ViscosityCorrection * CacheValid;
    float3 LaplacianForce = ForceResult.LaplacianForce * CacheValid;
    float ViscosityWeightSum = ForceResult.WeightSum * CacheValid;

    //=========================================================================
    // 2. Apply Forces To Velocity (only for active particles via ActiveMask)
    //=========================================================================

    // Total acceleration: Gravity + External + Cohesion
    float3 TotalAcceleration = Gravity + ExternalForce + CohesionAccel;

    // Apply acceleration (Semi-implicit Euler) - masked for active particles only
    Particle.Velocity += TotalAcceleration * DeltaTime * ActiveMask;

    //=========================================================================
    // 3. Apply Viscosity To Velocity
    // OPTIMIZED: No branches - uses *0 masking and safe division
    //=========================================================================

    // XSPH velocity smoothing (branchless, matches original logic)
    // When WeightSum < SMALL_NUMBER: no neighbors, skip correction (multiply by 0)
    float WeightMask = step(SMALL_NUMBER, ViscosityWeightSum);  // 1 if WeightSum >= SMALL_NUMBER, else 0
    float SafeWeightSum = max(ViscosityWeightSum, SMALL_NUMBER);
    ViscosityCorrection = (ViscosityCorrection / SafeWeightSum) * WeightMask;
    // When ViscosityCoefficient=0 or attached, this adds 0
    Particle.Velocity += ViscosityCoefficient * ViscosityCorrection * ActiveMask;

    // Laplacian viscosity (drag force) - masked
    float Mu = ViscosityCoefficient * ViscosityCoefficient * LAPLACIAN_VISCOSITY_SCALE;
    Particle.Velocity += Mu * LaplacianForce * DeltaTime * ActiveMask;

    // Velocity drag (air resistance) - use lerp for branchless Damping
    float DragCoeff = ViscosityCoefficient * ViscosityCoefficient * VELOCITY_DRAG_SCALE;
    float Damping = max(1.0f - DragCoeff * DeltaTime, 0.0f);
    // Active: apply Damping, Attached: keep velocity unchanged (Damping = 1.0)
    float EffectiveDamping = lerp(Damping, 1.0f, AttachedMask);
    Particle.Velocity *= EffectiveDamping;

    //=========================================================================
    // 4. Position Prediction
    // Active: Position + Velocity * DeltaTime
    // Attached: Position (no movement)
    //=========================================================================
    float3 ActivePredicted = Particle.Position + Particle.Velocity * DeltaTime;
    float3 AttachedPredicted = Particle.Position;
    Particle.PredictedPosition = lerp(ActivePredicted, AttachedPredicted, AttachedMask);

    // XPBD Warm Starting: Preserve Lambda with Damping (only for active)
    // Attached: Lambda unchanged (multiply by 1.0)
    float LambdaDamping = lerp(0.9f, 1.0f, AttachedMask);
    Particle.Lambda *= LambdaDamping;

    // Store back
    Particles[Idx] = Particle;
}
