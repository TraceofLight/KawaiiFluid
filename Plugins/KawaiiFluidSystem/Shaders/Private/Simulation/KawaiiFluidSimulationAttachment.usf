// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidSimulationAttachment.usf
 * @brief Shader implementation for KawaiiFluidSimulationAttachment
 */

// GPU Fluid Physics - Adhesion Pass
// Handles particle attachment to bone colliders and position tracking

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidSpatialHash.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle SOA buffers
RWBuffer<float> Positions;
RWBuffer<float> PredictedPositions;
RWBuffer<uint2> PackedVelocities;  // B plan: half3 packed
RWBuffer<uint> Flags;
int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float ParticleRadius;

// Attachment buffer (one per particle)
RWStructuredBuffer<FGPUParticleAttachment> Attachments;

// Bone transforms
StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

// Adhesion parameters
float AdhesionStrength;
float AdhesionRadius;
float DetachAccelThreshold;
float DetachDistanceThreshold;
float ColliderContactOffset;
float BoneVelocityScale;
float SlidingFriction;
float CurrentTime;
float DeltaTime;
int bEnableAdhesion;

// Gravity sliding parameters
float3 Gravity;
float GravitySlidingScale;  // How much gravity affects sliding (0-1)

// Primitive type constants
#define PRIM_TYPE_SPHERE 0
#define PRIM_TYPE_CAPSULE 1
#define PRIM_TYPE_BOX 2
#define PRIM_TYPE_CONVEX 3

//=============================================================================
// Helper Functions
//=============================================================================

/**
 * @brief Find closest point on sphere surface
 */
float3 GetClosestPointOnSphere(float3 Pos, FGPUCollisionSphere Sphere, out float3 Normal, out float Distance)
{
	float3 ToPoint = Pos - Sphere.Center;
	float Dist = length(ToPoint);
	Normal = Dist > 0.0001f ? ToPoint / Dist : float3(0, 0, 1);
	Distance = Dist - Sphere.Radius;
	return Sphere.Center + Normal * Sphere.Radius;
}

/**
 * @brief Find closest point on capsule surface
 */
float3 GetClosestPointOnCapsule(float3 Pos, FGPUCollisionCapsule Capsule, out float3 Normal, out float Distance)
{
	float3 CapsuleAxis = Capsule.End - Capsule.Start;
	float AxisT = saturate(dot(Pos - Capsule.Start, CapsuleAxis) / dot(CapsuleAxis, CapsuleAxis));
	float3 ClosestOnAxis = Capsule.Start + AxisT * CapsuleAxis;
	float3 ToPoint = Pos - ClosestOnAxis;
	float Dist = length(ToPoint);
	Normal = Dist > 0.0001f ? ToPoint / Dist : float3(0, 0, 1);
	Distance = Dist - Capsule.Radius;
	return ClosestOnAxis + Normal * Capsule.Radius;
}

/**
 * @brief Find closest point on box surface (approximate)
 */
float3 GetClosestPointOnBox(float3 Pos, FGPUCollisionBox Box, out float3 Normal, out float Distance)
{
	// Transform to local space
	float3 LocalP = InverseRotateByQuat(Pos - Box.Center, Box.Rotation);

	// Clamp to Box surface
	float3 Clamped = clamp(LocalP, -Box.Extent, Box.Extent);
	float3 LocalNormal = LocalP - Clamped;
	float Dist = length(LocalNormal);

	if (Dist > 0.0001f)
	{
		LocalNormal /= Dist;
	}
	else
	{
		// Inside Box - find closest face
		float3 ToFace = Box.Extent - abs(LocalP);
		if (ToFace.x < ToFace.y && ToFace.x < ToFace.z)
			LocalNormal = float3(sign(LocalP.x), 0, 0);
		else if (ToFace.y < ToFace.z)
			LocalNormal = float3(0, sign(LocalP.y), 0);
		else
			LocalNormal = float3(0, 0, sign(LocalP.z));
		Dist = -min(ToFace.x, min(ToFace.y, ToFace.z));
	}

	// Transform back to world space
	Normal = RotateByQuat(LocalNormal, Box.Rotation);
	Distance = Dist;
	return Box.Center + RotateByQuat(Clamped, Box.Rotation);
}

/**
 * @brief Returns surface distance and normal for a convex collider
 */
void GetConvexSurfaceInfo(
	float3 Pos,
	FGPUCollisionConvex Convex,
	StructuredBuffer<FGPUConvexPlane> ConvexPlanesBuffer,
	out float Distance,
	out float3 Normal,
	out float3 SurfacePoint)
{
	float3 ToCenter = Pos - Convex.Center;
	float CenterLen = length(ToCenter);
	float3 BoundNormal = CenterLen > 0.0001f ? ToCenter / CenterLen : float3(0, 0, 1);
	float BoundDistance = CenterLen - Convex.BoundingRadius;

	float MaxPlaneDistance = -1e10f;
	float3 PlaneNormal = BoundNormal;

	if (Convex.PlaneCount > 0)
	{
		const int PlaneStart = Convex.PlaneStartIndex;
		for (int Pi = 0; Pi < Convex.PlaneCount; ++Pi)
		{
			FGPUConvexPlane Plane = ConvexPlanesBuffer[PlaneStart + Pi];
			float PlaneDistance = dot(Pos, Plane.Normal) - Plane.Distance;
			if (PlaneDistance > MaxPlaneDistance)
			{
				MaxPlaneDistance = PlaneDistance;
				PlaneNormal = Plane.Normal;
			}
		}

		bool bUseBound = BoundDistance > MaxPlaneDistance;
		Distance = bUseBound ? BoundDistance : MaxPlaneDistance;
		Normal = bUseBound ? BoundNormal : PlaneNormal;
		SurfacePoint = Pos - Normal * Distance;
	}
	else
	{
		Distance = BoundDistance;
		Normal = BoundNormal;
		SurfacePoint = Convex.Center + Normal * Convex.BoundingRadius;
	}
}

/**
 * @brief Calculate absolute distance between an arbitrary position and the attached primitive surface
 */
float ComputeAttachmentSurfaceDistance(float3 Pos, FGPUParticleAttachment Attachment)
{
	if (Attachment.PrimitiveIndex < 0)
	{
		return 0.0f;
	}

	if (Attachment.PrimitiveType == PRIM_TYPE_SPHERE && Attachment.PrimitiveIndex < SphereCount)
	{
		FGPUCollisionSphere Sphere = CollisionSpheres[Attachment.PrimitiveIndex];
		return abs(length(Pos - Sphere.Center) - Sphere.Radius);
	}
	else if (Attachment.PrimitiveType == PRIM_TYPE_CAPSULE && Attachment.PrimitiveIndex < CapsuleCount)
	{
		FGPUCollisionCapsule Capsule = CollisionCapsules[Attachment.PrimitiveIndex];
		float3 CapsuleAxis = Capsule.End - Capsule.Start;
		float AxisT = saturate(dot(Pos - Capsule.Start, CapsuleAxis) / dot(CapsuleAxis, CapsuleAxis));
		float3 ClosestOnAxis = Capsule.Start + AxisT * CapsuleAxis;
		return abs(length(Pos - ClosestOnAxis) - Capsule.Radius);
	}
	else if (Attachment.PrimitiveType == PRIM_TYPE_BOX && Attachment.PrimitiveIndex < BoxCount)
	{
		FGPUCollisionBox Box = CollisionBoxes[Attachment.PrimitiveIndex];
		return abs(sdBox(Pos, Box.Center, Box.Extent, Box.Rotation));
	}
	else if (Attachment.PrimitiveType == PRIM_TYPE_CONVEX && Attachment.PrimitiveIndex < ConvexCount)
	{
		FGPUCollisionConvex Convex = CollisionConvexes[Attachment.PrimitiveIndex];
		float SignedDistance;
		float3 TmpNormal;
		float3 TmpPoint;
		GetConvexSurfaceInfo(Pos, Convex, ConvexPlanes, SignedDistance, TmpNormal, TmpPoint);
		return abs(SignedDistance);
	}

	return 0.0f;
}

//=============================================================================
// Adhesion Compute Shader - Check and create attachments
//=============================================================================

/**
 * @brief Compute shader entry point for AdhesionCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void AdhesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6] || bEnableAdhesion == 0)
	{
		return;
	}

	uint Idx3 = Idx * 3;
	uint ParticleFlags = Flags[Idx];
	FGPUParticleAttachment Attachment = Attachments[Idx];
	const float EffectiveAdhesionRadius = max(0.0f, AdhesionRadius + ColliderContactOffset);

	float3 Pos = float3(Positions[Idx3], Positions[Idx3 + 1], Positions[Idx3 + 2]);

	// If already attached, skip adhesion check (handled by UpdateAttachedPositions)
	if (Attachment.PrimitiveType >= 0)
	{
		return;
	}

	// Skip if just detached this frame
	if (HasFlag(ParticleFlags, GPU_PARTICLE_FLAG_JUST_DETACHED))
	{
		return;
	}

	// Find Closest primitive for potential Attachment
	float ClosestDist = EffectiveAdhesionRadius;
	int ClosestPrimType = -1;
	int ClosestPrimIndex = -1;
	int ClosestBoneIndex = -1;
	float3 ClosestPoint = float3(0, 0, 0);
	float3 ClosestNormal = float3(0, 0, 1);

	// Check spheres
	for (int Si = 0; Si < SphereCount; ++Si)
	{
		FGPUCollisionSphere Sphere = CollisionSpheres[Si];
		if (Sphere.BoneIndex < 0) continue;  // Skip primitives without Bone tracking

		float3 Normal;
		float Distance;
		float3 SurfacePoint = GetClosestPointOnSphere(Pos, Sphere, Normal, Distance);

		if (Distance < ClosestDist && Distance < EffectiveAdhesionRadius)
		{
			ClosestDist = Distance;
			ClosestPrimType = PRIM_TYPE_SPHERE;
			ClosestPrimIndex = Si;
			ClosestBoneIndex = Sphere.BoneIndex;
			ClosestPoint = SurfacePoint;
			ClosestNormal = Normal;
		}
	}

	// Check capsules
	for (int Ci = 0; Ci < CapsuleCount; ++Ci)
	{
		FGPUCollisionCapsule Capsule = CollisionCapsules[Ci];
		if (Capsule.BoneIndex < 0) continue;

		float3 Normal;
		float Distance;
		float3 SurfacePoint = GetClosestPointOnCapsule(Pos, Capsule, Normal, Distance);

		if (Distance < ClosestDist && Distance < EffectiveAdhesionRadius)
		{
			ClosestDist = Distance;
			ClosestPrimType = PRIM_TYPE_CAPSULE;
			ClosestPrimIndex = Ci;
			ClosestBoneIndex = Capsule.BoneIndex;
			ClosestPoint = SurfacePoint;
			ClosestNormal = Normal;
		}
	}

	// Check boxes
	for (int Bi = 0; Bi < BoxCount; ++Bi)
	{
		FGPUCollisionBox Box = CollisionBoxes[Bi];
		if (Box.BoneIndex < 0) continue;

		float3 Normal;
		float Distance;
		float3 SurfacePoint = GetClosestPointOnBox(Pos, Box, Normal, Distance);

		if (Distance < ClosestDist && Distance < EffectiveAdhesionRadius)
		{
			ClosestDist = Distance;
			ClosestPrimType = PRIM_TYPE_BOX;
			ClosestPrimIndex = Bi;
			ClosestBoneIndex = Box.BoneIndex;
			ClosestPoint = SurfacePoint;
			ClosestNormal = Normal;
		}
	}

	// Check convexes
	for (int Cxi = 0; Cxi < ConvexCount; ++Cxi)
	{
		FGPUCollisionConvex Convex = CollisionConvexes[Cxi];
		if (Convex.BoneIndex < 0) continue;

		float Distance;
		float3 SurfaceNormal;
		float3 SurfacePoint;
		GetConvexSurfaceInfo(Pos, Convex, ConvexPlanes, Distance, SurfaceNormal, SurfacePoint);

		if (Distance < ClosestDist && Distance < EffectiveAdhesionRadius)
		{
			ClosestDist = Distance;
			ClosestPrimType = PRIM_TYPE_CONVEX;
			ClosestPrimIndex = Cxi;
			ClosestBoneIndex = Convex.BoneIndex;
			ClosestPoint = SurfacePoint;
			ClosestNormal = SurfaceNormal;
		}
	}

	// Create Attachment if close enough
	if (ClosestPrimType >= 0 && ClosestBoneIndex >= 0 && ClosestBoneIndex < BoneCount)
	{
		FGPUBoneTransform Bone = BoneTransforms[ClosestBoneIndex];

		// Store Attachment info
		Attachment.PrimitiveType = ClosestPrimType;
		Attachment.PrimitiveIndex = ClosestPrimIndex;
		Attachment.BoneIndex = ClosestBoneIndex;
		Attachment.AdhesionStrength = AdhesionStrength;
		Attachment.LocalOffset = WorldToBoneLocal(Pos, Bone);
		Attachment.AttachmentTime = CurrentTime;
		Attachment.RelativeVelocity = float3(0, 0, 0);  // No relative velocity on attach

		// Set attached flag
		ParticleFlags = SetFlag(ParticleFlags, GPU_PARTICLE_FLAG_IS_ATTACHED);

		Flags[Idx] = ParticleFlags;
		Attachments[Idx] = Attachment;
	}
}

//=============================================================================
// Update Attached Positions Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for UpdateAttachedPositionsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateAttachedPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
	{
		return;
	}

	FGPUParticleAttachment Attachment = Attachments[Idx];
	const float EffectiveDetachThreshold = max(0.0f, DetachDistanceThreshold + ColliderContactOffset);

	// Skip non-attached particles
	if (Attachment.PrimitiveType < 0 || Attachment.BoneIndex < 0 || Attachment.BoneIndex >= BoneCount)
	{
		return;
	}

	uint Idx3 = Idx * 3;
	float3 Position = float3(Positions[Idx3], Positions[Idx3 + 1], Positions[Idx3 + 2]);
	float3 PredictedPosition = float3(PredictedPositions[Idx3], PredictedPositions[Idx3 + 1], PredictedPositions[Idx3 + 2]);
	float3 Velocity = UnpackVelocity(PackedVelocities[Idx]);
	uint ParticleFlags = Flags[Idx];
	FGPUBoneTransform Bone = BoneTransforms[Attachment.BoneIndex];
	float3 PreviousVelocity = Velocity;

	// Desired Bone-follow Position and inferred speed
	float3 DesiredPos = BoneLocalToWorld(Attachment.LocalOffset, Bone);
	float3 FollowDelta = DesiredPos - PredictedPosition;
	const float DesiredSpeed = length(FollowDelta) / max(DeltaTime, 0.0001f);

	// AdhesionStrength affects detach thresholds (0~1 ratio)
	// 0 = normal detach behavior
	// 1 = never detach
	// Formula: EffectiveThreshold = BaseThreshold / (1.0 - AdhesionStrength)
	const float ClampedStrength = saturate(Attachment.AdhesionStrength);  // Clamp to 0~1
	bool bShouldDetach = false;

	if (ClampedStrength >= 0.999f)
	{
		// AdhesionStrength = 1 → never detach
		bShouldDetach = false;
	}
	else
	{
		// 0~0.999: progressively harder to detach
		const float StrengthMultiplier = 1.0f / (1.0f - ClampedStrength);
		const float EffectiveAccelThreshold = DetachAccelThreshold * StrengthMultiplier;
		const float EffectiveDistThreshold = EffectiveDetachThreshold * StrengthMultiplier;

		// Detach if the required follow speed exceeds threshold
		if (DesiredSpeed > EffectiveAccelThreshold)
		{
			bShouldDetach = true;
		}

		// Additional safety: detach if we drift too far from the surface
		float PredictedSurfaceDistance = ComputeAttachmentSurfaceDistance(PredictedPosition, Attachment);
		if (PredictedSurfaceDistance > EffectiveDistThreshold)
		{
			bShouldDetach = true;
		}

		float SurfaceDistance = ComputeAttachmentSurfaceDistance(DesiredPos, Attachment);
		if (SurfaceDistance > EffectiveDistThreshold)
		{
			bShouldDetach = true;
		}
	}

	// Calculate Bone Velocity for later Velocity blending / sliding
	float3 BoneVelocity = CalcBoneVelocity(Attachment.LocalOffset, Bone, DeltaTime);

	if (bShouldDetach)
	{
		// Detach: clear Attachment, give particle Bone Velocity
		Attachment.PrimitiveType = -1;
		Attachment.PrimitiveIndex = -1;
		Attachment.BoneIndex = -1;
		Attachment.AdhesionStrength = 0;
		Attachment.LocalOffset = float3(0, 0, 0);
		Attachment.RelativeVelocity = float3(0, 0, 0);  // Reset relative Velocity

		ParticleFlags = ClearFlag(ParticleFlags, GPU_PARTICLE_FLAG_IS_ATTACHED);
		ParticleFlags = SetFlag(ParticleFlags, GPU_PARTICLE_FLAG_JUST_DETACHED);

		// Clamp and dampen Velocity on detach to prevent particles flying too far
		const float MaxDetachVelocity = 500.0f;  // cm/s (5 m/s max)
		const float DetachVelocityDamping = 0.3f; // 30% of Bone Velocity
		float3 ClampedVelocity = BoneVelocity * DetachVelocityDamping;
		float VelMag = length(ClampedVelocity);
		if (VelMag > MaxDetachVelocity)
		{
			ClampedVelocity = ClampedVelocity * (MaxDetachVelocity / VelMag);
		}
		float3 DesiredVelocity = ClampedVelocity;
		Velocity = lerp(PreviousVelocity, DesiredVelocity, saturate(BoneVelocityScale));
	}
	else
	{
		// === Gravity-based surface sliding ===
		// Calculate surface normal at current Position
		float3 SurfaceNormal = float3(0, 0, 1);
		float3 SurfacePoint = DesiredPos;

		if (Attachment.PrimitiveType == PRIM_TYPE_SPHERE && Attachment.PrimitiveIndex < SphereCount)
		{
			FGPUCollisionSphere Sphere = CollisionSpheres[Attachment.PrimitiveIndex];
			float3 ToParticle = DesiredPos - Sphere.Center;
			float Dist = length(ToParticle);
			SurfaceNormal = Dist > 0.0001f ? ToParticle / Dist : float3(0, 0, 1);
			SurfacePoint = Sphere.Center + SurfaceNormal * Sphere.Radius;
		}
		else if (Attachment.PrimitiveType == PRIM_TYPE_CAPSULE && Attachment.PrimitiveIndex < CapsuleCount)
		{
			FGPUCollisionCapsule Capsule = CollisionCapsules[Attachment.PrimitiveIndex];
			float3 CapsuleAxis = Capsule.End - Capsule.Start;
			float AxisT = saturate(dot(DesiredPos - Capsule.Start, CapsuleAxis) / dot(CapsuleAxis, CapsuleAxis));
			float3 ClosestOnAxis = Capsule.Start + AxisT * CapsuleAxis;
			float3 ToParticle = DesiredPos - ClosestOnAxis;
			float Dist = length(ToParticle);
			SurfaceNormal = Dist > 0.0001f ? ToParticle / Dist : float3(0, 0, 1);
			SurfacePoint = ClosestOnAxis + SurfaceNormal * Capsule.Radius;
		}
		else if (Attachment.PrimitiveType == PRIM_TYPE_BOX && Attachment.PrimitiveIndex < BoxCount)
		{
			FGPUCollisionBox Box = CollisionBoxes[Attachment.PrimitiveIndex];
			float Dummy;
			SurfacePoint = GetClosestPointOnBox(DesiredPos, Box, SurfaceNormal, Dummy);
		}
		else if (Attachment.PrimitiveType == PRIM_TYPE_CONVEX && Attachment.PrimitiveIndex < ConvexCount)
		{
			FGPUCollisionConvex Convex = CollisionConvexes[Attachment.PrimitiveIndex];
			float SignedDistance;
			GetConvexSurfaceInfo(DesiredPos, Convex, ConvexPlanes, SignedDistance, SurfaceNormal, SurfacePoint);
		}

		// Calculate tangential gravity component (gravity projected onto surface)
		// TangentGravity = gravity - (gravity · normal) * normal
		float GravityNormalComponent = dot(Gravity, SurfaceNormal);
		float3 TangentGravity = Gravity - GravityNormalComponent * SurfaceNormal;

		// Apply sliding only if gravity has tangential component (surface is not horizontal)
		float TangentMagnitude = length(TangentGravity);
		if (TangentMagnitude > 0.1f && GravitySlidingScale > 0.0f)
		{
			// Calculate sliding Velocity with friction
			// SlidingAccel = TangentGravity * (1 - friction)
			float EffectiveFriction = saturate(SlidingFriction);
			float3 SlidingAccel = TangentGravity * (1.0f - EffectiveFriction) * GravitySlidingScale;

			// Apply sliding displacement in world space
			float3 SlidingDisplacement = SlidingAccel * DeltaTime * DeltaTime * 0.5f;

			// Convert displacement to Bone local space and update LocalOffset
			float3 NewWorldPos = DesiredPos + SlidingDisplacement;

			// Re-project onto surface to prevent drifting away
			float3 ToNewPos = NewWorldPos - SurfacePoint;
			float DistToSurface = dot(ToNewPos, SurfaceNormal);
			NewWorldPos = NewWorldPos - DistToSurface * SurfaceNormal;

			// Update local offset for next frame
			Attachment.LocalOffset = WorldToBoneLocal(NewWorldPos, Bone);

			// Update particle Position
			Position = NewWorldPos;
			PredictedPosition = NewWorldPos;
			float3 DesiredVelocity = BoneVelocity + SlidingAccel * DeltaTime;
			Velocity = lerp(PreviousVelocity, DesiredVelocity, saturate(BoneVelocityScale));
		}
		else
		{
			// No sliding - just follow Bone
			Position = DesiredPos;
			PredictedPosition = DesiredPos;
			float3 DesiredVelocity = BoneVelocity;
			Velocity = lerp(PreviousVelocity, DesiredVelocity, saturate(BoneVelocityScale));
		}

		// Store relative Velocity for anisotropy (particle Velocity - Bone Velocity)
		// This ensures anisotropy only reflects movement ON the surface, not with the Bone
		Attachment.RelativeVelocity = Velocity - BoneVelocity;
	}

	// Write back to SoA buffers
	Positions[Idx3] = Position.x;
	Positions[Idx3 + 1] = Position.y;
	Positions[Idx3 + 2] = Position.z;
	PredictedPositions[Idx3] = PredictedPosition.x;
	PredictedPositions[Idx3 + 1] = PredictedPosition.y;
	PredictedPositions[Idx3 + 2] = PredictedPosition.z;
	PackedVelocities[Idx] = PackVelocity(Velocity);
	Flags[Idx] = ParticleFlags;
	Attachments[Idx] = Attachment;
}

//=============================================================================
// Clear Just Detached Flag (run at end of frame)
//=============================================================================

/**
 * @brief Compute shader entry point for ClearDetachedFlagCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearDetachedFlagCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	if (Idx >= ParticleCountBuffer[6])
	{
		return;
	}

	uint ParticleFlags = Flags[Idx];
	ParticleFlags = ClearFlag(ParticleFlags, GPU_PARTICLE_FLAG_JUST_DETACHED);
	Flags[Idx] = ParticleFlags;
}

//=============================================================================
// Stack Pressure Pass (Merged from FluidStackPressure.usf)
//=============================================================================
//=============================================================================
// Shader Parameters (SOA - Structure of Arrays)
//=============================================================================

// Fluid particle SOA buffers
Buffer<float> StackPositions;                // float3 packed as 3 floats (read-only for neighbor search)
float UniformParticleMass;              // B plan: uniform mass (same for all particles)

StructuredBuffer<FGPUParticleAttachment> StackAttachments;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

float SmoothingRadius;
float StackPressureScale;
float CellSize;

//=============================================================================
// Helper Functions
//=============================================================================

/**
 * @brief Get surface normal at position for attached particle
 */
float3 GetAttachmentSurfaceNormal(FGPUParticleAttachment Attachment, float3 WorldPos)
{
    float3 Normal = float3(0, 0, 1);

    if (Attachment.PrimitiveType == PRIM_TYPE_SPHERE && Attachment.PrimitiveIndex < SphereCount)
    {
        FGPUCollisionSphere Sphere = CollisionSpheres[Attachment.PrimitiveIndex];
        float3 ToParticle = WorldPos - Sphere.Center;
        float Dist = length(ToParticle);
        Normal = Dist > 0.0001f ? ToParticle / Dist : float3(0, 0, 1);
    }
    else if (Attachment.PrimitiveType == PRIM_TYPE_CAPSULE && Attachment.PrimitiveIndex < CapsuleCount)
    {
        FGPUCollisionCapsule Capsule = CollisionCapsules[Attachment.PrimitiveIndex];
        float3 CapsuleAxis = Capsule.End - Capsule.Start;
        float AxisT = saturate(dot(WorldPos - Capsule.Start, CapsuleAxis) / dot(CapsuleAxis, CapsuleAxis));
        float3 ClosestOnAxis = Capsule.Start + AxisT * CapsuleAxis;
        float3 ToParticle = WorldPos - ClosestOnAxis;
        float Dist = length(ToParticle);
        Normal = Dist > 0.0001f ? ToParticle / Dist : float3(0, 0, 1);
    }
    else if (Attachment.PrimitiveType == PRIM_TYPE_BOX && Attachment.PrimitiveIndex < BoxCount)
    {
        FGPUCollisionBox Box = CollisionBoxes[Attachment.PrimitiveIndex];
        Normal = CalcNumericalGradient_Box(WorldPos, Box.Center, Box.Extent, Box.Rotation);
    }
    else if (Attachment.PrimitiveType == PRIM_TYPE_CONVEX && Attachment.PrimitiveIndex < ConvexCount)
    {
        FGPUCollisionConvex Convex = CollisionConvexes[Attachment.PrimitiveIndex];
        // For Convex, use direction from center as approximation
        float3 ToParticle = WorldPos - Convex.Center;
        float Dist = length(ToParticle);
        Normal = Dist > 0.0001f ? ToParticle / Dist : float3(0, 0, 1);
    }

    return Normal;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for StackPressureCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void StackPressureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint Idx = DispatchThreadId.x;
    if (Idx >= ParticleCountBuffer[6])
    {
        return;
    }

    FGPUParticleAttachment Attachment = StackAttachments[Idx];

    // Skip non-attached particles
    if (Attachment.PrimitiveType < 0)
    {
        return;
    }

    // Read from SOA buffers
    uint Idx3 = Idx * 3;
    float3 Pos = float3(StackPositions[Idx3], StackPositions[Idx3 + 1], StackPositions[Idx3 + 2]);
    float3 Velocity = UnpackVelocity(PackedVelocities[Idx]);

    // Get surface normal at current position
    float3 SurfaceNormal = GetAttachmentSurfaceNormal(Attachment, Pos);

    // Calculate tangent gravity direction (gravity projected onto surface)
    float NormalComponent = dot(Gravity, SurfaceNormal);
    float3 TangentGravity = Gravity - NormalComponent * SurfaceNormal;
    float TangentMag = length(TangentGravity);

    // Skip if on horizontal surface (no sliding direction)
    if (TangentMag < 0.1f)
    {
        return;
    }

    float3 TangentDir = TangentGravity / TangentMag;

    // "Up" direction on the surface = opposite of tangent gravity direction
    // Particles in this direction are "above" and contribute their weight
    float3 UpDir = -TangentDir;

    // Accumulate stack weight from neighbors above
    float StackWeight = 0.0f;
    float RadiusSq = SmoothingRadius * SmoothingRadius;
    float H = SmoothingRadius * CM_TO_M;
    float H2 = H * H;

    // Precompute Poly6 coefficient for weight calculation
    float H9 = H2 * H2 * H2 * H2 * H;
    float Poly6Coeff = 315.0f / (64.0f * PI * H9);

    int3 CenterCell = WorldToCell(Pos, CellSize);
    int CellRadius = (int)ceil(SmoothingRadius / CellSize);

    // Iterate over neighboring cells
    for (int Dz = -CellRadius; Dz <= CellRadius; ++Dz)
    {
        for (int Dy = -CellRadius; Dy <= CellRadius; ++Dy)
        {
            for (int Dx = -CellRadius; Dx <= CellRadius; ++Dx)
            {
                int3 NeighborCell = CenterCell + int3(Dx, Dy, Dz);
                uint Hash = HashCell(NeighborCell);
                uint Count = min(CellCounts[Hash], (uint)MAX_PARTICLES_PER_CELL);
                uint StartIdx = Hash * MAX_PARTICLES_PER_CELL;

                for (uint I = 0; I < Count; ++I)
                {
                    uint NeighborIdx = ParticleIndices[StartIdx + I];

                    // Skip self and invalid indices
                    if (NeighborIdx == Idx || NeighborIdx >= ParticleCountBuffer[6])
                    {
                        continue;
                    }

                    // Check if neighbor is also attached
                    FGPUParticleAttachment NeighborAttachment = StackAttachments[NeighborIdx];
                    if (NeighborAttachment.PrimitiveType < 0)
                    {
                        continue;
                    }

                    // Read neighbor from SOA
                    uint NeighborIdx3 = NeighborIdx * 3;
                    float3 NeighborPos = float3(StackPositions[NeighborIdx3], StackPositions[NeighborIdx3 + 1], StackPositions[NeighborIdx3 + 2]);
                    float NeighborMass = UniformParticleMass;

                    float3 ToNeighbor = NeighborPos - Pos;
                    float DistSq = dot(ToNeighbor, ToNeighbor);

                    // Skip if too far or too close
                    if (DistSq > RadiusSq || DistSq < 0.0001f)
                    {
                        continue;
                    }

                    // Check if neighbor is "above" (in the up direction on surface)
                    float HeightDiff = dot(ToNeighbor, UpDir);

                    if (HeightDiff > 0.0f)
                    {
                        // Neighbor is above - accumulate its weight
                        float Dist = sqrt(DistSq);

                        // Weight based on SPH kernel (Poly6)
                        float DistM = Dist * CM_TO_M;
                        float R2M = DistM * DistM;
                        float Diff = H2 - R2M;
                        float KernelWeight = (Diff > 0.0f) ? Poly6Coeff * Diff * Diff * Diff : 0.0f;

                        // Weight contribution scaled by how much "above" the neighbor is
                        // and by neighbor's mass
                        float HeightFactor = HeightDiff / Dist;  // normalized height contribution
                        StackWeight += NeighborMass * KernelWeight * HeightFactor;
                    }
                }
            }
        }
    }

    // Apply stack pressure force
    if (StackWeight > 0.0f)
    {
        // Stack pressure pushes particle in the tangent gravity direction
        // (same direction it would naturally slide)
        float3 StackForce = TangentDir * StackWeight * StackPressureScale;

        // Apply to Velocity
        Velocity += StackForce * DeltaTime;

        // Write back to SOA
        PackedVelocities[Idx] = PackVelocity(Velocity);
    }
}
