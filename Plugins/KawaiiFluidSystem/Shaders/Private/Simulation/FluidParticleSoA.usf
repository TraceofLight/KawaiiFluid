// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file FluidParticleSoA.usf
 * @brief Shader implementation for FluidParticleSoA
 */

// Particle SoA (Structure of Arrays) Conversion Shaders
//
// Memory bandwidth optimization:
// 1. Split AoS FGPUFluidParticle into separate field buffers
// 2. Half-precision packing for Velocity/Density/Lambda (50% bandwidth reduction)
// 3. Uniform Mass (removed from per-particle storage)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

// Half Precision Packing Utilities: defined in KawaiiFluidParticleCore.ush
// PackHalf2, UnpackHalf2, PackVelocity, UnpackVelocity, PackDensityLambda, UnpackDensityLambda

//=============================================================================
// Split Pass: AoS → SoA
// Converts FGPUFluidParticle (64 bytes) into separate field buffers
// With half-precision packing for bandwidth optimization
//=============================================================================

StructuredBuffer<FGPUFluidParticle> SourceParticles;

// Full precision (Position is critical for simulation stability)
RWBuffer<float> OutPositions;              // float3 packed as 3 floats
RWBuffer<float> OutPredictedPositions;     // float3 packed as 3 floats

// Half precision packed (bandwidth optimization)
RWBuffer<uint2> OutPackedVelocities;       // uint2 = half4 (vel.xy, vel.z, padding)
RWBuffer<uint> OutPackedDensityLambda;     // uint = half2 (density, lambda)

// Other fields
RWBuffer<uint> OutFlags;                   // uint
RWBuffer<uint> OutNeighborCounts;          // uint
RWBuffer<int> OutParticleIDs;              // int
RWBuffer<int> OutSourceIDs;                // int

int SplitParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

/**
 * @brief Compute shader entry point for SplitAoSToSoACS
 */
[numthreads(256, 1, 1)]
void SplitAoSToSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= ParticleCountBuffer[6])
		return;

	FGPUFluidParticle p = SourceParticles[idx];

	// Position: full precision (float3 stored as 3 consecutive floats)
	uint idx3 = idx * 3;
	OutPositions[idx3 + 0] = p.Position.x;
	OutPositions[idx3 + 1] = p.Position.y;
	OutPositions[idx3 + 2] = p.Position.z;

	OutPredictedPositions[idx3 + 0] = p.PredictedPosition.x;
	OutPredictedPositions[idx3 + 1] = p.PredictedPosition.y;
	OutPredictedPositions[idx3 + 2] = p.PredictedPosition.z;

	// Velocity: half precision packed (12B → 8B) for SolveDensityPressure
	OutPackedVelocities[idx] = PackVelocity(p.Velocity);

	// Density + Lambda: half precision packed (8B → 4B)
	OutPackedDensityLambda[idx] = PackDensityLambda(p.Density, p.Lambda);

	// Other fields: unchanged
	OutFlags[idx] = p.Flags;
	OutNeighborCounts[idx] = p.NeighborCount;
	OutParticleIDs[idx] = p.ParticleID;
	OutSourceIDs[idx] = p.SourceID;
}

//=============================================================================
// Merge Pass: SoA → AoS
// Converts separate field buffers back into FGPUFluidParticle (64 bytes)
// Unpacks half-precision data back to full precision
//=============================================================================

Buffer<float> InPositions;
Buffer<float> InPredictedPositions;
// Half precision packed (bandwidth optimization)
Buffer<uint2> InPackedVelocities;
Buffer<uint> InPackedDensityLambda;
Buffer<uint> InFlags;
Buffer<uint> InNeighborCounts;
Buffer<int> InParticleIDs;
Buffer<int> InSourceIDs;

// Uniform mass for all particles (from Preset)
float MergeUniformParticleMass;

RWStructuredBuffer<FGPUFluidParticle> TargetParticles;

int MergeParticleCount;

/**
 * @brief Compute shader entry point for MergeSoAToAoSCS
 */
[numthreads(256, 1, 1)]
void MergeSoAToAoSCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= ParticleCountBuffer[6])
		return;

	// Read from separate field buffers
	uint idx3 = idx * 3;

	FGPUFluidParticle p;

	// Position: full precision
	p.Position.x = InPositions[idx3 + 0];
	p.Position.y = InPositions[idx3 + 1];
	p.Position.z = InPositions[idx3 + 2];

	p.PredictedPosition.x = InPredictedPositions[idx3 + 0];
	p.PredictedPosition.y = InPredictedPositions[idx3 + 1];
	p.PredictedPosition.z = InPredictedPositions[idx3 + 2];

	// Velocity: unpack from half-precision (8B packed)
	p.Velocity = UnpackVelocity(InPackedVelocities[idx]);

	// Density + Lambda: unpack from half-precision (4B packed)
	float density, lambda;
	UnpackDensityLambda(InPackedDensityLambda[idx], density, lambda);
	p.Density = density;
	p.Lambda = lambda;

	// Mass: uniform constant (same for all particles)
	p.Mass = MergeUniformParticleMass;

	// Other fields: unchanged
	p.Flags = InFlags[idx];
	p.NeighborCount = InNeighborCounts[idx];
	p.ParticleID = InParticleIDs[idx];
	p.SourceID = InSourceIDs[idx];

	TargetParticles[idx] = p;
}


