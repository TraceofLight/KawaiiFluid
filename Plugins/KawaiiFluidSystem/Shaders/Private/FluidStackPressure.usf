// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Stack Pressure Pass
// Applies weight transfer from stacked attached particles for realistic dripping behavior
// Particles higher up on the surface transfer their weight to particles below,
// causing lower particles to slide down faster

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidGPUPhysics.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidSpatialHash.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters (SOA - Structure of Arrays)
//=============================================================================

// Fluid particle SOA buffers
Buffer<float> Positions;                // float3 packed as 3 floats (read-only for neighbor search)
RWBuffer<uint2> PackedVelocities;       // B plan: half3 packed as uint2 (read/write)
float UniformParticleMass;              // B plan: uniform mass (same for all particles)

StructuredBuffer<FGPUParticleAttachment> Attachments;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

// Collision primitives (for surface normal calculation)
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

int SphereCount;
int CapsuleCount;
int BoxCount;
int ConvexCount;

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float SmoothingRadius;
float StackPressureScale;
float CellSize;
float3 Gravity;
float DeltaTime;

// Primitive type constants
#define PRIM_TYPE_SPHERE 0
#define PRIM_TYPE_CAPSULE 1
#define PRIM_TYPE_BOX 2
#define PRIM_TYPE_CONVEX 3

//=============================================================================
// Helper Functions
//=============================================================================

// Get surface normal at position for attached particle
float3 GetAttachmentSurfaceNormal(FGPUParticleAttachment attachment, float3 worldPos)
{
    float3 normal = float3(0, 0, 1);

    if (attachment.PrimitiveType == PRIM_TYPE_SPHERE && attachment.PrimitiveIndex < SphereCount)
    {
        FGPUCollisionSphere sphere = CollisionSpheres[attachment.PrimitiveIndex];
        float3 toParticle = worldPos - sphere.Center;
        float dist = length(toParticle);
        normal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
    }
    else if (attachment.PrimitiveType == PRIM_TYPE_CAPSULE && attachment.PrimitiveIndex < CapsuleCount)
    {
        FGPUCollisionCapsule capsule = CollisionCapsules[attachment.PrimitiveIndex];
        float3 ab = capsule.End - capsule.Start;
        float t = saturate(dot(worldPos - capsule.Start, ab) / dot(ab, ab));
        float3 closestOnAxis = capsule.Start + t * ab;
        float3 toParticle = worldPos - closestOnAxis;
        float dist = length(toParticle);
        normal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
    }
    else if (attachment.PrimitiveType == PRIM_TYPE_BOX && attachment.PrimitiveIndex < BoxCount)
    {
        FGPUCollisionBox box = CollisionBoxes[attachment.PrimitiveIndex];
        normal = CalcNumericalGradient_Box(worldPos, box.Center, box.Extent, box.Rotation);
    }
    else if (attachment.PrimitiveType == PRIM_TYPE_CONVEX && attachment.PrimitiveIndex < ConvexCount)
    {
        FGPUCollisionConvex convex = CollisionConvexes[attachment.PrimitiveIndex];
        // For convex, use direction from center as approximation
        float3 toParticle = worldPos - convex.Center;
        float dist = length(toParticle);
        normal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
    }

    return normal;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void StackPressureCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    FGPUParticleAttachment attachment = Attachments[idx];

    // Skip non-attached particles
    if (attachment.PrimitiveType < 0)
    {
        return;
    }

    // Read from SOA buffers
    uint idx3 = idx * 3;
    float3 pos = float3(Positions[idx3], Positions[idx3 + 1], Positions[idx3 + 2]);
    float3 velocity = UnpackVelocity(PackedVelocities[idx]);

    // Get surface normal at current position
    float3 surfaceNormal = GetAttachmentSurfaceNormal(attachment, pos);

    // Calculate tangent gravity direction (gravity projected onto surface)
    float normalComponent = dot(Gravity, surfaceNormal);
    float3 tangentGravity = Gravity - normalComponent * surfaceNormal;
    float tangentMag = length(tangentGravity);

    // Skip if on horizontal surface (no sliding direction)
    if (tangentMag < 0.1f)
    {
        return;
    }

    float3 tangentDir = tangentGravity / tangentMag;

    // "Up" direction on the surface = opposite of tangent gravity direction
    // Particles in this direction are "above" and contribute their weight
    float3 upDir = -tangentDir;

    // Accumulate stack weight from neighbors above
    float stackWeight = 0.0f;
    float radiusSq = SmoothingRadius * SmoothingRadius;
    float h = SmoothingRadius * CM_TO_M;
    float h2 = h * h;

    // Precompute Poly6 coefficient for weight calculation
    float h9 = h2 * h2 * h2 * h2 * h;
    float poly6Coeff = 315.0f / (64.0f * PI * h9);

    int3 centerCell = WorldToCell(pos, CellSize);
    int cellRadius = (int)ceil(SmoothingRadius / CellSize);

    // Iterate over neighboring cells
    for (int dz = -cellRadius; dz <= cellRadius; ++dz)
    {
        for (int dy = -cellRadius; dy <= cellRadius; ++dy)
        {
            for (int dx = -cellRadius; dx <= cellRadius; ++dx)
            {
                int3 neighborCell = centerCell + int3(dx, dy, dz);
                uint hash = HashCell(neighborCell);
                uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
                uint startIdx = hash * MAX_PARTICLES_PER_CELL;

                for (uint i = 0; i < count; ++i)
                {
                    uint neighborIdx = ParticleIndices[startIdx + i];

                    // Skip self and invalid indices
                    if (neighborIdx == idx || neighborIdx >= ParticleCountBuffer[6])
                    {
                        continue;
                    }

                    // Check if neighbor is also attached
                    FGPUParticleAttachment neighborAttachment = Attachments[neighborIdx];
                    if (neighborAttachment.PrimitiveType < 0)
                    {
                        continue;
                    }

                    // Read neighbor from SOA
                    uint neighborIdx3 = neighborIdx * 3;
                    float3 neighborPos = float3(Positions[neighborIdx3], Positions[neighborIdx3 + 1], Positions[neighborIdx3 + 2]);
                    float neighborMass = UniformParticleMass;

                    float3 toNeighbor = neighborPos - pos;
                    float distSq = dot(toNeighbor, toNeighbor);

                    // Skip if too far or too close
                    if (distSq > radiusSq || distSq < 0.0001f)
                    {
                        continue;
                    }

                    // Check if neighbor is "above" (in the up direction on surface)
                    float heightDiff = dot(toNeighbor, upDir);

                    if (heightDiff > 0.0f)
                    {
                        // Neighbor is above - accumulate its weight
                        float dist = sqrt(distSq);

                        // Weight based on SPH kernel (Poly6)
                        float dist_m = dist * CM_TO_M;
                        float r2_m = dist_m * dist_m;
                        float diff = h2 - r2_m;
                        float kernelWeight = (diff > 0.0f) ? poly6Coeff * diff * diff * diff : 0.0f;

                        // Weight contribution scaled by how much "above" the neighbor is
                        // and by neighbor's mass
                        float heightFactor = heightDiff / dist;  // normalized height contribution
                        stackWeight += neighborMass * kernelWeight * heightFactor;
                    }
                }
            }
        }
    }

    // Apply stack pressure force
    if (stackWeight > 0.0f)
    {
        // Stack pressure pushes particle in the tangent gravity direction
        // (same direction it would naturally slide)
        float3 stackForce = tangentDir * stackWeight * StackPressureScale;

        // Apply to velocity
        velocity += stackForce * DeltaTime;

        // Write back to SOA
        PackedVelocities[idx] = PackVelocity(velocity);
    }
}
