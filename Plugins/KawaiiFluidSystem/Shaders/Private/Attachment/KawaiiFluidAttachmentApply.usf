// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidAttachmentApply.usf
 * @brief Shader implementation for KawaiiFluidAttachmentApply
 */

// GPU Fluid Physics - Apply Boundary Attachment Pass
//
// Runs at SIMULATION START: Moves attached particles to follow bone transforms
// DIRECTLY applies bone transforms to local positions - same as BoundarySkinningCS
// This eliminates 1-frame delay by using the SAME bone transform buffer.
//
// Legacy approach: Use WorldBoundaryParticles[ParticleIndex].Position (pre-computed)
// New approach: Apply BoneTransforms[BoneIndex] * LocalPosition directly
//
// Both BoundarySkinningCS and this pass now use the IDENTICAL bone transform data,
// guaranteeing perfect synchronization with skeletal mesh rendering.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryAttachment.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryParticles.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particles buffer (read/write)
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

// Bone Delta Attachment buffer (read only for this pass)
StructuredBuffer<FGPUBoneDeltaAttachment> BoneDeltaAttachments;

// Local boundary particles (persistent, same data used by BoundarySkinningCS)
StructuredBuffer<FGPUBoundaryParticleLocal> LocalBoundaryParticles;
int BoundaryParticleCount;

// Bone transforms (SAME buffer as BoundarySkinningCS - this is the key!)
StructuredBuffer<float4x4> BoneTransforms;
int BoneCount;

// Fallback Transform for static meshes (BoneIndex == -1)
float4x4 ComponentTransform;

// Time parameter for velocity calculation
float DeltaTime;

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for ApplyBoneTransformCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyBoneTransformCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= ParticleCountBuffer[6])
	{
		return;
	}

	// Read Particle first to check NEAR_BOUNDARY flag
	FGPUFluidParticle Particle = Particles[ParticleIndex];

	// CRITICAL: Only apply attachment to particles with NEAR_BOUNDARY flag
	// This prevents non-attached (blue) particles from following boundaries
	if (!HasFlag(Particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY))
	{
		return;
	}

	// Read attachment data
	FGPUBoneDeltaAttachment Attachment = BoneDeltaAttachments[ParticleIndex];

	// Skip if not attached to a boundary particle
	if (Attachment.BoundaryParticleIndex < 0 || Attachment.BoundaryParticleIndex >= BoundaryParticleCount)
	{
		return;
	}

	// =========================================================================
	// DIRECT BONE TRANSFORM APPLICATION (Legacy-style, no 1-frame delay!)
	// Instead of reading pre-computed WorldBoundaryParticles.Position,
	// we directly apply the bone transform to the local position.
	// This uses the EXACT SAME bone transform buffer as BoundarySkinningCS,
	// guaranteeing perfect synchronization.
	// =========================================================================

	// Get the local boundary particle data
	FGPUBoundaryParticleLocal LocalParticle = LocalBoundaryParticles[Attachment.BoundaryParticleIndex];

	// Select the appropriate transform based on bone index
	float4x4 Transform;
	if (LocalParticle.BoneIndex >= 0 && LocalParticle.BoneIndex < BoneCount)
	{
		// Skeletal mesh: use bone transform
		Transform = BoneTransforms[LocalParticle.BoneIndex];
	}
	else
	{
		// Static mesh or invalid bone: use component transform
		Transform = ComponentTransform;
	}

	// Transform local position to world space (row-major, Unreal convention)
	float4 LocalPos4 = float4(LocalParticle.LocalPosition, 1.0f);
	float3 BoundaryWorldPosition = mul(LocalPos4, Transform).xyz;

	// Apply LocalOffset (stored in Attachment)
	// This allows physics to affect the particle while still following the boundary
	float3 LocalOffset = Attachment.LocalOffset;
	float3 TargetPosition = BoundaryWorldPosition + LocalOffset;

	// =========================================================================
	// VELOCITY-ONLY CORRECTION (Based on Bone Delta)
	// Update only velocity using bone movement without position correction
	// PreviousPosition = (Bone Position + LocalOffset) saved from previous frame
	// =========================================================================

	// Use bone position from previous frame (already stored in PreviousPosition)
	// PreviousPosition = (BoundaryWorldPosition + LocalOffset) from previous frame
	float3 PreviousTargetPosition = Attachment.PreviousPosition;

	// Bone movement velocity = (Current Bone Pos - Previous Bone Pos) / dt
	float3 BoneVelocity = float3(0, 0, 0);
	if (DeltaTime > 0.0001f)
	{
		BoneVelocity = (TargetPosition - PreviousTargetPosition) / DeltaTime;
	}

	// Set velocity to bone velocity (No position/PredictedPosition correction)
	Particle.Velocity = BoneVelocity;

	// Write back
	Particles[ParticleIndex] = Particle;
}
