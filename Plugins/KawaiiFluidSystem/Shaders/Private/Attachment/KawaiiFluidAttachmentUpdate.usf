// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidAttachmentUpdate.usf
 * @brief Shader implementation for KawaiiFluidAttachmentUpdate
 */

// GPU Fluid Physics - Update Bone Delta Attachment Pass
//
// Runs at SIMULATION END: Updates attachment data after physics simulation
//
// Steps:
// 1. Detach check: If distance from PreviousPosition > DetachDistance, detach
// 2. For unattached particles: Find nearest boundary particle, store OriginalIndex
// 3. Update PreviousPosition for next frame's detach check
//
// Uses OriginalIndex (stored in each boundary particle) for stable attachment
// across Z-Order sorting. This ensures the same boundary particle is referenced
// even when the sorted order changes.
//
// This is part of the bone-following system:
// 1. BoundarySkinningCS: Transform local boundary particles to world space
// 2. ApplyBoneTransform: Move fluid particles to attached BoundaryParticle positions
// 3. [Physics simulation: density, pressure, viscosity, collision]
// 4. UpdateBoneDeltaAttachment (this pass): Find/update attachments

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryAttachment.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryParticles.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidMortonUtils.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Fluid particles
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

// Bone Delta Attachment buffer (read/write)
RWStructuredBuffer<FGPUBoneDeltaAttachment> BoneDeltaAttachments;

// Z-Order sorted boundary particles (for efficient neighbor search)
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;
int BoundaryParticleCount;

// World boundary particles (unsorted, for LocalOffset calculation by OriginalIndex)
StructuredBuffer<FGPUBoundaryParticle> WorldBoundaryParticles;
int WorldBoundaryParticleCount;

// Parameters
float AttachRadius;        // Radius within which to attach to boundary (= BoundaryAttachRadius)
float DetachDistance;      // Distance threshold for detaching (= BoundaryAttachRadius * 5.0)
float AdhesionStrength;    // Adhesion strength - if 0, no attachment allowed

// Z-Order bounds (must match fluid simulation)
float3 MortonBoundsMin;
float CellSize;

// Hybrid Tiled Z-Order mode (for unlimited simulation range)
int bUseHybridTiledZOrder;

//=============================================================================
// Collision Primitives (for direct collider surface normal calculation)
//=============================================================================
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int SphereCount;
int CapsuleCount;
int BoxCount;
int BoneCount;

//=============================================================================
// Collider Surface Normal Calculation
// Finds the closest collider and returns its surface normal at contact point
//=============================================================================

/**
 * @brief Returns the nearest collider surface normal
 */
float3 GetClosestColliderNormal(float3 Position, float SearchRadius)
{
	float ClosestDistance = SearchRadius;
	float3 ClosestNormal = float3(0, 0, 1);  // Fallback: world up
	bool bFoundCollider = false;

	// NOTE: Colliders are ALREADY in world space (transformed by C++ before upload)
	// Do NOT apply bone transforms here!

	// Check spheres
	for (int SphereIndex = 0; SphereIndex < SphereCount; ++SphereIndex)
	{
		FGPUCollisionSphere Sphere = CollisionSpheres[SphereIndex];

		float3 ToPoint = Position - Sphere.Center;
		float Distance = length(ToPoint);
		float SignedDistance = Distance - Sphere.Radius;

		if (abs(SignedDistance) < ClosestDistance)
		{
			ClosestDistance = abs(SignedDistance);
			ClosestNormal = (Distance > 0.001f) ? (ToPoint / Distance) : float3(0, 0, 1);
			bFoundCollider = true;
		}
	}

	// Check capsules
	for (int CapsuleIndex = 0; CapsuleIndex < CapsuleCount; ++CapsuleIndex)
	{
		FGPUCollisionCapsule Capsule = CollisionCapsules[CapsuleIndex];

		float3 CapsuleAxis = Capsule.End - Capsule.Start;
		float AxisLengthSquared = dot(CapsuleAxis, CapsuleAxis);
		float AxisT = (AxisLengthSquared > 0.0001f) ? saturate(dot(Position - Capsule.Start, CapsuleAxis) / AxisLengthSquared) : 0.0f;
		float3 ClosestOnAxis = Capsule.Start + AxisT * CapsuleAxis;
		float3 ToPoint = Position - ClosestOnAxis;
		float Distance = length(ToPoint);
		float SignedDistance = Distance - Capsule.Radius;

		if (abs(SignedDistance) < ClosestDistance)
		{
			ClosestDistance = abs(SignedDistance);
			ClosestNormal = (Distance > 0.001f) ? (ToPoint / Distance) : float3(0, 0, 1);
			bFoundCollider = true;
		}
	}

	// Check boxes
	for (int BoxIndex = 0; BoxIndex < BoxCount; ++BoxIndex)
	{
		FGPUCollisionBox Box = CollisionBoxes[BoxIndex];

		// Transform to box local space
		float3 LocalPosition = InverseRotateByQuat(Position - Box.Center, Box.Rotation);

		// Clamp to box surface
		float3 ClampedPosition = clamp(LocalPosition, -Box.Extent, Box.Extent);

		// Find which face is closest
		float3 LocalNormal = float3(0, 0, 1);
		float3 Difference = LocalPosition - ClampedPosition;
		float DifferenceLength = length(Difference);

		if (DifferenceLength > 0.001f)
		{
			// Outside box: normal points from surface to point
			LocalNormal = Difference / DifferenceLength;
		}
		else
		{
			// Inside box: find closest face
			float3 DistanceToFace = Box.Extent - abs(LocalPosition);
			if (DistanceToFace.x <= DistanceToFace.y && DistanceToFace.x <= DistanceToFace.z)
				LocalNormal = float3(sign(LocalPosition.x), 0, 0);
			else if (DistanceToFace.y <= DistanceToFace.z)
				LocalNormal = float3(0, sign(LocalPosition.y), 0);
			else
				LocalNormal = float3(0, 0, sign(LocalPosition.z));
		}

		// Transform normal back to world space
		float3 WorldNormal = RotateByQuat(LocalNormal, Box.Rotation);
		float SignedDistance = DifferenceLength;

		if (SignedDistance < ClosestDistance)
		{
			ClosestDistance = SignedDistance;
			ClosestNormal = WorldNormal;
			bFoundCollider = true;
		}
	}

	return bFoundCollider ? normalize(ClosestNormal) : float3(0, 0, 1);
}

//=============================================================================
// Z-Order Cell ID Calculation
//=============================================================================

/**
 * @brief Computes cell key for attachment update
 */
uint GetMortonCellIDFromCellCoord_Update(int3 CellCoord)
{
	if (bUseHybridTiledZOrder)
	{
		// Hybrid Tiled Z-Order: 21-bit key (matches MAX_CELLS, no truncation needed)
		// Hash collisions (8 tile buckets) are filtered by distance check
		return ComputeHybridTiledKey(CellCoord) & (MAX_CELLS - 1);
	}
	else
	{
		// Classic Morton code with bounded range
		int3 GridMin = int3(floor(MortonBoundsMin / CellSize));
		int3 Offset = CellCoord - GridMin;
		uint3 UOffset = uint3(max(Offset, int3(0, 0, 0)));
		UOffset = min(UOffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
		return Morton3D(UOffset.x, UOffset.y, UOffset.z);
	}
}

/**
 * @brief Converts world position to update cell coordinates
 */
int3 WorldToCell_Update(float3 WorldPosition)
{
	return int3(floor(WorldPosition / CellSize));
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for UpdateBoneDeltaAttachmentCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateBoneDeltaAttachmentCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= ParticleCountBuffer[6])
	{
		return;
	}

	FGPUFluidParticle Particle = Particles[ParticleIndex];
	FGPUBoneDeltaAttachment Attachment = BoneDeltaAttachments[ParticleIndex];
	float3 Position = Particle.Position;

	//=========================================================================
	// Step 1: Detach Check (if already attached)
	// Detach if:
	//   1. Particle moved more than DetachDistance from previous position (Sudden movement)
	//   2. LocalOffset exceeds AttachRadius * 5 (Too far from Boundary)
	//=========================================================================
	if (Attachment.BoundaryParticleIndex >= 0)
	{
		float MoveDistance = length(Position - Attachment.PreviousPosition);

		// Check LocalOffset distance (distance from Boundary accumulated by physics)
		float3 LocalOffset = Attachment.LocalOffset;
		float OffsetDistance = length(LocalOffset);

		// Condition 1: Sudden movement between frames (DetachDistance = BoundaryAttachRadius * 5)
		// Condition 2: LocalOffset exceeds 5x AttachRadius (Too far from Boundary)
		if (MoveDistance > DetachDistance || OffsetDistance > AttachRadius * 5.0f)
		{
			// Detach! Distance exceeded threshold
			Attachment.BoundaryParticleIndex = BONE_DELTA_INVALID_INDEX;
			Attachment.LocalNormal = float3(0, 0, 0);
			Attachment.LocalOffset = float3(0, 0, 0);
			Particle.Flags = ClearFlag(Particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
		}
	}

	//=========================================================================
	// Step 1.5: Update LocalOffset and LocalNormal for attached particles
	// Physics simulation may have moved the particle - update LocalOffset to reflect this
	// LocalOffset = CurrentPosition - BoundaryPosition
	// LocalNormal = Surface normal from COLLIDER GEOMETRY (Sphere/Capsule/Box)
	//=========================================================================
	if (Attachment.BoundaryParticleIndex >= 0 && Attachment.BoundaryParticleIndex < WorldBoundaryParticleCount)
	{
		float3 BoundaryPosition = WorldBoundaryParticles[Attachment.BoundaryParticleIndex].Position;
		Attachment.LocalOffset = Position - BoundaryPosition;  // LocalOffset = particle position - boundary position

		// DEBUG: Test if CapsuleCount is received by shader
		// If CapsuleCount > 0, output (1, 0, 0) - red direction
		// If CapsuleCount == 0, output (0, 1, 0) - green direction
		if (CapsuleCount > 0)
		{
			Attachment.LocalNormal = float3(1, 0, 0);  // RED = capsules exist
		}
		else
		{
			Attachment.LocalNormal = float3(0, 1, 0);  // GREEN = no capsules
		}
	}

	//=========================================================================
	// Step 2: Find new attachment (if not attached)
	// Only attach particles that already have NEAR_BOUNDARY flag (set by collision)
	// This prevents ALL particles from attaching just because they spawned near player
	// Also requires AdhesionStrength > 0 (if adhesion is disabled, no attachment)
	//=========================================================================
	bool bHasNearBoundaryFlag = HasFlag(Particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
	if (Attachment.BoundaryParticleIndex < 0 && BoundaryParticleCount > 0 && bHasNearBoundaryFlag && AdhesionStrength > 0.0f)
	{
		int NearestOriginalIndex = BONE_DELTA_INVALID_INDEX;
		float NearestDistance = AttachRadius;

		// Z-Order search for nearby boundary particles
		int3 CenterCell = WorldToCell_Update(Position);
		int CellRadius = (int)ceil(AttachRadius / CellSize);
		CellRadius = min(CellRadius, 2);  // Limit search radius for performance

		for (int ZOffset = -CellRadius; ZOffset <= CellRadius; ++ZOffset)
		{
			for (int YOffset = -CellRadius; YOffset <= CellRadius; ++YOffset)
			{
				for (int XOffset = -CellRadius; XOffset <= CellRadius; ++XOffset)
				{
					int3 NeighborCell = CenterCell + int3(XOffset, YOffset, ZOffset);
					uint CellID = GetMortonCellIDFromCellCoord_Update(NeighborCell);

					// Bounds check for cell ID
					if (CellID >= MAX_CELLS)
					{
						continue;
					}

					uint CellStart = BoundaryCellStart[CellID];
					uint CellEnd = BoundaryCellEnd[CellID];

					// Skip empty cells
					if (CellStart == INVALID_INDEX || CellStart > CellEnd)
					{
						continue;
					}

					// Search boundary particles in this cell
					for (uint BoundaryIndex = CellStart; BoundaryIndex <= CellEnd && BoundaryIndex < (uint)BoundaryParticleCount; ++BoundaryIndex)
					{
						FGPUBoundaryParticle BoundaryParticle = SortedBoundaryParticles[BoundaryIndex];
						float Distance = length(Position - BoundaryParticle.Position);

						// Track nearest boundary particle with valid OriginalIndex for attachment
						if (Distance < NearestDistance && BoundaryParticle.OriginalIndex >= 0 && BoundaryParticle.OriginalIndex < WorldBoundaryParticleCount)
						{
							NearestDistance = Distance;
							NearestOriginalIndex = BoundaryParticle.OriginalIndex;
						}
					}
				}
			}
		}

		// Attach if found a nearby boundary particle
		if (NearestOriginalIndex >= 0)
		{
			Attachment.BoundaryParticleIndex = NearestOriginalIndex;

			// Initialize LocalOffset to zero (will be updated by physics)
			Attachment.LocalOffset = float3(0, 0, 0);

			// Calculate surface normal from ACTUAL COLLIDER GEOMETRY (Sphere/Capsule/Box)
			// This gives the precise contact normal at the particle's position
			// Calculate surface normal from ACTUAL COLLIDER GEOMETRY (Sphere/Capsule/Box)
			Attachment.LocalNormal = GetClosestColliderNormal(Position, AttachRadius * 2.0f);

			Particle.Flags = SetFlag(Particle.Flags, GPU_PARTICLE_FLAG_NEAR_BOUNDARY);
		}
	}

	//=========================================================================
	// Step 3: Update PreviousPosition for next frame's detach check
	//=========================================================================
	Attachment.PreviousPosition = Position;

	// Write back
	BoneDeltaAttachments[ParticleIndex] = Attachment;
	Particles[ParticleIndex] = Particle;
}
