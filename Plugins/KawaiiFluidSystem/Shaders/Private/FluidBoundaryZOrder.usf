// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Boundary Particle Z-Order Sorting
// Computes Morton codes and Cell Start/End for boundary particles
// Enables O(K) neighbor search instead of O(M) full traversal

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidMortonUtils.ush"

//=============================================================================
// Structures (must match C++ definitions in GPUFluidParticle.h)
//=============================================================================

struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "volume" (total: 16)
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID (total: 32)
	float3 Velocity;      // 12 bytes - World velocity (for moving boundaries)
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient (total: 48)
	int BoneIndex;        // 4 bytes  - Skeleton bone index (-1 for static mesh)
	float3 Padding;       // 12 bytes - Alignment padding (total: 64)
};

//=============================================================================
// Shared Parameters
//=============================================================================

int BoundaryParticleCount;
float3 BoundsMin;
float CellSize;
int bUseHybridTiledZOrder;  // 1 = Hybrid Tiled Z-Order (unlimited range), 0 = Classic Morton (bounded)

//=============================================================================
// Pass 1: Compute Boundary Morton Codes
// Calculates Morton code for each boundary particle based on position
//=============================================================================

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticlesIn;
RWStructuredBuffer<uint> BoundaryMortonCodes;
RWStructuredBuffer<uint> BoundaryParticleIndices;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeBoundaryMortonCodesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	float3 pos = BoundaryParticlesIn[idx].Position;

	// Compute cell coordinates
	int3 cellCoord = int3(floor(pos / CellSize));

	uint sortKey;
	if (bUseHybridTiledZOrder)
	{
		// Hybrid Tiled Z-Order: 21-bit key (3-bit TileHash + 18-bit LocalMorton)
		// Must match fluid particle key computation in FluidMortonCode.usf
		sortKey = ComputeHybridTiledKey(cellCoord);
	}
	else
	{
		// Classic Morton code: bounded range
		// Compute grid offset relative to bounds minimum
		int3 gridMin = int3(floor(BoundsMin / CellSize));
		int3 offset = cellCoord - gridMin;

		// Clamp to valid Morton code range
		uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
		uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

		// Compute Morton code
		sortKey = Morton3D(uoffset.x, uoffset.y, uoffset.z);
	}

	BoundaryMortonCodes[idx] = sortKey;
	BoundaryParticleIndices[idx] = idx;
}

//=============================================================================
// Pass 2: Clear Boundary Cell Start/End
// Initializes cell arrays to INVALID_INDEX before computing
//=============================================================================

RWStructuredBuffer<uint> BoundaryCellStart;
RWStructuredBuffer<uint> BoundaryCellEnd;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearBoundaryCellIndicesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint cellIdx = DispatchThreadId.x;
	if (cellIdx >= MAX_CELLS)
	{
		return;
	}

	BoundaryCellStart[cellIdx] = INVALID_INDEX;
	BoundaryCellEnd[cellIdx] = INVALID_INDEX;
}

//=============================================================================
// Pass 3: Reorder Boundary Particles by Sorted Indices
// Rearranges boundary particles according to sorted Morton code order
//=============================================================================

StructuredBuffer<FGPUBoundaryParticle> OldBoundaryParticles;
StructuredBuffer<uint> SortedBoundaryIndices;
RWStructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderBoundaryParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	uint oldIdx = SortedBoundaryIndices[idx];
	SortedBoundaryParticles[idx] = OldBoundaryParticles[oldIdx];
}

//=============================================================================
// Pass 4: Compute Boundary Cell Start/End
// Must be called AFTER boundary particles are sorted by Morton code
// Determines the range [start, end] of particles in each cell
//=============================================================================

StructuredBuffer<uint> SortedBoundaryMortonCodes;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeBoundaryCellStartEndCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	uint currentMorton = SortedBoundaryMortonCodes[idx];

	// In Hybrid mode, key is 21-bit matching MAX_CELLS (mask is a no-op)
	// Hash collisions (8 tile buckets) are filtered by distance check
	uint currentCellID = currentMorton & (MAX_CELLS - 1);

	// First particle or different from previous - this is a cell start
	if (idx == 0)
	{
		BoundaryCellStart[currentCellID] = idx;
	}
	else
	{
		uint prevMorton = SortedBoundaryMortonCodes[idx - 1];
		uint prevCellID = prevMorton & (MAX_CELLS - 1);

		if (currentCellID != prevCellID)
		{
			// End of previous cell
			BoundaryCellEnd[prevCellID] = idx - 1;
			// Start of current cell
			BoundaryCellStart[currentCellID] = idx;
		}
	}

	// Last particle - this is a cell end
	if (idx == (uint)(BoundaryParticleCount - 1))
	{
		BoundaryCellEnd[currentCellID] = idx;
	}
}
