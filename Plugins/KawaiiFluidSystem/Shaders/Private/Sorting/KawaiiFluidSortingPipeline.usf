// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidSortingPipeline.usf
 * @brief Shader implementation for KawaiiFluidSortingPipeline
 */

// GPU Fluid Physics - Sorting Pipeline Core
//
// Consolidates these passes in one file:
// 1. ComputeMortonCodesCellBasedCS
// 2. ReorderParticlesCS
// 3. BuildReverseMappingCS
// 4. ClearCellIndicesCS
// 5. ComputeCellStartEndCS

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryAttachment.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidMortonUtils.ush"

#define SORTING_THREAD_GROUP_SIZE 256
#define CELL_INDEX_THREAD_GROUP_SIZE 512

//=============================================================================
// Shared Shader Parameters
//=============================================================================

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

//=============================================================================
// Morton Code Pass Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> Particles;
RWStructuredBuffer<uint> MortonCodes;      // Output: Morton codes for sorting
RWStructuredBuffer<uint> ParticleIndices;  // Output: Particle indices (0..N-1)

float3 BoundsMin;
float CellSize;
int bUseHybridTiledZOrder;

/**
 * @brief Converts world position to simulation cell coordinates
 */
int3 WorldToCell(float3 WorldPos, float CellSz)
{
    return int3(floor(WorldPos / CellSz));
}

/**
 * @brief Computes Morton code from cell coordinates
 */
uint Morton3DFromCell(int3 CellCoord, int3 GridMin)
{
    int3 Offset = CellCoord - GridMin;
    uint3 UOffset = uint3(max(Offset, int3(0, 0, 0)));
    UOffset = min(UOffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
    return Morton3D(UOffset.x, UOffset.y, UOffset.z);
}

/**
 * @brief Compute shader entry point for ComputeMortonCodesCellBasedCS
 */
[numthreads(SORTING_THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCellBasedCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint Idx = DispatchThreadId.x;
    if (Idx >= ParticleCountBuffer[6])
    {
        return;
    }

    float3 Pos = Particles[Idx].PredictedPosition;
    int3 CellCoord = WorldToCell(Pos, CellSize);

    uint SortKey;
    if (bUseHybridTiledZOrder)
    {
        SortKey = ComputeHybridTiledKey(CellCoord);
    }
    else
    {
        int3 GridMin = int3(floor(BoundsMin / CellSize));
        SortKey = Morton3DFromCell(CellCoord, GridMin);
    }

    MortonCodes[Idx] = SortKey;
    ParticleIndices[Idx] = Idx;
}

//=============================================================================
// Reorder Pass Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> OldParticles;
StructuredBuffer<uint> SortedIndices;

RWStructuredBuffer<FGPUFluidParticle> SortedParticles;
RWStructuredBuffer<uint> OldToNewMapping;

StructuredBuffer<FGPUBoneDeltaAttachment> OldBoneDeltaAttachments;
RWStructuredBuffer<FGPUBoneDeltaAttachment> SortedBoneDeltaAttachments;
int bReorderAttachments;

/**
 * @brief Compute shader entry point for ReorderParticlesCS
 */
[numthreads(SORTING_THREAD_GROUP_SIZE, 1, 1)]
void ReorderParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint NewIdx = DispatchThreadId.x;
    if (NewIdx >= ParticleCountBuffer[6])
    {
        return;
    }

    uint OldIdx = SortedIndices[NewIdx];
    SortedParticles[NewIdx] = OldParticles[OldIdx];

    if (bReorderAttachments != 0)
    {
        SortedBoneDeltaAttachments[NewIdx] = OldBoneDeltaAttachments[OldIdx];
    }
}

/**
 * @brief Compute shader entry point for BuildReverseMappingCS
 */
[numthreads(SORTING_THREAD_GROUP_SIZE, 1, 1)]
void BuildReverseMappingCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint NewIdx = DispatchThreadId.x;
    if (NewIdx >= ParticleCountBuffer[6])
    {
        return;
    }

    uint OldIdx = SortedIndices[NewIdx];
    OldToNewMapping[OldIdx] = NewIdx;
}

//=============================================================================
// Cell Start/End Pass Parameters
//=============================================================================

StructuredBuffer<uint> SortedMortonCodes;
RWStructuredBuffer<uint> CellStart;
RWStructuredBuffer<uint> CellEnd;

/**
 * @brief Compute shader entry point for ClearCellIndicesCS
 */
[numthreads(CELL_INDEX_THREAD_GROUP_SIZE, 1, 1)]
void ClearCellIndicesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint CellIdx = DispatchThreadId.x;
    if (CellIdx >= MAX_CELLS)
    {
        return;
    }

    CellStart[CellIdx] = INVALID_INDEX;
    CellEnd[CellIdx] = INVALID_INDEX;
}

/**
 * @brief Compute shader entry point for ComputeCellStartEndCS
 */
[numthreads(CELL_INDEX_THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint Idx = DispatchThreadId.x;
    if (Idx >= ParticleCountBuffer[6])
    {
        return;
    }

    uint CurrentCode = SortedMortonCodes[Idx];
    uint CellID = CurrentCode & (MAX_CELLS - 1);

    if (Idx == 0)
    {
        CellStart[CellID] = Idx;
    }
    else
    {
        uint PrevCode = SortedMortonCodes[Idx - 1];
        uint PrevCellID = PrevCode & (MAX_CELLS - 1);

        if (CellID != PrevCellID)
        {
            CellStart[CellID] = Idx;
            CellEnd[PrevCellID] = Idx - 1;
        }
    }

    if (Idx == ParticleCountBuffer[6] - 1)
    {
        CellEnd[CellID] = Idx;
    }
}
