// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidPrefixScan.usf
 * @brief Shader implementation for KawaiiFluidPrefixScan
 */

// GPU Fluid Physics - Prefix Sum (Stream Compaction Step 2)
// Calculates exclusive prefix sum for compaction indices

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

//=============================================================================
// Shared Shader Parameters (used by multiple entry points)
// All buffers declared once to avoid redefinition errors
//=============================================================================

// Input buffer (read-only)
StructuredBuffer<uint> MarkedFlags;        // Input: 0/1 marks

// Output buffers (read-write, used by multiple shaders)
RWStructuredBuffer<uint> PrefixSums;       // Prefix sum output
RWStructuredBuffer<uint> BlockSums;        // Block sums (written by Pass 2a, scanned in Pass 2b, read by Pass 2c)

// Scalar parameters
int ElementCount;
int BlockCount;

// Shared memory for block-level scan
groupshared uint SharedData[THREAD_GROUP_SIZE * 2];
groupshared uint SharedBlockData[1024];  // Support up to 1024 blocks

//=============================================================================
// Pass 2a: Block-level Prefix Sum
// Each block computes local prefix sum and outputs block total
//=============================================================================

/**
 * @brief Compute shader entry point for PrefixSumBlockCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PrefixSumBlockCS(uint3 GroupId : SV_GroupID, uint3 GroupThreadId : SV_GroupThreadID, uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Tid = GroupThreadId.x;
	uint Gid = GroupId.x;
	uint Idx = DispatchThreadId.x;

	// Load data into shared memory
	uint Value = (Idx < (uint)ElementCount) ? MarkedFlags[Idx] : 0;
	SharedData[Tid] = Value;

	GroupMemoryBarrierWithGroupSync();

	// Up-sweep (reduce) phase
	uint Offset = 1;
	for (uint d = THREAD_GROUP_SIZE >> 1; d > 0; d >>= 1)
	{
		if (Tid < d)
		{
			uint Ai = Offset * (2 * Tid + 1) - 1;
			uint Bi = Offset * (2 * Tid + 2) - 1;
			SharedData[Bi] += SharedData[Ai];
		}
		Offset *= 2;
		GroupMemoryBarrierWithGroupSync();
	}

	// Save block sum and clear last element
	if (Tid == 0)
	{
		BlockSums[Gid] = SharedData[THREAD_GROUP_SIZE - 1];
		SharedData[THREAD_GROUP_SIZE - 1] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	// Down-sweep phase
	for (uint D2 = 1; D2 < THREAD_GROUP_SIZE; D2 *= 2)
	{
		Offset >>= 1;
		if (Tid < D2)
		{
			uint Ai = Offset * (2 * Tid + 1) - 1;
			uint Bi = Offset * (2 * Tid + 2) - 1;
			uint Temp = SharedData[Ai];
			SharedData[Ai] = SharedData[Bi];
			SharedData[Bi] += Temp;
		}
		GroupMemoryBarrierWithGroupSync();
	}

	// Write result (exclusive prefix sum)
	if (Idx < (uint)ElementCount)
	{
		PrefixSums[Idx] = SharedData[Tid];
	}
}

//=============================================================================
// Pass 2b: Scan Block Sums
// Small number of blocks, can be done in single pass
// In-place exclusive scan of block sums
//=============================================================================

/**
 * @brief Compute shader entry point for ScanBlockSumsCS
 */
[numthreads(1024, 1, 1)]
void ScanBlockSumsCS(uint3 GroupThreadId : SV_GroupThreadID)
{
	uint Tid = GroupThreadId.x;

	// Load block sum into shared memory
	uint Value = (Tid < (uint)BlockCount) ? BlockSums[Tid] : 0;
	SharedBlockData[Tid] = Value;

	GroupMemoryBarrierWithGroupSync();

	// Simple sequential exclusive scan (small data, single thread is fine)
	if (Tid == 0)
	{
		uint Sum = 0;
		for (int i = 0; i < BlockCount; i++)
		{
			uint Temp = SharedBlockData[i];
			BlockSums[i] = Sum;  // Write exclusive prefix sum back to same buffer
			Sum += Temp;
		}
	}
}

//=============================================================================
// Pass 2c: Add Block Offsets
// Add block offset to each element's prefix sum
// BlockSums now contains exclusive prefix sum of block totals (from Pass 2b)
//=============================================================================

/**
 * @brief Compute shader entry point for AddBlockOffsetsCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void AddBlockOffsetsCS(uint3 GroupId : SV_GroupID, uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint Idx = DispatchThreadId.x;
	uint Gid = GroupId.x;

	if (Idx < (uint)ElementCount)
	{
		PrefixSums[Idx] += BlockSums[Gid];
	}
}
