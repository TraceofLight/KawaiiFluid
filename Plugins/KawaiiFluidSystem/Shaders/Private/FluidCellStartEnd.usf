// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Cell Start/End Index Computation
//
// After particles are sorted by Morton code, this shader computes the
// start and end indices for each cell in the sorted array.
//
// Because particles are sorted, all particles in the same cell are contiguous.
// We only need to find where each cell begins and ends.
//
// Neighbor lookup becomes: for (i = CellStart[cellID]; i <= CellEnd[cellID]; i++)
// This is much faster than hash table linked-list traversal.
//
// Configuration (must match GPUFluidSimulatorShaders.h and FluidMortonCode.usf):
//   - GridAxisBits = 7 (7 bits per axis)
//   - GridResolution = 128 (2^7)
//   - MaxCells = 128^3 = 2,097,152
//   - Morton code (21-bit) = Cell ID (no truncation needed)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

//=============================================================================
// Configuration
//=============================================================================

// Grid configuration (must match GPUFluidSimulatorShaders.h and FluidMortonCode.usf)
#ifndef MORTON_GRID_AXIS_BITS
#define MORTON_GRID_AXIS_BITS 7  // 7 bits per axis
#endif

#define MORTON_GRID_SIZE (1 << MORTON_GRID_AXIS_BITS)  // 128 (2^7)

// Maximum number of cells = GridResolution³
// With 7-bit per axis: 128³ = 2,097,152 cells
#ifndef MAX_CELLS
#define MAX_CELLS (MORTON_GRID_SIZE * MORTON_GRID_SIZE * MORTON_GRID_SIZE)  // 2,097,152
#endif

// Invalid index marker (no particles in cell)
#define INVALID_INDEX 0xFFFFFFFF

//=============================================================================
// Shader Parameters
//=============================================================================

// Input: Sorted Morton codes (keys from radix sort)
StructuredBuffer<uint> SortedMortonCodes;

// Output: Cell start and end indices
RWStructuredBuffer<uint> CellStart;  // CellStart[cellID] = first particle index
RWStructuredBuffer<uint> CellEnd;    // CellEnd[cellID] = last particle index

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

//=============================================================================
// Clear Cell Indices
// Initialize all cells to invalid (no particles)
//=============================================================================

#define THREAD_GROUP_SIZE 512

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearCellIndicesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint cellIdx = DispatchThreadId.x;
    if (cellIdx >= MAX_CELLS)
    {
        return;
    }

    CellStart[cellIdx] = INVALID_INDEX;
    CellEnd[cellIdx] = INVALID_INDEX;
}

//=============================================================================
// Compute Cell Start/End Indices
// Detects boundaries where Morton code changes in sorted array
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    uint currentCode = SortedMortonCodes[idx];

    // Map Morton code to cell ID (could be direct mapping or hash)
    // For now, use modulo to fit into cell array size
    uint cellID = currentCode & (MAX_CELLS - 1);

    // Check if this is the first particle or Morton code changed
    if (idx == 0)
    {
        // First particle always starts a cell
        CellStart[cellID] = idx;
    }
    else
    {
        uint prevCode = SortedMortonCodes[idx - 1];
        uint prevCellID = prevCode & (MAX_CELLS - 1);

        if (cellID != prevCellID)
        {
            // New cell starts here
            CellStart[cellID] = idx;
            // Previous cell ends at idx - 1
            CellEnd[prevCellID] = idx - 1;
        }
    }

    // Check if this is the last particle
    if (idx == ParticleCountBuffer[6] - 1)
    {
        // Last particle always ends its cell
        CellEnd[cellID] = idx;
    }
}

//=============================================================================
// [DEPRECATED] Alternative: Upper-bit Morton Code Cell Lookup
// This was used for 10-bit per axis (30-bit Morton code) with 16-bit cell ID
//
// With 7-bit per axis (21-bit Morton code), Morton code = Cell ID directly,
// so this function is no longer needed. Use ComputeCellStartEndCS instead.
//=============================================================================

// Legacy: 16-bit cell ID from 30-bit Morton code (NOT USED with 7-bit grid)
#define MORTON_CELL_BITS 16

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndMortonCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // DEPRECATED: With 7-bit per axis, use ComputeCellStartEndCS instead
    // This function remains for backward compatibility only

    uint idx = DispatchThreadId.x;
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    uint currentCode = SortedMortonCodes[idx];
    // With 21-bit Morton code, use directly as cellID (no shift needed)
    uint cellID = currentCode;  // Direct mapping for 7-bit grid

    if (idx == 0)
    {
        CellStart[cellID] = idx;
    }
    else
    {
        uint prevCode = SortedMortonCodes[idx - 1];
        uint prevCellID = prevCode;

        if (cellID != prevCellID)
        {
            CellStart[cellID] = idx;
            CellEnd[prevCellID] = idx - 1;
        }
    }

    if (idx == ParticleCountBuffer[6] - 1)
    {
        CellEnd[cellID] = idx;
    }
}

//=============================================================================
// Hybrid: Cell-Based with Grid Coordinates
// Uses actual grid cell coordinates instead of Morton code
// Better for SPH where we iterate 27 neighboring cells
//=============================================================================

// Input: Sorted cell IDs (computed from position, not Morton code)
StructuredBuffer<uint> SortedCellIDs;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndGridCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    uint currentCellID = SortedCellIDs[idx];

    // Handle wrap-around for hash-based cell IDs
    uint cellIdx = currentCellID & (MAX_CELLS - 1);

    if (idx == 0)
    {
        CellStart[cellIdx] = idx;
    }
    else
    {
        uint prevCellID = SortedCellIDs[idx - 1];
        uint prevCellIdx = prevCellID & (MAX_CELLS - 1);

        if (currentCellID != prevCellID)
        {
            CellStart[cellIdx] = idx;
            CellEnd[prevCellIdx] = idx - 1;
        }
    }

    if (idx == ParticleCountBuffer[6] - 1)
    {
        CellEnd[cellIdx] = idx;
    }
}

//=============================================================================
// Validation: Count particles per cell (for debugging)
//=============================================================================

RWStructuredBuffer<uint> CellCounts;  // For validation

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ValidateCellCountsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint cellIdx = DispatchThreadId.x;
    if (cellIdx >= MAX_CELLS)
    {
        return;
    }

    uint start = CellStart[cellIdx];
    uint end = CellEnd[cellIdx];

    if (start == INVALID_INDEX || end == INVALID_INDEX)
    {
        CellCounts[cellIdx] = 0;
    }
    else
    {
        CellCounts[cellIdx] = end - start + 1;
    }
}
