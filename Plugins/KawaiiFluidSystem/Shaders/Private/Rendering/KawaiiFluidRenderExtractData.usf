// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidRenderExtractData.usf
 * @brief Shader implementation for KawaiiFluidRenderExtractData
 */

// GPU Fluid Physics - Extract Render Data Pass
// Converts physics particle buffer to render particle buffer (GPU â†’ GPU)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

//=============================================================================
// Render Particle Structure (must match FKawaiiRenderParticle - 32 bytes)
//=============================================================================

/**
 * @brief Data layout for FRenderParticle
 */
struct FRenderParticle
{
	float3 Position;
	float3 Velocity;
	float Radius;
	float Padding;
};

//=============================================================================
// Shader Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> PhysicsParticles;
RWStructuredBuffer<FRenderParticle> RenderParticles;
StructuredBuffer<uint> ParticleCountBuffer;
float ParticleRadius;

// SoA (Structure of Arrays) output buffers - Memory bandwidth optimization
RWStructuredBuffer<float3> RenderPositions;   // 12B per particle (SDF hot path)
RWStructuredBuffer<float3> RenderVelocities;  // 12B per particle (for motion blur)
RWStructuredBuffer<float3> OutputBounds;      // [0] = Min, [1] = Max
float BoundsMargin;

// Shared memory for bounds reduction (256 threads per group)
#define BOUNDS_THREAD_GROUP_SIZE 256
groupshared float3 SharedMin[BOUNDS_THREAD_GROUP_SIZE];
groupshared float3 SharedMax[BOUNDS_THREAD_GROUP_SIZE];

//=============================================================================
// Main Compute Shader (Legacy AoS output)
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractRenderDataCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	uint ParticleCount = ParticleCountBuffer[6];
	if (idx >= ParticleCount)
	{
		return;
	}

	FGPUFluidParticle physics = PhysicsParticles[idx];

	// Validate position - skip particles with invalid/extreme positions
	float3 pos = physics.Position;
	bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
						  abs(pos.x) < 1e10 && abs(pos.y) < 1e10 && abs(pos.z) < 1e10;

	FRenderParticle render;
	if (bValidPosition)
	{
		render.Position = pos;
		render.Velocity = physics.Velocity;
	}
	else
	{
		// Invalid particle - place at infinity so it won't be rendered
		render.Position = float3(1e20, 1e20, 1e20);
		render.Velocity = float3(0, 0, 0);
	}
	render.Radius = ParticleRadius;
	render.Padding = 0.0f;

	RenderParticles[idx] = render;
}

//=============================================================================
// SoA Compute Shader (Memory bandwidth optimization)
// - 32B/particle to 12B/particle (62% reduction when using Position only)
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractRenderDataSoACS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	uint ParticleCount = ParticleCountBuffer[6];
	if (idx >= ParticleCount)
	{
		return;
	}

	FGPUFluidParticle physics = PhysicsParticles[idx];

	// Validate position - skip particles with invalid/extreme positions
	float3 pos = physics.Position;
	float3 vel = physics.Velocity;

	bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
						  abs(pos.x) < 1e10 && abs(pos.y) < 1e10 && abs(pos.z) < 1e10;

	if (!bValidPosition)
	{
		// Invalid particle - place at infinity so it won't be rendered
		pos = float3(1e20, 1e20, 1e20);
		vel = float3(0, 0, 0);
	}

	// SoA output - Store each attribute in separate buffer
	RenderPositions[idx] = pos;
	RenderVelocities[idx] = vel;
}

//=============================================================================
// Extract Render Data With Bounds Compute Shader
// Dispatch: (1, 1, 1) - single group of 256 threads
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractRenderDataWithBoundsCS
 */
[numthreads(BOUNDS_THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataWithBoundsCS(uint3 GroupId : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint GI : SV_GroupIndex)
{
	// Read GPU-authoritative particle count
	uint ParticleCount = ParticleCountBuffer[6];

	// Initialize bounds with extreme values
	float3 localMin = float3(1e10, 1e10, 1e10);
	float3 localMax = float3(-1e10, -1e10, -1e10);

	// Handle empty particle case
	if (ParticleCount == 0)
	{
		if (GI == 0)
		{
			OutputBounds[0] = float3(0, 0, 0);
			OutputBounds[1] = float3(0, 0, 0);
		}
		return;
	}

	// Grid-stride loop: each thread processes particles at indices GI, GI+256, GI+512, ...
	const float MAX_VALID_COORD = 100000.0f;

	for (uint i = GI; i < ParticleCount; i += BOUNDS_THREAD_GROUP_SIZE)
	{
		FGPUFluidParticle physics = PhysicsParticles[i];
		float3 pos = physics.Position;

		// Validate position
		bool bValidPosition = !any(isnan(pos)) && !any(isinf(pos)) &&
							  abs(pos.x) < MAX_VALID_COORD &&
							  abs(pos.y) < MAX_VALID_COORD &&
							  abs(pos.z) < MAX_VALID_COORD;

		// Create render particle
		FRenderParticle render;
		if (bValidPosition)
		{
			render.Position = pos;
			render.Velocity = physics.Velocity;

			// Update local bounds
			localMin = min(localMin, pos);
			localMax = max(localMax, pos);
		}
		else
		{
			// Invalid particle - place at infinity so it won't be rendered
			render.Position = float3(1e20, 1e20, 1e20);
			render.Velocity = float3(0, 0, 0);
		}
		render.Radius = ParticleRadius;
		render.Padding = 0.0f;

		// Write render particle
		RenderParticles[i] = render;
	}

	// Store local bounds in shared memory
	SharedMin[GI] = localMin;
	SharedMax[GI] = localMax;

	GroupMemoryBarrierWithGroupSync();

	// Parallel reduction within work group (log2(256) = 8 iterations)
	[unroll]
	for (uint s = BOUNDS_THREAD_GROUP_SIZE / 2; s > 0; s >>= 1)
	{
		if (GI < s)
		{
			SharedMin[GI] = min(SharedMin[GI], SharedMin[GI + s]);
			SharedMax[GI] = max(SharedMax[GI], SharedMax[GI + s]);
		}
		GroupMemoryBarrierWithGroupSync();
	}

	// Thread 0 writes final result with margin expansion
	if (GI == 0)
	{
		float3 finalMin = SharedMin[0];
		float3 finalMax = SharedMax[0];

		// Check if we found any valid particles
		bool hasValidBounds = (finalMin.x < 1e9) && (finalMax.x > -1e9);

		if (hasValidBounds)
		{
			float expansion = ParticleRadius + BoundsMargin;
			OutputBounds[0] = finalMin - float3(expansion, expansion, expansion);
			OutputBounds[1] = finalMax + float3(expansion, expansion, expansion);
		}
		else
		{
			// No valid particles found
			OutputBounds[0] = float3(0, 0, 0);
			OutputBounds[1] = float3(0, 0, 0);
		}
	}
}
