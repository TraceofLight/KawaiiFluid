// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidRenderExtractData.usf
 * @brief Shader implementation for KawaiiFluidRenderExtractData
 */

// GPU Fluid Physics - Extract Render Data Pass
// Converts physics particle buffer to render particle buffer (GPU â†’ GPU)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"

//=============================================================================
// Render Particle Structure (must match FKawaiiRenderParticle - 32 bytes)
//=============================================================================

/**
 * @brief Data layout for FRenderParticle
 */
struct FRenderParticle
{
	float3 Position;
	float3 Velocity;
	float Radius;
	float Padding;
};

//=============================================================================
// Shader Parameters
//=============================================================================

StructuredBuffer<FGPUFluidParticle> PhysicsParticles;
RWStructuredBuffer<FRenderParticle> RenderParticles;
StructuredBuffer<uint> ParticleCountBuffer;
float ParticleRadius;

// SoA (Structure of Arrays) output buffers - Memory bandwidth optimization
RWStructuredBuffer<float3> RenderPositions;   // 12B per particle (SDF hot path)
RWStructuredBuffer<float3> RenderVelocities;  // 12B per particle (for motion blur)
RWStructuredBuffer<float3> OutputBounds;      // [0] = Min, [1] = Max
float BoundsMargin;

// Shared memory for bounds reduction (256 threads per group)
#define BOUNDS_THREAD_GROUP_SIZE 256
groupshared float3 SharedMin[BOUNDS_THREAD_GROUP_SIZE];
groupshared float3 SharedMax[BOUNDS_THREAD_GROUP_SIZE];

//=============================================================================
// Main Compute Shader (Legacy AoS output)
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractRenderDataCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	uint ParticleCount = ParticleCountBuffer[6];
	if (ParticleIndex >= ParticleCount)
	{
		return;
	}

	FGPUFluidParticle PhysicsParticle = PhysicsParticles[ParticleIndex];

	// Validate position - skip particles with invalid/extreme positions
	float3 Position = PhysicsParticle.Position;
	bool bValidPosition = !any(isnan(Position)) && !any(isinf(Position)) &&
						  abs(Position.x) < 1e10 && abs(Position.y) < 1e10 && abs(Position.z) < 1e10;

	FRenderParticle RenderParticle;
	if (bValidPosition)
	{
		RenderParticle.Position = Position;
		RenderParticle.Velocity = PhysicsParticle.Velocity;
	}
	else
	{
		// Invalid particle - place at infinity so it won't be rendered
		RenderParticle.Position = float3(1e20, 1e20, 1e20);
		RenderParticle.Velocity = float3(0, 0, 0);
	}
	RenderParticle.Radius = ParticleRadius;
	RenderParticle.Padding = 0.0f;

	RenderParticles[ParticleIndex] = RenderParticle;
}

//=============================================================================
// SoA Compute Shader (Memory bandwidth optimization)
// - 32B/particle to 12B/particle (62% reduction when using Position only)
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractRenderDataSoACS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	uint ParticleCount = ParticleCountBuffer[6];
	if (ParticleIndex >= ParticleCount)
	{
		return;
	}

	FGPUFluidParticle PhysicsParticle = PhysicsParticles[ParticleIndex];

	// Validate position - skip particles with invalid/extreme positions
	float3 Position = PhysicsParticle.Position;
	float3 Velocity = PhysicsParticle.Velocity;

	bool bValidPosition = !any(isnan(Position)) && !any(isinf(Position)) &&
						  abs(Position.x) < 1e10 && abs(Position.y) < 1e10 && abs(Position.z) < 1e10;

	if (!bValidPosition)
	{
		// Invalid particle - place at infinity so it won't be rendered
		Position = float3(1e20, 1e20, 1e20);
		Velocity = float3(0, 0, 0);
	}

	// SoA output - Store each attribute in separate buffer
	RenderPositions[ParticleIndex] = Position;
	RenderVelocities[ParticleIndex] = Velocity;
}

//=============================================================================
// Extract Render Data With Bounds Compute Shader
// Dispatch: (1, 1, 1) - single group of 256 threads
//=============================================================================

/**
 * @brief Compute shader entry point for ExtractRenderDataWithBoundsCS
 */
[numthreads(BOUNDS_THREAD_GROUP_SIZE, 1, 1)]
void ExtractRenderDataWithBoundsCS(uint3 GroupId : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint GI : SV_GroupIndex)
{
	// Read GPU-authoritative particle count
	uint ParticleCount = ParticleCountBuffer[6];

	// Initialize bounds with extreme values
	float3 LocalMin = float3(1e10, 1e10, 1e10);
	float3 LocalMax = float3(-1e10, -1e10, -1e10);

	// Handle empty particle case
	if (ParticleCount == 0)
	{
		if (GI == 0)
		{
			OutputBounds[0] = float3(0, 0, 0);
			OutputBounds[1] = float3(0, 0, 0);
		}
		return;
	}

	// Grid-stride loop: each thread processes particles at indices GI, GI+256, GI+512, ...
	const float MAX_VALID_COORD = 100000.0f;

	for (uint ParticleIndex = GI; ParticleIndex < ParticleCount; ParticleIndex += BOUNDS_THREAD_GROUP_SIZE)
	{
		FGPUFluidParticle PhysicsParticle = PhysicsParticles[ParticleIndex];
		float3 Position = PhysicsParticle.Position;

		// Validate position
		bool bValidPosition = !any(isnan(Position)) && !any(isinf(Position)) &&
							  abs(Position.x) < MAX_VALID_COORD &&
							  abs(Position.y) < MAX_VALID_COORD &&
							  abs(Position.z) < MAX_VALID_COORD;

		// Create render particle
		FRenderParticle RenderParticle;
		if (bValidPosition)
		{
			RenderParticle.Position = Position;
			RenderParticle.Velocity = PhysicsParticle.Velocity;

			// Update local bounds
			LocalMin = min(LocalMin, Position);
			LocalMax = max(LocalMax, Position);
		}
		else
		{
			// Invalid particle - place at infinity so it won't be rendered
			RenderParticle.Position = float3(1e20, 1e20, 1e20);
			RenderParticle.Velocity = float3(0, 0, 0);
		}
		RenderParticle.Radius = ParticleRadius;
		RenderParticle.Padding = 0.0f;

		// Write render particle
		RenderParticles[ParticleIndex] = RenderParticle;
	}

	// Store local bounds in shared memory
	SharedMin[GI] = LocalMin;
	SharedMax[GI] = LocalMax;

	GroupMemoryBarrierWithGroupSync();

	// Parallel reduction within work group (log2(256) = 8 iterations)
	[unroll]
	for (uint Stride = BOUNDS_THREAD_GROUP_SIZE / 2; Stride > 0; Stride >>= 1)
	{
		if (GI < Stride)
		{
			SharedMin[GI] = min(SharedMin[GI], SharedMin[GI + Stride]);
			SharedMax[GI] = max(SharedMax[GI], SharedMax[GI + Stride]);
		}
		GroupMemoryBarrierWithGroupSync();
	}

	// Thread 0 writes final result with margin expansion
	if (GI == 0)
	{
		float3 FinalMin = SharedMin[0];
		float3 FinalMax = SharedMax[0];

		// Check if we found any valid particles
		bool bHasValidBounds = (FinalMin.x < 1e9) && (FinalMax.x > -1e9);

		if (bHasValidBounds)
		{
			float Expansion = ParticleRadius + BoundsMargin;
			OutputBounds[0] = FinalMin - float3(Expansion, Expansion, Expansion);
			OutputBounds[1] = FinalMax + float3(Expansion, Expansion, Expansion);
		}
		else
		{
			// No valid particles found
			OutputBounds[0] = float3(0, 0, 0);
			OutputBounds[1] = float3(0, 0, 0);
		}
	}
}
