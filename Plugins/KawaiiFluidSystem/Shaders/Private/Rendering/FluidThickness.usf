// Copyright 2026 Team_Bruteforce. All Rights Reserved.

/**
 * @file FluidThickness.usf
 * @brief Shader implementation for FluidThickness
 */

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidCommon.ush"

//-----------------------------------------------------------------------------
// Parameters
//-----------------------------------------------------------------------------

// Particle data buffer
StructuredBuffer<float3> ParticlePositions;

// Rendering parameters
float ParticleRadius;
float4x4 ViewMatrix;
float4x4 ProjectionMatrix;

// Thickness scale
float ThicknessScale;

// Scene Depth for occlusion test
Texture2D SceneDepthTexture;
SamplerState SceneDepthSampler;

// Parameters for SceneDepth UV transformation
float2 SceneViewRect;    // SceneDepth valid area size (Screen Percentage applied)
float2 SceneTextureSize; // SceneDepth texture total size

//-----------------------------------------------------------------------------
// Vertex Shader
//-----------------------------------------------------------------------------

/**
 * @brief Data layout for FVertexInput
 */
struct FVertexInput
{
	uint InstanceId : SV_InstanceID;
	uint VertexId : SV_VertexID;
};

/**
 * @brief Data layout for FVertexOutput
 */
struct FVertexOutput
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
	float3 ViewSpacePosition : TEXCOORD1;
	float3 ParticleViewCenter : TEXCOORD2;
	float ParticleRadius : TEXCOORD3;
	float4 ScreenPosition : TEXCOORD4; // Screen space position for occlusion test
};

// Billboard quad vertices
static const float2 QuadVertices[4] =
{
	float2(-1.0, -1.0),
	float2( 1.0, -1.0),
	float2(-1.0,  1.0),
	float2( 1.0,  1.0)
};

// Billboard UV
static const float2 QuadUVs[4] =
{
	float2(0.0, 1.0),
	float2(1.0, 1.0),
	float2(0.0, 0.0),
	float2(1.0, 0.0)
};

/**
 * @brief Vertex shader entry point
 */
FVertexOutput MainVS(FVertexInput Input)
{
	FVertexOutput Output;

	// Get particle world position
	float3 ParticleWorldPosition = ParticlePositions[Input.InstanceId];

	// Transform to view space
	float4 ParticleViewPosition = mul(float4(ParticleWorldPosition, 1.0), ViewMatrix);

	// Generate billboard quad offset
	float2 QuadOffset = QuadVertices[Input.VertexId] * ParticleRadius;

	// Apply quad offset in view space
	float3 ViewSpacePosition = ParticleViewPosition.xyz;
	ViewSpacePosition.xy += QuadOffset;

	// Projection
	Output.Position = mul(float4(ViewSpacePosition, 1.0), ProjectionMatrix);
	Output.UV = QuadUVs[Input.VertexId];
	Output.ViewSpacePosition = ViewSpacePosition;
	Output.ParticleViewCenter = ParticleViewPosition.xyz;
	Output.ParticleRadius = ParticleRadius;
	Output.ScreenPosition = Output.Position; // Screen position for occlusion test

	return Output;
}

//-----------------------------------------------------------------------------
// Pixel Shader
//-----------------------------------------------------------------------------

/**
 * @brief Pixel shader entry point
 */
float MainPS(FVertexOutput Input) : SV_Target0
{
	// =========================================================================
	// Occlusion Test: Remove particles occluded by scene geometry
	// =========================================================================

	// Calculate Screen UV
	float2 ScreenUV = Input.ScreenPosition.xy / Input.ScreenPosition.w;
	ScreenUV = ScreenUV * 0.5 + 0.5;
	ScreenUV.y = 1.0 - ScreenUV.y;

	// SceneDepth UV transformation: Map ScreenUV to SceneDepth valid area
	float2 SceneUV = ScreenUV * (SceneViewRect / SceneTextureSize);

	// Sample Scene Depth and perform occlusion test
	float SceneDeviceDepth = SceneDepthTexture.Sample(SceneDepthSampler, SceneUV).r;

	// Reversed-Z: 0.0 = far, 1.0 = near
	// Discard if billboard quad is behind scene geometry
	if (Input.Position.z < SceneDeviceDepth)
	{
		discard;
	}

	// =========================================================================
	// Thickness Calculation
	// =========================================================================

	// Unit position within billboard (transform UV to -1~1 range)
	float2 UnitPosition = Input.UV * 2.0 - 1.0;
	float DistanceSquared = dot(UnitPosition, UnitPosition);

	// Discard if outside sphere shape
	if (DistanceSquared > 1.0)
	{
		discard;
	}

	// Calculate sphere thickness (2 * sqrt(r^2 - dist^2))
	// Perform normalized calculation then apply radius
	float NormalizedThickness = 2.0 * sqrt(1.0 - DistanceSquared);

	// Actual world-space thickness = normalized thickness * particle radius * scale
	float Thickness = NormalizedThickness * Input.ParticleRadius * ThicknessScale;

    return Thickness;
}
