// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file FluidBoundarySkinning.usf
 * @brief Shader implementation for FluidBoundarySkinning
 */

// GPU Boundary Particle Skinning
// Transforms bone-local boundary particles to world space using bone transforms

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryParticles.ush"

#define THREAD_GROUP_SIZE 256

//=============================================================================
// Shader Parameters
//=============================================================================

// Input: Local boundary particles (persistent, uploaded once)
StructuredBuffer<FGPUBoundaryParticleLocal> LocalBoundaryParticles;

// Output: World-space boundary particles (updated each frame)
RWStructuredBuffer<FGPUBoundaryParticle> WorldBoundaryParticles;

// Previous frame positions for velocity calculation
StructuredBuffer<FGPUBoundaryParticle> PreviousWorldBoundaryParticles;

// Bone transforms (uploaded each frame) - 4x3 matrix packed as 3 float4
// [Row0.xyz, Row1.x] [Row1.yz, Row2.xy] [Row2.z, Translation.xyz]
// Using float4x4 for simplicity - only first 3 rows used
StructuredBuffer<float4x4> BoneTransforms;

int BoundaryParticleCount;
int BoneCount;
int OwnerID;
int bHasPreviousFrame;  // 1 if previous frame data is valid, 0 otherwise

// Fallback transform for static meshes (BoneIndex == -1)
float4x4 ComponentTransform;

// Delta time for velocity calculation
float DeltaTime;

//=============================================================================
// Main Skinning Shader
//=============================================================================

/**
 * @brief Compute shader entry point for BoundarySkinningCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundarySkinningCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	FGPUBoundaryParticleLocal local = LocalBoundaryParticles[idx];

	float4x4 transform;

	if (local.BoneIndex >= 0 && local.BoneIndex < BoneCount)
	{
		// Skeletal mesh: use bone transform
		transform = BoneTransforms[local.BoneIndex];
	}
	else
	{
		// Static mesh or invalid bone: use component transform
		transform = ComponentTransform;
	}

	// Transform position: WorldPos = LocalPos * Transform (row-major, Unreal convention)
	float4 localPos4 = float4(local.LocalPosition, 1.0f);
	float3 worldPos = mul(localPos4, transform).xyz;

	// Transform normal (rotation only, no translation)
	// Safety check: normalize(0) produces NaN, so fall back to up vector if LocalNormal is zero
	float3x3 rotationMatrix = (float3x3)transform;
	float3 transformedNormal = mul(local.LocalNormal, rotationMatrix);
	float normalLen = length(transformedNormal);
	float3 worldNormal = (normalLen > 0.001f) ? (transformedNormal / normalLen) : float3(0, 0, 1);

	// Calculate velocity from position difference
	float3 velocity = float3(0, 0, 0);
	if (bHasPreviousFrame && DeltaTime > 0.0001f)
	{
		float3 prevPos = PreviousWorldBoundaryParticles[idx].Position;
		velocity = (worldPos - prevPos) / DeltaTime;
	}

	// Write output
	FGPUBoundaryParticle output;
	output.Position = worldPos;
	output.Psi = local.Psi;
	output.Normal = worldNormal;
	output.OwnerID = OwnerID;
	output.Velocity = velocity;
	output.FrictionCoeff = local.FrictionCoeff;
	output.BoneIndex = local.BoneIndex;  // Preserve bone index for attachment system
	output.OriginalIndex = idx;          // Store original index for stable attachment after Z-Order sorting
	output.Padding1 = 0;
	output.Padding2 = 0;

	WorldBoundaryParticles[idx] = output;
}
