// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidBoundaryTransform.usf
 * @brief Shader implementation for KawaiiFluidBoundaryTransform
 */

// GPU Boundary Particle Skinning
// Transforms bone-local boundary particles to world space using bone transforms

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryParticles.ush"

#define THREAD_GROUP_SIZE 256

//=============================================================================
// Shader Parameters
//=============================================================================

// Input: Local boundary particles (persistent, uploaded once)
StructuredBuffer<FGPUBoundaryParticleLocal> LocalBoundaryParticles;

// Output: World-space boundary particles (updated each frame)
RWStructuredBuffer<FGPUBoundaryParticle> WorldBoundaryParticles;

// Previous frame positions for velocity calculation
StructuredBuffer<FGPUBoundaryParticle> PreviousWorldBoundaryParticles;

// Bone transforms (uploaded each frame) - 4x3 matrix packed as 3 float4
// [Row0.xyz, Row1.x] [Row1.yz, Row2.xy] [Row2.z, Translation.xyz]
// Using float4x4 for simplicity - only first 3 rows used
StructuredBuffer<float4x4> BoneTransforms;

int BoundaryParticleCount;
int BoneCount;
int OwnerID;
int bHasPreviousFrame;  // 1 if previous frame data is valid, 0 otherwise

// Fallback transform for static meshes (BoneIndex == -1)
float4x4 ComponentTransform;

// Delta time for velocity calculation
float DeltaTime;

//=============================================================================
// Main Skinning Shader
//=============================================================================

/**
 * @brief Compute shader entry point for BoundarySkinningCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundarySkinningCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= (uint)BoundaryParticleCount)
	{
		return;
	}

	FGPUBoundaryParticleLocal LocalParticle = LocalBoundaryParticles[ParticleIndex];

	float4x4 Transform;

	if (LocalParticle.BoneIndex >= 0 && LocalParticle.BoneIndex < BoneCount)
	{
		// Skeletal mesh: use bone transform
		Transform = BoneTransforms[LocalParticle.BoneIndex];
	}
	else
	{
		// Static mesh or invalid bone: use component transform
		Transform = ComponentTransform;
	}

	// Transform position: WorldPos = LocalPos * Transform (row-major, Unreal convention)
	float4 LocalPos4 = float4(LocalParticle.LocalPosition, 1.0f);
	float3 WorldPosition = mul(LocalPos4, Transform).xyz;

	// Transform normal (rotation only, no translation)
	// Safety check: normalize(0) produces NaN, so fall back to up vector if LocalNormal is zero
	float3x3 RotationMatrix = (float3x3)Transform;
	float3 TransformedNormal = mul(LocalParticle.LocalNormal, RotationMatrix);
	float NormalLength = length(TransformedNormal);
	float3 WorldNormal = (NormalLength > 0.001f) ? (TransformedNormal / NormalLength) : float3(0, 0, 1);

	// Calculate velocity from position difference
	float3 Velocity = float3(0, 0, 0);
	if (bHasPreviousFrame && DeltaTime > 0.0001f)
	{
		float3 PreviousPosition = PreviousWorldBoundaryParticles[ParticleIndex].Position;
		Velocity = (WorldPosition - PreviousPosition) / DeltaTime;
	}

	// Write output particle
	FGPUBoundaryParticle OutputParticle;
	OutputParticle.Position = WorldPosition;
	OutputParticle.Psi = LocalParticle.Psi;
	OutputParticle.Normal = WorldNormal;
	OutputParticle.OwnerID = OwnerID;
	OutputParticle.Velocity = Velocity;
	OutputParticle.FrictionCoeff = LocalParticle.FrictionCoeff;
	OutputParticle.BoneIndex = LocalParticle.BoneIndex;  // Preserve bone index for attachment system
	OutputParticle.OriginalIndex = ParticleIndex;          // Store original index for stable attachment after Z-Order sorting
	OutputParticle.Padding1 = 0;
	OutputParticle.Padding2 = 0;

	WorldBoundaryParticles[ParticleIndex] = OutputParticle;
}
