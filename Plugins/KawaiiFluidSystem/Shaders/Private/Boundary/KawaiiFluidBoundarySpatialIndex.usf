// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidBoundarySpatialIndex.usf
 * @brief Shader implementation for KawaiiFluidBoundarySpatialIndex
 */

// GPU Fluid Physics - Boundary Particle Z-Order Sorting
// Computes Morton codes and Cell Start/End for boundary particles
// Enables O(K) neighbor search instead of O(M) full traversal

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidBoundaryParticles.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidMortonUtils.ush"

//=============================================================================
// Shared Parameters
//=============================================================================

int BoundaryParticleCount;
float3 BoundsMin;
float CellSize;
int bUseHybridTiledZOrder;  // 1 = Hybrid Tiled Z-Order (unlimited range), 0 = Classic Morton (bounded)

//=============================================================================
// Pass 1: Compute Boundary Morton Codes
// Calculates Morton code for each boundary particle based on position
//=============================================================================

StructuredBuffer<FGPUBoundaryParticle> BoundaryParticlesIn;
RWStructuredBuffer<uint> BoundaryMortonCodes;
RWStructuredBuffer<uint> BoundaryParticleIndices;

/**
 * @brief Compute shader entry point for ComputeBoundaryMortonCodesCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeBoundaryMortonCodesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= (uint)BoundaryParticleCount)
	{
		return;
	}

	float3 Position = BoundaryParticlesIn[ParticleIndex].Position;

	// Compute cell coordinates
	int3 CellCoord = int3(floor(Position / CellSize));

	uint SortKey;
	if (bUseHybridTiledZOrder)
	{
		// Hybrid Tiled Z-Order: 21-bit key (3-bit TileHash + 18-bit LocalMorton)
		// Must match fluid particle key computation in FluidMortonCode.usf
		SortKey = ComputeHybridTiledKey(CellCoord);
	}
	else
	{
		// Classic Morton code: bounded range
		// Compute grid Offset relative to bounds minimum
		int3 GridMin = int3(floor(BoundsMin / CellSize));
		int3 Offset = CellCoord - GridMin;

		// Clamp to valid Morton code range
		uint3 UOffset = uint3(max(Offset, int3(0, 0, 0)));
		UOffset = min(UOffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

		// Compute Morton code
		SortKey = Morton3D(UOffset.x, UOffset.y, UOffset.z);
	}

	BoundaryMortonCodes[ParticleIndex] = SortKey;
	BoundaryParticleIndices[ParticleIndex] = ParticleIndex;
}

//=============================================================================
// Pass 2: Clear Boundary Cell Start/End
// Initializes cell arrays to INVALID_INDEX before computing
//=============================================================================

RWStructuredBuffer<uint> BoundaryCellStart;
RWStructuredBuffer<uint> BoundaryCellEnd;

/**
 * @brief Compute shader entry point for ClearBoundaryCellIndicesCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearBoundaryCellIndicesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint CellIndex = DispatchThreadId.x;
	if (CellIndex >= MAX_CELLS)
	{
		return;
	}

	BoundaryCellStart[CellIndex] = INVALID_INDEX;
	BoundaryCellEnd[CellIndex] = INVALID_INDEX;
}

//=============================================================================
// Pass 3: Reorder Boundary Particles by Sorted Indices
// Rearranges boundary particles according to sorted Morton code order
//=============================================================================

StructuredBuffer<FGPUBoundaryParticle> OldBoundaryParticles;
StructuredBuffer<uint> SortedBoundaryIndices;
RWStructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;

/**
 * @brief Compute shader entry point for ReorderBoundaryParticlesCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderBoundaryParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= (uint)BoundaryParticleCount)
	{
		return;
	}

	uint OldIndex = SortedBoundaryIndices[ParticleIndex];
	SortedBoundaryParticles[ParticleIndex] = OldBoundaryParticles[OldIndex];
}

//=============================================================================
// Pass 4: Compute Boundary Cell Start/End
// Must be called AFTER boundary particles are sorted by Morton code
// Determines the range [start, end] of particles in each cell
//=============================================================================

StructuredBuffer<uint> SortedBoundaryMortonCodes;

/**
 * @brief Compute shader entry point for ComputeBoundaryCellStartEndCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeBoundaryCellStartEndCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= (uint)BoundaryParticleCount)
	{
		return;
	}

	uint CurrentMorton = SortedBoundaryMortonCodes[ParticleIndex];

	// In Hybrid mode, key is 21-bit matching MAX_CELLS (mask is a no-op)
	// Hash collisions (8 tile buckets) are filtered by distance check
	uint CurrentCellID = CurrentMorton & (MAX_CELLS - 1);

	// First particle or different from previous - this is a cell start
	if (ParticleIndex == 0)
	{
		BoundaryCellStart[CurrentCellID] = ParticleIndex;
	}
	else
	{
		uint PreviousMorton = SortedBoundaryMortonCodes[ParticleIndex - 1];
		uint PreviousCellID = PreviousMorton & (MAX_CELLS - 1);

		if (CurrentCellID != PreviousCellID)
		{
			// End of previous cell
			BoundaryCellEnd[PreviousCellID] = ParticleIndex - 1;
			// Start of current cell
			BoundaryCellStart[CurrentCellID] = ParticleIndex;
		}
	}

	// Last particle - this is a cell end
	if (ParticleIndex == (uint)(BoundaryParticleCount - 1))
	{
		BoundaryCellEnd[CurrentCellID] = ParticleIndex;
	}
}
