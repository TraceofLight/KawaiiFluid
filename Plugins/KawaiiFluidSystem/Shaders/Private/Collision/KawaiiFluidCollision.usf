// Copyright 2026 Team_Bruteforce. All Rights Reserved.
/**
 * @file KawaiiFluidCollision.usf
 * @brief Unified collision shaders for bounds, heightmap, and primitives
 */
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidParticleCore.ush"
#include "/Plugin/KawaiiFluidSystem/Public/KawaiiFluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters (SoA - Structure of Arrays)
//=============================================================================

RWBuffer<float> Positions;
RWBuffer<float> PredictedPositions;
RWBuffer<uint2> PackedVelocities;  // B plan: half3 packed
Buffer<uint> PackedDensityLambda;   // B plan: half2 packed (read-only for feedback)
Buffer<int> SourceIDs;              // Read-only for feedback
RWBuffer<uint> Flags;

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float ParticleRadius;

// OBB parameters
float3 BoundsCenter;
float3 BoundsExtent;
float4 BoundsRotation;  // Quaternion (x, y, z, w)
int bUseOBB;

// Legacy AABB parameters
float3 BoundsMin;
float3 BoundsMax;

// Collision response
float Restitution;
float Friction;

//=============================================================================
// Quaternion Helpers
//=============================================================================

/**
 * @brief Rotate vector by quaternion: Quaternion * Vector * Quaternion^-1
 */
float3 QuatRotateVector(float4 Quaternion, float3 Vector)
{
	// Optimized quaternion-vector rotation
	// Quaternion = (x, y, z, w) where w is scalar part
	float3 QuaternionVectorPart = float3(Quaternion.x, Quaternion.y, Quaternion.z);
	float QuaternionScalarPart = Quaternion.w;

	float3 RotationTerm = 2.0f * cross(QuaternionVectorPart, Vector);
	return Vector + QuaternionScalarPart * RotationTerm + cross(QuaternionVectorPart, RotationTerm);
}

/**
 * @brief Rotate vector by inverse (conjugate) of quaternion
 */
float3 QuatRotateVectorInverse(float4 Quaternion, float3 Vector)
{
	// For unit quaternion, inverse = conjugate = (-x, -y, -z, w)
	float4 QuaternionConjugate = float4(-Quaternion.x, -Quaternion.y, -Quaternion.z, Quaternion.w);
	return QuatRotateVector(QuaternionConjugate, Vector);
}

//=============================================================================
// Position-Level Friction Helper for Axis-Aligned Collision
// Applies friction at position level per Unified Particle Physics (Macklin 2014)
//=============================================================================

/**
 * @brief Applies axis-aligned friction response
 */
void ApplyAxisFriction(
	inout float3 PredictedPos,
	float3 OriginalPos,
	float3 Normal,
	float Penetration,
	inout float3 Vel)
{
	// Push out of collision
	PredictedPos += Normal * Penetration;

	// Calculate displacement from original position
	float3 DeltaX = PredictedPos - OriginalPos;

	// Decompose into Normal and tangent
	float DeltaXNormalScalar = dot(DeltaX, Normal);
	float3 DeltaXNormalVector = DeltaXNormalScalar * Normal;
	float3 DeltaXTangent = DeltaX - DeltaXNormalVector;

	float TangentLength = length(DeltaXTangent);

	if (TangentLength > SMALL_NUMBER)
	{
		// Reference distance for friction scaling
		float FrictionReferenceDistance = max(Penetration, 0.1f);

		// Static friction threshold
		float StaticThreshold = Friction * FrictionReferenceDistance;

		if (TangentLength < StaticThreshold)
		{
			// Static friction: stop movement
			DeltaXTangent = float3(0, 0, 0);
		}
		else
		{
			// Kinetic friction: reduce tangent displacement
			float FrictionScale = min(Friction * FrictionReferenceDistance / TangentLength, 1.0f);
			DeltaXTangent *= (1.0f - FrictionScale);
		}
	}

	// Reconstruct position
	PredictedPos = OriginalPos + DeltaXNormalVector + DeltaXTangent;

	// Apply restitution to Velocity for next timestep's bounce
	float VelocityAlongNormal = dot(Vel, Normal);
	if (VelocityAlongNormal < 0.0f)
	{
		Vel -= (1.0f + Restitution) * VelocityAlongNormal * Normal;
	}
}

//=============================================================================
// AABB Collision with Position-Level Friction
//=============================================================================

/**
 * @brief Applies axis-aligned Box collision response
 */
void ApplyAABBCollision(inout float3 Pos, float3 OriginalPos, inout float3 Vel, inout uint FlagsValue)
{
	// Effective bounds considering particle radius
	float3 EffectiveMin = BoundsMin + ParticleRadius;
	float3 EffectiveMax = BoundsMax - ParticleRadius;

	bool bHitGround = false;

	// X axis collision
	if (Pos.x < EffectiveMin.x)
	{
		float Penetration = EffectiveMin.x - Pos.x;
		ApplyAxisFriction(Pos, OriginalPos, float3(1, 0, 0), Penetration, Vel);
		OriginalPos = Pos; // Update for subsequent axis checks
	}
	else if (Pos.x > EffectiveMax.x)
	{
		float Penetration = Pos.x - EffectiveMax.x;
		ApplyAxisFriction(Pos, OriginalPos, float3(-1, 0, 0), Penetration, Vel);
		OriginalPos = Pos;
	}

	// Y axis collision
	if (Pos.y < EffectiveMin.y)
	{
		float Penetration = EffectiveMin.y - Pos.y;
		ApplyAxisFriction(Pos, OriginalPos, float3(0, 1, 0), Penetration, Vel);
		OriginalPos = Pos;
	}
	else if (Pos.y > EffectiveMax.y)
	{
		float Penetration = Pos.y - EffectiveMax.y;
		ApplyAxisFriction(Pos, OriginalPos, float3(0, -1, 0), Penetration, Vel);
		OriginalPos = Pos;
	}

	// Z axis collision (typically ground collision)
	if (Pos.z < EffectiveMin.z)
	{
		float Penetration = EffectiveMin.z - Pos.z;
		ApplyAxisFriction(Pos, OriginalPos, float3(0, 0, 1), Penetration, Vel);
		bHitGround = true;
	}
	else if (Pos.z > EffectiveMax.z)
	{
		float Penetration = Pos.z - EffectiveMax.z;
		ApplyAxisFriction(Pos, OriginalPos, float3(0, 0, -1), Penetration, Vel);
	}

	// Update ground flag
	if (bHitGround)
	{
		FlagsValue = SetFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
	else
	{
		FlagsValue = ClearFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
}

//=============================================================================
// OBB Collision with Position-Level Friction
//=============================================================================

/**
 * @brief Applies oriented Box collision response
 */
void ApplyOBBCollision(inout float3 Pos, float3 OriginalPos, inout float3 Vel, inout uint FlagsValue)
{
	// Transform positions from world space to OBB local space
	float3 LocalPos = QuatRotateVectorInverse(BoundsRotation, Pos - BoundsCenter);
	float3 LocalOriginalPos = QuatRotateVectorInverse(BoundsRotation, OriginalPos - BoundsCenter);
	float3 LocalVel = QuatRotateVectorInverse(BoundsRotation, Vel);

	// Effective extents considering particle radius
	float3 EffectiveExtent = BoundsExtent - ParticleRadius;
	EffectiveExtent = max(EffectiveExtent, float3(0.001f, 0.001f, 0.001f));  // Prevent negative

	bool bHitGround = false;

	// X axis collision (in local space)
	if (LocalPos.x < -EffectiveExtent.x)
	{
		float Penetration = -EffectiveExtent.x - LocalPos.x;
		ApplyAxisFriction(LocalPos, LocalOriginalPos, float3(1, 0, 0), Penetration, LocalVel);
		LocalOriginalPos = LocalPos;
	}
	else if (LocalPos.x > EffectiveExtent.x)
	{
		float Penetration = LocalPos.x - EffectiveExtent.x;
		ApplyAxisFriction(LocalPos, LocalOriginalPos, float3(-1, 0, 0), Penetration, LocalVel);
		LocalOriginalPos = LocalPos;
	}

	// Y axis collision (in local space)
	if (LocalPos.y < -EffectiveExtent.y)
	{
		float Penetration = -EffectiveExtent.y - LocalPos.y;
		ApplyAxisFriction(LocalPos, LocalOriginalPos, float3(0, 1, 0), Penetration, LocalVel);
		LocalOriginalPos = LocalPos;
	}
	else if (LocalPos.y > EffectiveExtent.y)
	{
		float Penetration = LocalPos.y - EffectiveExtent.y;
		ApplyAxisFriction(LocalPos, LocalOriginalPos, float3(0, -1, 0), Penetration, LocalVel);
		LocalOriginalPos = LocalPos;
	}

	// Z axis collision (in local space - typically floor/ceiling)
	if (LocalPos.z < -EffectiveExtent.z)
	{
		float Penetration = -EffectiveExtent.z - LocalPos.z;
		ApplyAxisFriction(LocalPos, LocalOriginalPos, float3(0, 0, 1), Penetration, LocalVel);
		bHitGround = true;
	}
	else if (LocalPos.z > EffectiveExtent.z)
	{
		float Penetration = LocalPos.z - EffectiveExtent.z;
		ApplyAxisFriction(LocalPos, LocalOriginalPos, float3(0, 0, -1), Penetration, LocalVel);
	}

	// Update ground flag
	if (bHitGround)
	{
		FlagsValue = SetFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
	else
	{
		FlagsValue = ClearFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Transform back to world space
	Pos = QuatRotateVector(BoundsRotation, LocalPos) + BoundsCenter;
	Vel = QuatRotateVector(BoundsRotation, LocalVel);
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for BoundsCollisionCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundsCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= ParticleCountBuffer[6])
	{
		return;
	}

	uint ParticleIndex3 = ParticleIndex * 3;
	uint FlagsValue = Flags[ParticleIndex];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles still need collision with simulation bounds
	if (HasFlag(FlagsValue, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Read SoA buffers
	float3 Pos = float3(PredictedPositions[ParticleIndex3], PredictedPositions[ParticleIndex3 + 1], PredictedPositions[ParticleIndex3 + 2]);
	float3 OriginalPos = float3(Positions[ParticleIndex3], Positions[ParticleIndex3 + 1], Positions[ParticleIndex3 + 2]);
	float3 Vel = UnpackVelocity(PackedVelocities[ParticleIndex]);

	// Apply collision based on mode (with position-level friction)
	if (bUseOBB != 0)
	{
		ApplyOBBCollision(Pos, OriginalPos, Vel, FlagsValue);
	}
	else
	{
		ApplyAABBCollision(Pos, OriginalPos, Vel, FlagsValue);
	}

	// Write back to SoA buffers
	PredictedPositions[ParticleIndex3] = Pos.x;
	PredictedPositions[ParticleIndex3 + 1] = Pos.y;
	PredictedPositions[ParticleIndex3 + 2] = Pos.z;

	PackedVelocities[ParticleIndex] = PackVelocity(Vel);

	Flags[ParticleIndex] = FlagsValue;
}

//=============================================================================
// Heightmap Collision Parameters
//=============================================================================

// Heightmap texture
Texture2D<float> HeightmapTexture;
SamplerState HeightmapSampler;

// World space transform parameters
float3 WorldMin;         // Heightmap coverage min XYZ
float3 WorldMax;         // Heightmap coverage max XYZ
float2 InvWorldExtent;   // 1/(Max.xy - Min.xy) for UV transform
int TextureWidth;
int TextureHeight;
float InvTextureWidth;   // 1/TextureWidth for texel offset
float InvTextureHeight;  // 1/TextureHeight for texel offset

// Collision response parameters
float NormalStrength;    // Normal calculation strength (gradient scale)
float CollisionOffset;   // Extra offset for collision detection

//=============================================================================
// Helper Functions
//=============================================================================

/**
 * @brief Convert world XY position to heightmap UV coordinates
 */
float2 WorldToUV(float2 WorldXY)
{
	return (WorldXY - WorldMin.xy) * InvWorldExtent;
}

/**
 * @brief Check if world position is within heightmap bounds (XY only)
 */
bool IsInHeightmapBounds(float2 WorldXY)
{
	return WorldXY.x >= WorldMin.x && WorldXY.x <= WorldMax.x &&
	       WorldXY.y >= WorldMin.y && WorldXY.y <= WorldMax.y;
}

/**
 * @brief Sample terrain height at UV coordinates
 * Returns world Z position of terrain surface
 */
float SampleTerrainHeight(float2 UV)
{
	// Clamp UV to valid range
	UV = saturate(UV);

	// Sample heightmap (normalized 0-1 value)
	float NormalizedHeight = HeightmapTexture.SampleLevel(HeightmapSampler, UV, 0);

	// Convert to world Z
	return lerp(WorldMin.z, WorldMax.z, NormalizedHeight);
}

/**
 * @brief Calculate terrain Normal using Sobel gradient
 * Uses central differences for smooth Normal calculation
 */
float3 CalculateTerrainNormal(float2 UV)
{
	// Texel size for gradient calculation
	float2 TexelSize = float2(InvTextureWidth, InvTextureHeight);

	// Sample heights in a cross pattern (Sobel-like)
	float HeightLeft = SampleTerrainHeight(UV + float2(-TexelSize.x, 0));  // Left
	float HeightRight = SampleTerrainHeight(UV + float2(TexelSize.x, 0));   // Right
	float HeightDown = SampleTerrainHeight(UV + float2(0, -TexelSize.y));  // Down
	float HeightUp = SampleTerrainHeight(UV + float2(0, TexelSize.y));   // Up

	// Calculate gradient (dZ/dX, dZ/dY)
	// World space extent per texel
	float WorldTexelX = (WorldMax.x - WorldMin.x) * InvTextureWidth;
	float WorldTexelY = (WorldMax.y - WorldMin.y) * InvTextureHeight;

	float DZdX = (HeightRight - HeightLeft) / (2.0f * WorldTexelX);
	float DZdY = (HeightUp - HeightDown) / (2.0f * WorldTexelY);

	// Normal = normalize(-dZ/dX, -dZ/dY, 1)
	// The -gradient points uphill, we want the surface Normal pointing up
	float3 Normal = normalize(float3(-DZdX * NormalStrength, -DZdY * NormalStrength, 1.0f));

	return Normal;
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for HeightmapCollisionCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void HeightmapCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= ParticleCountBuffer[6])
	{
		return;
	}

	uint ParticleIndex3 = ParticleIndex * 3;
	uint FlagsValue = Flags[ParticleIndex];

	// Skip CPU-attached particles (they follow bone position directly)
	if (HasFlag(FlagsValue, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Read SoA buffers
	float3 Pos = float3(PredictedPositions[ParticleIndex3], PredictedPositions[ParticleIndex3 + 1], PredictedPositions[ParticleIndex3 + 2]);
	float3 OriginalPos = float3(Positions[ParticleIndex3], Positions[ParticleIndex3 + 1], Positions[ParticleIndex3 + 2]);
	float3 Vel = UnpackVelocity(PackedVelocities[ParticleIndex]);

	// Check if particle is within heightmap XY bounds
	if (!IsInHeightmapBounds(Pos.xy))
	{
		return;
	}

	// Convert world XY to UV
	float2 UV = WorldToUV(Pos.xy);

	// Sample terrain height at particle XY position
	float TerrainZ = SampleTerrainHeight(UV);

	// Calculate terrain Normal from heightmap gradient
	float3 Normal = CalculateTerrainNormal(UV);

	// Terrain surface point directly below particle (in XY)
	float3 TerrainPoint = float3(Pos.xy, TerrainZ);

	// Calculate signed distance from particle CENTER to terrain PLANE
	// This is geometrically correct for sloped terrain!
	// Positive = particle center is above terrain Plane
	// Negative = particle center is below terrain Plane
	float SignedDistance = dot(Pos - TerrainPoint, Normal);

	// Penetration depth (how much particle radius penetrates terrain)
	// Penetration > 0 means collision
	float Penetration = (ParticleRadius + CollisionOffset) - SignedDistance;

	if (Penetration > 0.0f)
	{
		// === Heightmap-specific collision response (no hardcoded offset) ===
		// Push out with minimal skin offset to prevent flickering
		const float SkinOffset = 0.01f;  // Much smaller than the 0.1f in shared function
		Pos += Normal * (Penetration + SkinOffset);

		// Position-level friction (Coulomb model)
		// Calculate displacement from original position
		float3 DeltaX = Pos - OriginalPos;
		float DeltaXNormal = dot(DeltaX, Normal);
		float3 DeltaXTangent = DeltaX - DeltaXNormal * Normal;
		float TangentLength = length(DeltaXTangent);

		// Apply friction using Penetration depth as Normal force proxy
		if (TangentLength > 0.001f)
		{
			float MaxTangent = Friction * Penetration;
			if (TangentLength < MaxTangent)
			{
				// Static friction: stop tangent motion
				Pos = OriginalPos + DeltaXNormal * Normal;
			}
			else
			{
				// Kinetic friction: reduce tangent motion
				float FrictionScale = MaxTangent / TangentLength;
				Pos = OriginalPos + DeltaXNormal * Normal + DeltaXTangent * (1.0f - FrictionScale);
			}
		}

		// Apply restitution to Velocity for bounce effect
		float VelocityAlongNormal = dot(Vel, Normal);
		if (VelocityAlongNormal < 0.0f)
		{
			Vel -= (1.0f + Restitution) * VelocityAlongNormal * Normal;
		}

		// Mark particle as near ground (used by adhesion system)
		if (Normal.z > 0.5f)
		{
			FlagsValue = SetFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
		}

		// Mark as collided this frame
		FlagsValue = SetFlag(FlagsValue, GPU_PARTICLE_FLAG_HAS_COLLIDED);
	}
	else if (SignedDistance > ParticleRadius * 3.0f)
	{
		// Clear near ground flag if particle is well above terrain
		// (SignedDistance > 0 means above terrain Plane)
		FlagsValue = ClearFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back to SoA buffers
	PredictedPositions[ParticleIndex3] = Pos.x;
	PredictedPositions[ParticleIndex3 + 1] = Pos.y;
	PredictedPositions[ParticleIndex3 + 2] = Pos.z;

	PackedVelocities[ParticleIndex] = PackVelocity(Vel);

	Flags[ParticleIndex] = FlagsValue;
}

//=============================================================================
// Primitive Collision Parameters
//=============================================================================

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision threshold
float CollisionThreshold;

//=============================================================================
// Unified Collision Feedback Buffer
// All feedback types merged into single buffer with embedded counters
// Layout: [Header:16B][BoneFeedback][SMFeedback][FISMFeedback]
//=============================================================================

// Unified feedback buffer (byte-addressable for header access)
RWByteAddressBuffer UnifiedFeedbackBuffer;

// Enable/disable feedback recording (0 = disabled, 1 = enabled)
int bEnableCollisionFeedback;

// Buffer layout constants (must match C++ GPUCollisionFeedbackManager constants)
// Header: [BoneCount:4][SMCount:4][FISMCount:4][Reserved:4]
#define UNIFIED_HEADER_SIZE 16
#define FEEDBACK_STRUCT_SIZE 96  // sizeof(FGPUCollisionFeedback) = 96 bytes

// Max entries per section
#define MAX_BONE_FEEDBACK 4096
#define MAX_SM_FEEDBACK 1024
#define MAX_FISM_FEEDBACK 1024

// Section offsets (in bytes)
#define BONE_FEEDBACK_OFFSET UNIFIED_HEADER_SIZE
#define SM_FEEDBACK_OFFSET (BONE_FEEDBACK_OFFSET + MAX_BONE_FEEDBACK * FEEDBACK_STRUCT_SIZE)
#define FISM_FEEDBACK_OFFSET (SM_FEEDBACK_OFFSET + MAX_SM_FEEDBACK * FEEDBACK_STRUCT_SIZE)

// Counter offsets in header (in bytes)
#define BONE_COUNTER_OFFSET 0
#define SM_COUNTER_OFFSET 4
#define FISM_COUNTER_OFFSET 8

//=============================================================================
// Collider Contact Count Buffer (for simple collision count)
//=============================================================================

// Number of colliding particles per collider (atomic increment)
RWStructuredBuffer<uint> ColliderContactCounts;

// Maximum collider count
int MaxColliderCount;

//=============================================================================
// Helper Function: Write Feedback Struct to ByteAddressBuffer
//=============================================================================

/**
 * @brief Writes FGPUCollisionFeedback struct to unified buffer at given byte offset
 * FGPUCollisionFeedback layout (96 bytes):
 *   Row 1: ParticleIndex(4) + ColliderIndex(4) + ColliderType(4) + Density(4)
 *   Row 2: ImpactNormal(12) + Penetration(4)
 *   Row 3: ParticleVelocity(12) + ColliderOwnerID(4)
 *   Row 4: ParticleSourceID(4) + ParticleActorID(4) + BoneIndex(4) + Padding1(4)
 *   Row 5: ImpactOffset(12) + Padding2(4)
 *   Row 6: ParticlePosition(12) + Padding3(4)
 */
void WriteFeedbackToBuffer(uint ByteOffset, int ParticleIdx, int ColliderIdx, int ColliderType,
                           float Density, float3 Normal, float Penetration, float3 Velocity,
                           int ColliderOwnerID, int ParticleSourceID, int BoneIndex,
                           float3 ImpactOffset, float3 ParticlePosition)
{
	// Row 1: ParticleIndex, ColliderIndex, ColliderType, Density
	UnifiedFeedbackBuffer.Store4(ByteOffset, uint4(
		asuint(ParticleIdx),
		asuint(ColliderIdx),
		asuint(ColliderType),
		asuint(Density)
	));

	// Row 2: ImpactNormal.xyz, Penetration
	UnifiedFeedbackBuffer.Store4(ByteOffset + 16, uint4(
		asuint(Normal.x),
		asuint(Normal.y),
		asuint(Normal.z),
		asuint(Penetration)
	));

	// Row 3: ParticleVelocity.xyz, ColliderOwnerID
	UnifiedFeedbackBuffer.Store4(ByteOffset + 32, uint4(
		asuint(Velocity.x),
		asuint(Velocity.y),
		asuint(Velocity.z),
		asuint(ColliderOwnerID)
	));

	// Row 4: ParticleSourceID, ParticleActorID(0), BoneIndex, Padding1(0)
	UnifiedFeedbackBuffer.Store4(ByteOffset + 48, uint4(
		asuint(ParticleSourceID),
		0,  // ParticleActorID
		asuint(BoneIndex),
		0   // Padding1
	));

	// Row 5: ImpactOffset.xyz, Padding2(0)
	UnifiedFeedbackBuffer.Store4(ByteOffset + 64, uint4(
		asuint(ImpactOffset.x),
		asuint(ImpactOffset.y),
		asuint(ImpactOffset.z),
		0   // Padding2
	));

	// Row 6: ParticlePosition.xyz, Padding3(0)
	UnifiedFeedbackBuffer.Store4(ByteOffset + 80, uint4(
		asuint(ParticlePosition.x),
		asuint(ParticlePosition.y),
		asuint(ParticlePosition.z),
		0   // Padding3
	));
}

//=============================================================================
// Helper Function: Record Collision Feedback
//=============================================================================

/**
 * @brief Records collision feedback for CPU readback (particle -> player interaction)
 * Uses atomic counter in unified buffer header to safely write to shared buffer
 *
 * Unified Buffer Layout:
 * - Header[0]: BoneCount, Header[4]: SMCount, Header[8]: FISMCount
 * - BoneIndex >= 0 -> BoneFeedback section
 * - BoneIndex < 0, bHasFluidInteraction = 0 -> SMFeedback section
 * - BoneIndex < 0, bHasFluidInteraction = 1 -> FISMFeedback section
 *
 * @param ParticleIdx - Index of the colliding particle
 * @param ColliderIdx - Index of the collider (unique across all types)
 * @param ColliderType - Type of collider (0=Sphere, 1=Capsule, 2=Box, 3=Convex)
 * @param Density - Particle Density at collision time
 * @param Normal - Collision surface Normal
 * @param Penetration - Penetration depth (cm)
 * @param Velocity - Particle Velocity (for drag force calculation)
 * @param ColliderOwnerID - Unique ID of collider owner (for filtering by actor)
 * @param ParticleSourceID - Particle's SourceID (PresetIndex | ComponentIndex << 16)
 * @param BoneIndex - Bone index for per-bone force calculation (-1 = no bone)
 * @param bHasFluidInteraction - 1 if from FluidInteraction component, 0 if from WorldCollision
 * @param ImpactWorld - Impact position in world space
 * @param ParticlePosition - Particle world position (for buoyancy center calculation)
 */
void RecordCollisionFeedback(int ParticleIdx, int ColliderIdx, int ColliderType,
                             float Density, float3 Normal, float Penetration, float3 Velocity,
                             int ColliderOwnerID, int ParticleSourceID, int BoneIndex,
                             int bHasFluidInteraction, float3 ImpactWorld, float3 ParticlePosition)
{
	// Increment collision count per collider (always executed)
	if (ColliderIdx >= 0 && ColliderIdx < MaxColliderCount)
	{
		uint Dummy;
		InterlockedAdd(ColliderContactCounts[ColliderIdx], 1, Dummy);
	}

	// Record detailed feedback when enabled
	if (bEnableCollisionFeedback == 0)
	{
		return;
	}

	// Compute impact offset in bone local space
	float3 ImpactOffset = float3(0, 0, 0);
	if (BoneIndex >= 0 && BoneIndex < BoneCount)
	{
		ImpactOffset = WorldToBoneLocal(ImpactWorld, BoneTransforms[BoneIndex]);
	}

	// Route to appropriate section of unified buffer
	uint FeedbackIdx;
	uint ByteOffset;

	if (BoneIndex >= 0)
	{
		// SkeletalMesh bone colliders -> BoneFeedback section
		UnifiedFeedbackBuffer.InterlockedAdd(BONE_COUNTER_OFFSET, 1, FeedbackIdx);
		if ((int)FeedbackIdx < MAX_BONE_FEEDBACK)
		{
			ByteOffset = BONE_FEEDBACK_OFFSET + FeedbackIdx * FEEDBACK_STRUCT_SIZE;
			WriteFeedbackToBuffer(ByteOffset, ParticleIdx, ColliderIdx, ColliderType,
			                      Density, Normal, Penetration, Velocity,
			                      ColliderOwnerID, ParticleSourceID, BoneIndex,
			                      ImpactOffset, ParticlePosition);
		}
	}
	else if (bHasFluidInteraction != 0)
	{
		// FluidInteraction StaticMesh -> FISMFeedback section
		UnifiedFeedbackBuffer.InterlockedAdd(FISM_COUNTER_OFFSET, 1, FeedbackIdx);
		if ((int)FeedbackIdx < MAX_FISM_FEEDBACK)
		{
			ByteOffset = FISM_FEEDBACK_OFFSET + FeedbackIdx * FEEDBACK_STRUCT_SIZE;
			WriteFeedbackToBuffer(ByteOffset, ParticleIdx, ColliderIdx, ColliderType,
			                      Density, Normal, Penetration, Velocity,
			                      ColliderOwnerID, ParticleSourceID, BoneIndex,
			                      ImpactOffset, ParticlePosition);
		}
	}
	else
	{
		// WorldCollision StaticMesh -> SMFeedback section
		UnifiedFeedbackBuffer.InterlockedAdd(SM_COUNTER_OFFSET, 1, FeedbackIdx);
		if ((int)FeedbackIdx < MAX_SM_FEEDBACK)
		{
			ByteOffset = SM_FEEDBACK_OFFSET + FeedbackIdx * FEEDBACK_STRUCT_SIZE;
			WriteFeedbackToBuffer(ByteOffset, ParticleIdx, ColliderIdx, ColliderType,
			                      Density, Normal, Penetration, Velocity,
			                      ColliderOwnerID, ParticleSourceID, BoneIndex,
			                      ImpactOffset, ParticlePosition);
		}
	}
}

//=============================================================================
// Main Compute Shader
//=============================================================================

/**
 * @brief Compute shader entry point for PrimitiveCollisionCS
 */
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void PrimitiveCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ParticleIndex = DispatchThreadId.x;
	if (ParticleIndex >= ParticleCountBuffer[6])
	{
		return;
	}

	uint ParticleIndex3 = ParticleIndex * 3;
	uint FlagsValue = Flags[ParticleIndex];

	// Skip CPU-attached particles only (they follow bone position directly)
	// Boundary-attached particles still need collision detection
	if (HasFlag(FlagsValue, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Read SoA buffers
	float3 Pos = float3(PredictedPositions[ParticleIndex3], PredictedPositions[ParticleIndex3 + 1], PredictedPositions[ParticleIndex3 + 2]);
	float3 OriginalPos = float3(Positions[ParticleIndex3], Positions[ParticleIndex3 + 1], Positions[ParticleIndex3 + 2]);
	float3 Vel = UnpackVelocity(PackedVelocities[ParticleIndex]);
	float Density, Lambda;
	UnpackDensityLambda(PackedDensityLambda[ParticleIndex], Density, Lambda);
	int SourceID = SourceIDs[ParticleIndex];
	bool bCollided = false;

	// Check collision with all spheres
	// NOTE: Collision test based on particle center (ParticleRadius not applied)
	for (int SphereIndex = 0; SphereIndex < SphereCount; ++SphereIndex)
	{
		FGPUCollisionSphere Sphere = CollisionSpheres[SphereIndex];
		float Sdf = sdSphere(Pos, Sphere.Center, Sphere.Radius);
		float EffectiveDist = Sdf;  // Center-based

		if (EffectiveDist < CollisionThreshold)
		{
			float3 Normal = CalcNumericalGradient_Sphere(Pos, Sphere.Center, Sphere.Radius);
			float Penetration = max(0.0f, -EffectiveDist);
			float3 ImpactWorld = Pos - Normal * Sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(Pos, OriginalPos, Vel, Normal, Penetration, Sphere.Friction, Sphere.Restitution);
			OriginalPos = Pos;  // Update for subsequent collisions
			bCollided = true;

			// Record feedback for particle -> player interaction (includes Velocity for drag calculation)
			RecordCollisionFeedback(ParticleIndex, SphereIndex, COLLIDER_TYPE_SPHERE, Density, Normal, Penetration, Vel, Sphere.OwnerID, SourceID, Sphere.BoneIndex, Sphere.bHasFluidInteraction, ImpactWorld, Pos);
		}
	}

	// Check collision with all capsules
	// NOTE: Collision test based on particle center (ParticleRadius not applied)
	for (int CapsuleIndex = 0; CapsuleIndex < CapsuleCount; ++CapsuleIndex)
	{
		FGPUCollisionCapsule Capsule = CollisionCapsules[CapsuleIndex];
		float Sdf = sdCapsule(Pos, Capsule.Start, Capsule.End, Capsule.Radius);
		float EffectiveDist = Sdf;  // Center-based

		if (EffectiveDist < CollisionThreshold)
		{
			float3 Normal = CalcNumericalGradient_Capsule(Pos, Capsule.Start, Capsule.End, Capsule.Radius);
			float Penetration = max(0.0f, -EffectiveDist);
			float3 ImpactWorld = Pos - Normal * Sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(Pos, OriginalPos, Vel, Normal, Penetration, Capsule.Friction, Capsule.Restitution);
			OriginalPos = Pos;
			bCollided = true;

			// Record feedback for particle -> player interaction (includes Velocity for drag calculation)
			RecordCollisionFeedback(ParticleIndex, SphereCount + CapsuleIndex, COLLIDER_TYPE_CAPSULE, Density, Normal, Penetration, Vel, Capsule.OwnerID, SourceID, Capsule.BoneIndex, Capsule.bHasFluidInteraction, ImpactWorld, Pos);
		}
	}

	// Check collision with all boxes
	// NOTE: Collision test based on particle center (ParticleRadius not applied)
	for (int BoxIndex = 0; BoxIndex < BoxCount; ++BoxIndex)
	{
		FGPUCollisionBox Box = CollisionBoxes[BoxIndex];
		float Sdf = sdBox(Pos, Box.Center, Box.Extent, Box.Rotation);
		float EffectiveDist = Sdf;  // Center-based

		if (EffectiveDist < CollisionThreshold)
		{
			float3 Normal = CalcNumericalGradient_Box(Pos, Box.Center, Box.Extent, Box.Rotation);
			float Penetration = max(0.0f, -EffectiveDist);
			float3 ImpactWorld = Pos - Normal * Sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(Pos, OriginalPos, Vel, Normal, Penetration, Box.Friction, Box.Restitution);
			OriginalPos = Pos;

			// Mark as near ground if collision Normal is mostly upward
			if (Normal.z > 0.5f)
			{
				FlagsValue = SetFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes Velocity for drag calculation)
			RecordCollisionFeedback(ParticleIndex, SphereCount + CapsuleCount + BoxIndex, COLLIDER_TYPE_BOX, Density, Normal, Penetration, Vel, Box.OwnerID, SourceID, Box.BoneIndex, Box.bHasFluidInteraction, ImpactWorld, Pos);
		}
	}

	// Check collision with all Convex hulls
	for (int ConvexIndex = 0; ConvexIndex < ConvexCount; ++ConvexIndex)
	{
		FGPUCollisionConvex Convex = CollisionConvexes[ConvexIndex];

		// Early out with bounding Sphere (Center-based)
		float BoundingDistance = length(Pos - Convex.Center) - Convex.BoundingRadius;
		if (BoundingDistance > CollisionThreshold)
		{
			continue;
		}

		float Sdf = sdConvex(Pos, Convex.Center, Convex.BoundingRadius,
		                     Convex.PlaneStartIndex, Convex.PlaneCount, ConvexPlanes);
		float EffectiveDist = Sdf;  // Center-based

		if (EffectiveDist < CollisionThreshold)
		{
			// Find the closest Plane for Normal calculation
			float3 Normal = float3(0, 0, 1);
			float MaxDistance = -1e10f;
			for (int PlaneIndex = 0; PlaneIndex < Convex.PlaneCount; ++PlaneIndex)
			{
				FGPUConvexPlane Plane = ConvexPlanes[Convex.PlaneStartIndex + PlaneIndex];
				float Distance = dot(Pos, Plane.Normal) - Plane.Distance;
				if (Distance > MaxDistance)
				{
					MaxDistance = Distance;
					Normal = Plane.Normal;
				}
			}

			float Penetration = max(0.0f, -EffectiveDist);
			float3 ImpactWorld = Pos - Normal * Sdf;

			// Apply collision response
			ApplyCollisionResponseWithFriction(Pos, OriginalPos, Vel, Normal, Penetration, Convex.Friction, Convex.Restitution);
			OriginalPos = Pos;

			// Mark as near ground if collision Normal is mostly upward
			if (Normal.z > 0.5f)
			{
				FlagsValue = SetFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
			}
			bCollided = true;

			// Record feedback for particle -> player interaction (includes Velocity for drag calculation)
			RecordCollisionFeedback(ParticleIndex, SphereCount + CapsuleCount + BoxCount + ConvexIndex, COLLIDER_TYPE_CONVEX, Density, Normal, Penetration, Vel, Convex.OwnerID, SourceID, Convex.BoneIndex, Convex.bHasFluidInteraction, ImpactWorld, Pos);
		}
	}

	// Clear near ground flag if no collision
	if (!bCollided)
	{
		FlagsValue = ClearFlag(FlagsValue, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Write back to SoA buffers
	PredictedPositions[ParticleIndex3] = Pos.x;
	PredictedPositions[ParticleIndex3 + 1] = Pos.y;
	PredictedPositions[ParticleIndex3 + 2] = Pos.z;

	PackedVelocities[ParticleIndex] = PackVelocity(Vel);

	Flags[ParticleIndex] = FlagsValue;
}
