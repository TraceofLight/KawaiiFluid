// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Particle Data Reordering
//
// After sorting Morton codes with particle indices, this shader physically
// reorders the particle data so that spatially close particles are also
// close in memory. This enables cache-efficient sequential access during
// neighbor traversal.
//
// Input: Original particle buffer + sorted indices
// Output: Reordered particle buffer (physically sorted by Morton code)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidBoneDeltaAttachment.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Input buffers (unsorted data + sorted indices)
StructuredBuffer<FGPUFluidParticle> OldParticles;
StructuredBuffer<uint> SortedIndices;  // SortedIndices[new_position] = old_index

// Output buffer (physically reordered)
RWStructuredBuffer<FGPUFluidParticle> SortedParticles;

// Optional: Reverse mapping for external references
RWStructuredBuffer<uint> OldToNewMapping;  // OldToNewMapping[old_index] = new_position

// Optional: BoneDeltaAttachment reordering (must stay synchronized with particles)
StructuredBuffer<FGPUBoneDeltaAttachment> OldBoneDeltaAttachments;
RWStructuredBuffer<FGPUBoneDeltaAttachment> SortedBoneDeltaAttachments;
int bReorderAttachments;  // 1 = reorder attachments, 0 = skip

int ParticleCount;

//=============================================================================
// Main Compute Shader: Reorder Particles
// Copies particle data from old positions to new sorted positions
//=============================================================================

#define THREAD_GROUP_SIZE 256

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= (uint)ParticleCount)
    {
        return;
    }

    // Get the old index for this new position
    uint oldIdx = SortedIndices[newIdx];

    // Copy particle data from old position to new position
    SortedParticles[newIdx] = OldParticles[oldIdx];

    // Also reorder BoneDeltaAttachment if enabled (keeps attachment data synchronized with particles)
    if (bReorderAttachments != 0)
    {
        SortedBoneDeltaAttachments[newIdx] = OldBoneDeltaAttachments[oldIdx];
    }
}

//=============================================================================
// Build Reverse Mapping: Old Index -> New Index
// Useful for updating external references to particles
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BuildReverseMappingCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= (uint)ParticleCount)
    {
        return;
    }

    // SortedIndices[newIdx] = oldIdx
    // So OldToNewMapping[oldIdx] = newIdx
    uint oldIdx = SortedIndices[newIdx];
    OldToNewMapping[oldIdx] = newIdx;
}

//=============================================================================
// SoA Reordering: Separate buffers for cache-optimal access
// Reorders position, velocity, and other attributes separately
//=============================================================================

// SoA Input buffers (unsorted)
StructuredBuffer<float4> OldPositions;    // xyz = position, w = mass
StructuredBuffer<float4> OldVelocities;   // xyz = velocity, w = unused
StructuredBuffer<float4> OldDynamics;     // x = lambda, y = density, z = flags, w = neighborCount

// SoA Output buffers (sorted)
RWStructuredBuffer<float4> SortedPositions;
RWStructuredBuffer<float4> SortedVelocities;
RWStructuredBuffer<float4> SortedDynamics;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderParticlesSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= (uint)ParticleCount)
    {
        return;
    }

    // Get the old index for this new position
    uint oldIdx = SortedIndices[newIdx];

    // Reorder each SoA buffer
    SortedPositions[newIdx] = OldPositions[oldIdx];
    SortedVelocities[newIdx] = OldVelocities[oldIdx];
    SortedDynamics[newIdx] = OldDynamics[oldIdx];
}

//=============================================================================
// Combined: Reorder + Extract SoA in Single Pass
// More efficient than separate reorder + extract passes
//=============================================================================

RWStructuredBuffer<FGPUParticlePositionSoA> SortedPositionsSoA;
RWStructuredBuffer<FGPUParticleDynamicsSoA> SortedDynamicsSoA;
RWStructuredBuffer<FGPUParticleVelocitySoA> SortedVelocitiesSoA;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderAndExtractSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= (uint)ParticleCount)
    {
        return;
    }

    // Get the old index for this new position
    uint oldIdx = SortedIndices[newIdx];

    // Read from old position
    FGPUFluidParticle particle = OldParticles[oldIdx];

    // Write reordered full particle
    SortedParticles[newIdx] = particle;

    // Also extract to SoA buffers for cache-efficient neighbor access
    FGPUParticlePositionSoA posSoA;
    posSoA.PredictedPosition = particle.PredictedPosition;
    posSoA.Mass = particle.Mass;
    SortedPositionsSoA[newIdx] = posSoA;

    FGPUParticleDynamicsSoA dynSoA;
    dynSoA.Lambda = particle.Lambda;
    dynSoA.Density = particle.Density;
    dynSoA.Flags = particle.Flags;
    dynSoA.NeighborCount = particle.NeighborCount;
    SortedDynamicsSoA[newIdx] = dynSoA;

    FGPUParticleVelocitySoA velSoA;
    velSoA.Velocity = particle.Velocity;
    velSoA.Padding = 0.0f;
    SortedVelocitiesSoA[newIdx] = velSoA;
}

//=============================================================================
// Update Particle IDs after Reordering
// Fixes ParticleID field to match new array position
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateParticleIDsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    // Keep old ParticleID for external reference, but could optionally update
    // SortedParticles[idx].ParticleID remains the original ID
    // This allows tracking which particle is which after sorting
}
