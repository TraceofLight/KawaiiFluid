// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Particle Data Reordering
//
// After sorting Morton codes with particle indices, this shader physically
// reorders the particle data so that spatially close particles are also
// close in memory. This enables cache-efficient sequential access during
// neighbor traversal.
//
// Input: Original particle buffer + sorted indices
// Output: Reordered particle buffer (physically sorted by Morton code)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidGPUPhysics.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidBoneDeltaAttachment.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Input buffers (unsorted data + sorted indices)
StructuredBuffer<FGPUFluidParticle> OldParticles;
StructuredBuffer<uint> SortedIndices;  // SortedIndices[new_position] = old_index

// Output buffer (physically reordered)
RWStructuredBuffer<FGPUFluidParticle> SortedParticles;

// Optional: Reverse mapping for external references
RWStructuredBuffer<uint> OldToNewMapping;  // OldToNewMapping[old_index] = new_position

// Optional: BoneDeltaAttachment reordering (must stay synchronized with particles)
StructuredBuffer<FGPUBoneDeltaAttachment> OldBoneDeltaAttachments;
RWStructuredBuffer<FGPUBoneDeltaAttachment> SortedBoneDeltaAttachments;
int bReorderAttachments;  // 1 = reorder attachments, 0 = skip

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;

//=============================================================================
// Main Compute Shader: Reorder Particles
// Copies particle data from old positions to new sorted positions
//=============================================================================

#define THREAD_GROUP_SIZE 256

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= ParticleCountBuffer[6])
    {
        return;
    }

    // Get the old index for this new position
    uint oldIdx = SortedIndices[newIdx];

    // Copy particle data from old position to new position
    SortedParticles[newIdx] = OldParticles[oldIdx];

    // Also reorder BoneDeltaAttachment if enabled (keeps attachment data synchronized with particles)
    if (bReorderAttachments != 0)
    {
        SortedBoneDeltaAttachments[newIdx] = OldBoneDeltaAttachments[oldIdx];
    }
}

//=============================================================================
// Build Reverse Mapping: Old Index -> New Index
// Useful for updating external references to particles
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BuildReverseMappingCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= ParticleCountBuffer[6])
    {
        return;
    }

    // SortedIndices[newIdx] = oldIdx
    // So OldToNewMapping[oldIdx] = newIdx
    uint oldIdx = SortedIndices[newIdx];
    OldToNewMapping[oldIdx] = newIdx;
}

//=============================================================================
// SoA Reordering: Separate buffers for cache-optimal access
// Reorders position, velocity, and other attributes separately
//=============================================================================

// SoA Input buffers (unsorted)
StructuredBuffer<float4> OldPositions;    // xyz = position, w = mass
StructuredBuffer<float4> OldVelocities;   // xyz = velocity, w = unused
StructuredBuffer<float4> OldDynamics;     // x = lambda, y = density, z = flags, w = neighborCount

// SoA Output buffers (sorted)
RWStructuredBuffer<float4> SortedPositions;
RWStructuredBuffer<float4> SortedVelocities;
RWStructuredBuffer<float4> SortedDynamics;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderParticlesSoACS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint newIdx = DispatchThreadId.x;
    if (newIdx >= ParticleCountBuffer[6])
    {
        return;
    }

    // Get the old index for this new position
    uint oldIdx = SortedIndices[newIdx];

    // Reorder each SoA buffer
    SortedPositions[newIdx] = OldPositions[oldIdx];
    SortedVelocities[newIdx] = OldVelocities[oldIdx];
    SortedDynamics[newIdx] = OldDynamics[oldIdx];
}

