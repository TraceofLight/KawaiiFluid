// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Morton Code (Z-Order Curve) Computation
//
// Morton Code encodes 3D spatial coordinates into a 1D integer that preserves spatial locality.
// Particles sorted by Morton Code will have spatially close particles also close in memory.
//
// Configuration (set via C++ shader permutation):
//   - Small:  6 bits per axis = 64³ cells
//   - Medium: 7 bits per axis = 128³ cells
//   - Large:  8 bits per axis = 256³ cells

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidGPUPhysics.ush"
#include "/Plugin/KawaiiFluidSystem/Public/FluidMortonUtils.ush"  // Unified Morton code functions

//=============================================================================
// Shader Parameters
//=============================================================================

// IMPORTANT: Use full particle structure to access PredictedPosition
// This must match the Solver which uses PredictedPosition for neighbor search
StructuredBuffer<FGPUFluidParticle> Particles;
RWStructuredBuffer<uint> MortonCodes;    // Output: Morton codes for sorting
RWStructuredBuffer<uint> ParticleIndices; // Output: Particle indices (0, 1, 2, ... N-1)

int ParticleCount;
StructuredBuffer<uint> ParticleCountBuffer;
float3 BoundsMin;      // Simulation bounds minimum
float3 BoundsExtent;   // Simulation bounds extent (Max - Min)
float CellSize;        // Grid cell size (= SmoothingRadius)
int bUseHybridTiledZOrder;  // 1 = Hybrid Tiled Z-Order (unlimited range), 0 = Classic Morton (bounded)

//=============================================================================
// Cell-based Morton Code Helpers
// Uses cell coordinates instead of normalized positions
// Better for spatial hash grid alignment
//=============================================================================

int3 WorldToCell(float3 WorldPos, float CellSz)
{
    return int3(floor(WorldPos / CellSz));
}

uint Morton3DFromCell(int3 CellCoord, int3 GridMin)
{
    // Offset to make all coordinates positive (relative to grid min)
    int3 offset = CellCoord - GridMin;

    // Clamp negative values to 0 (particles outside bounds)
    // This must match FluidSolveDensityPressure.usf's GetMortonCellIDFromCellCoord
    uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
    uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

    // Use preset-specific Morton function from FluidMortonUtils.ush
    return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Main Compute Shader: Compute Morton Codes (Legacy - not recommended)
// Uses normalized position quantization
//=============================================================================

#define THREAD_GROUP_SIZE 256

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    // Read particle position
    float3 pos = Particles[idx].xyz;

    // Normalize position to [0, 1] range within simulation bounds
    float3 normalizedPos = saturate((pos - BoundsMin) / BoundsExtent);

    // Quantize to grid-bit integer (matches MORTON_GRID_SIZE)
    uint3 quantized = uint3(normalizedPos * float(MORTON_MAX_VALUE));

    // Compute Morton code using preset-specific function
    uint mortonCode = Morton3D(quantized.x, quantized.y, quantized.z);

    // Output Morton code and initial particle index
    MortonCodes[idx] = mortonCode;
    ParticleIndices[idx] = idx;
}

//=============================================================================
// Cell-based Morton Code Computation (RECOMMENDED)
// Uses cell coordinates for better grid alignment with SPH
//
// Key change from 10-bit version:
//   - 7-bit per axis → 21-bit Morton code = Cell ID (NO truncation needed!)
//   - Morton code directly maps to cell buffer index
//   - CellSize = SmoothingRadius for optimal SPH neighbor search
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCellBasedCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= ParticleCountBuffer[6])
    {
        return;
    }

    // IMPORTANT: Use PredictedPosition for Morton code calculation!
    // This MUST match the Solver which uses PredictedPosition for centerCell lookup.
    // Using Position here would cause mismatch: Morton codes based on old position,
    // but Solver searches neighbors based on predicted (new) position.
    float3 pos = Particles[idx].PredictedPosition;

    // Convert to cell coordinate
    int3 cellCoord = WorldToCell(pos, CellSize);

    uint sortKey;
    if (bUseHybridTiledZOrder)
    {
        // Hybrid Tiled Z-Order: 21-bit key (UNLIMITED RANGE!)
        // Key = TileHash (3 bits) | LocalMorton (18 bits)
        // No bounds clipping - particles anywhere in the world get valid keys
        sortKey = ComputeHybridTiledKey(cellCoord);
    }
    else
    {
        // Classic Morton code: 21-bit key (bounded range)
        // Compute grid minimum cell (based on bounds)
        int3 gridMin = int3(floor(BoundsMin / CellSize));

        // Compute 21-bit Morton code from cell coordinate
        // With 7-bit per axis: Morton code = Cell ID (no truncation needed!)
        sortKey = Morton3DFromCell(cellCoord, gridMin);
    }

    // Output sort key
    MortonCodes[idx] = sortKey;
    ParticleIndices[idx] = idx;
}
