// Copyright KawaiiFluid Team. All Rights Reserved.
//
// Fluid Shadow Projection Compute Shader
//
// Projects previous frame's SSFR depth into light space for VSM shadow generation.
// Pipeline: History Depth -> World Position -> Light Clip Space -> VSM

#include "/Engine/Private/Common.ush"

// Input: Previous frame's smoothed depth texture
Texture2D<float> HistoryDepthTexture;

// Output: VSM shadow map (RG32F: depth, depth²)
RWTexture2D<float2> VSMTexture;

// Atomic depth buffer for min-depth tracking (R32_UINT)
RWTexture2D<uint> DepthAtomicBuffer;

// Camera matrices (from previous frame)
float4x4 HistoryInvViewProjectionMatrix;

// Light matrices (current frame)
float4x4 LightViewProjectionMatrix;

// Texture dimensions
float2 HistoryTextureSize;
float2 VSMTextureSize;

// Background depth threshold (matches FluidSmoothing.usf)
#define BACKGROUND_DEPTH_THRESH 3.0e30f

// Encode float depth to uint for atomic comparison (reversed Z: 0=far, 1=near)
// We want to find the CLOSEST depth (largest value in reversed-Z)
uint EncodeDepthToUint(float Depth)
{
    // Clamp to valid range and convert to uint
    // Using reversed mapping: closer objects have higher uint values
    return asuint(saturate(Depth));
}

float DecodeUintToDepth(uint EncodedDepth)
{
    return asfloat(EncodedDepth);
}

/**
 * Reconstruct world position from screen UV and depth.
 *
 * @param ScreenUV Normalized screen coordinates (0-1)
 * @param Depth Linear depth value from SSFR
 * @return World space position
 */
float3 ReconstructWorldPosition(float2 ScreenUV, float Depth)
{
    // Convert UV to NDC (-1 to 1)
    // Note: Y is flipped (UV is top-down, NDC is bottom-up)
    float2 NDC;
    NDC.x = ScreenUV.x * 2.0f - 1.0f;
    NDC.y = -(ScreenUV.y * 2.0f - 1.0f);

    // Create clip space position
    // For SSFR, depth is stored as linear view-space depth
    // We need to convert back to clip space depth first
    // However, since we have InvViewProjectionMatrix, we can work with NDC + depth
    //
    // Actually, SSFR stores linear depth (view space Z)
    // For proper reconstruction, we need to use the projection matrix properly
    //
    // Simplified approach: treat depth as clip.z/clip.w (device depth)
    // This works if SSFR outputs device depth (0-1 range)
    float4 ClipPos = float4(NDC.x, NDC.y, Depth, 1.0f);

    // Transform to world space
    float4 WorldPos4 = mul(ClipPos, HistoryInvViewProjectionMatrix);

    // Perspective divide
    float3 WorldPos = WorldPos4.xyz / WorldPos4.w;

    return WorldPos;
}

/**
 * Project world position to light clip space.
 *
 * @param WorldPos World space position
 * @param OutLightUV Output: normalized light space UV (0-1)
 * @param OutLightDepth Output: light space depth (0-1)
 * @return True if position is within light frustum
 */
bool ProjectToLightSpace(float3 WorldPos, out float2 OutLightUV, out float OutLightDepth)
{
    // Transform to light clip space
    float4 LightClipPos = mul(float4(WorldPos, 1.0f), LightViewProjectionMatrix);

    // Perspective divide
    float3 LightNDC = LightClipPos.xyz / LightClipPos.w;

    // Check if within light frustum
    if (any(abs(LightNDC.xy) > 1.0f) || LightNDC.z < 0.0f || LightNDC.z > 1.0f)
    {
        OutLightUV = float2(0, 0);
        OutLightDepth = 0;
        return false;
    }

    // Convert NDC to UV (0-1)
    OutLightUV.x = LightNDC.x * 0.5f + 0.5f;
    OutLightUV.y = -LightNDC.y * 0.5f + 0.5f; // Y flip for texture coordinates

    OutLightDepth = LightNDC.z;

    return true;
}

/**
 * Main compute shader: Projects fluid depth to VSM shadow map.
 *
 * Each thread processes one pixel from the history depth texture.
 * Valid depths are projected to light space and written to VSM.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void ProjectFluidShadowCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Bounds check
    if (any(DispatchThreadId.xy >= uint2(HistoryTextureSize)))
    {
        return;
    }

    int2 PixelCoord = int2(DispatchThreadId.xy);

    // Read history depth
    float Depth = HistoryDepthTexture.Load(int3(PixelCoord, 0));

    // Skip background pixels
    if (Depth > BACKGROUND_DEPTH_THRESH || Depth <= 0.0f)
    {
        return;
    }

    // Calculate screen UV
    float2 ScreenUV = (float2(PixelCoord) + 0.5f) / HistoryTextureSize;

    // Reconstruct world position
    float3 WorldPos = ReconstructWorldPosition(ScreenUV, Depth);

    // Project to light space
    float2 LightUV;
    float LightDepth;
    if (!ProjectToLightSpace(WorldPos, LightUV, LightDepth))
    {
        return; // Outside light frustum
    }

    // Calculate VSM pixel coordinate
    int2 VSMCoord = int2(LightUV * VSMTextureSize);

    // Bounds check for VSM
    if (any(VSMCoord < 0) || any(VSMCoord >= int2(VSMTextureSize)))
    {
        return;
    }

    // Atomic min-depth update
    // We use InterlockedMax because in reversed-Z, closer objects have larger depth values
    // For standard depth (0=near, 1=far), use InterlockedMin
    uint EncodedDepth = EncodeDepthToUint(LightDepth);
    uint OldValue;
    InterlockedMin(DepthAtomicBuffer[VSMCoord], EncodedDepth, OldValue);

    // Note: VSM values (depth, depth²) are computed in a separate finalization pass
    // because we need the final min depth first before computing variance
}

/**
 * Finalization pass: Convert atomic depth buffer to VSM format.
 *
 * Reads the min depth from atomic buffer and writes (depth, depth²) to VSM.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void FinalizeVSMCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Bounds check
    if (any(DispatchThreadId.xy >= uint2(VSMTextureSize)))
    {
        return;
    }

    int2 Coord = int2(DispatchThreadId.xy);

    // Read atomic depth
    uint EncodedDepth = DepthAtomicBuffer[Coord];

    // Check if any fluid was written (initial value is 0xFFFFFFFF for min operation)
    if (EncodedDepth == 0xFFFFFFFF)
    {
        // No fluid at this pixel - write far depth
        VSMTexture[Coord] = float2(1.0f, 1.0f);
        return;
    }

    // Decode depth
    float Depth = DecodeUintToDepth(EncodedDepth);

    // Write VSM: (depth, depth²)
    VSMTexture[Coord] = float2(Depth, Depth * Depth);
}

/**
 * Clear pass: Initialize atomic buffer to max value.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void ClearAtomicBufferCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId.xy >= uint2(VSMTextureSize)))
    {
        return;
    }

    // Initialize to max uint (represents far plane for min operation)
    DepthAtomicBuffer[int2(DispatchThreadId.xy)] = 0xFFFFFFFF;
}
