// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Adhesion Pass
// Handles particle attachment to bone colliders and position tracking

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidCollisionPrimitives.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// Particle buffer
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float ParticleRadius;

// Attachment buffer (one per particle)
RWStructuredBuffer<FGPUParticleAttachment> Attachments;

// Bone transforms
StructuredBuffer<FGPUBoneTransform> BoneTransforms;
int BoneCount;

// Collision primitives
StructuredBuffer<FGPUCollisionSphere> CollisionSpheres;
int SphereCount;

StructuredBuffer<FGPUCollisionCapsule> CollisionCapsules;
int CapsuleCount;

StructuredBuffer<FGPUCollisionBox> CollisionBoxes;
int BoxCount;

StructuredBuffer<FGPUCollisionConvex> CollisionConvexes;
int ConvexCount;

StructuredBuffer<FGPUConvexPlane> ConvexPlanes;

// Adhesion parameters
float AdhesionStrength;
float AdhesionRadius;
float DetachAccelThreshold;
float DetachDistanceThreshold;
float SlidingFriction;
float CurrentTime;
float DeltaTime;
int bEnableAdhesion;

// Gravity sliding parameters
float3 Gravity;
float GravitySlidingScale;  // How much gravity affects sliding (0-1)

// Primitive type constants
#define PRIM_TYPE_SPHERE 0
#define PRIM_TYPE_CAPSULE 1
#define PRIM_TYPE_BOX 2
#define PRIM_TYPE_CONVEX 3

//=============================================================================
// Helper Functions
//=============================================================================

// Find closest point on sphere surface
float3 GetClosestPointOnSphere(float3 pos, FGPUCollisionSphere sphere, out float3 normal, out float distance)
{
	float3 toPoint = pos - sphere.Center;
	float dist = length(toPoint);
	normal = dist > 0.0001f ? toPoint / dist : float3(0, 0, 1);
	distance = dist - sphere.Radius;
	return sphere.Center + normal * sphere.Radius;
}

// Find closest point on capsule surface
float3 GetClosestPointOnCapsule(float3 pos, FGPUCollisionCapsule capsule, out float3 normal, out float distance)
{
	float3 ab = capsule.End - capsule.Start;
	float t = saturate(dot(pos - capsule.Start, ab) / dot(ab, ab));
	float3 closestOnAxis = capsule.Start + t * ab;
	float3 toPoint = pos - closestOnAxis;
	float dist = length(toPoint);
	normal = dist > 0.0001f ? toPoint / dist : float3(0, 0, 1);
	distance = dist - capsule.Radius;
	return closestOnAxis + normal * capsule.Radius;
}

// Find closest point on box surface (approximate)
float3 GetClosestPointOnBox(float3 pos, FGPUCollisionBox box, out float3 normal, out float distance)
{
	// Transform to local space
	float3 localP = InverseRotateByQuat(pos - box.Center, box.Rotation);

	// Clamp to box surface
	float3 clamped = clamp(localP, -box.Extent, box.Extent);
	float3 localNormal = localP - clamped;
	float dist = length(localNormal);

	if (dist > 0.0001f)
	{
		localNormal /= dist;
	}
	else
	{
		// Inside box - find closest face
		float3 toFace = box.Extent - abs(localP);
		if (toFace.x < toFace.y && toFace.x < toFace.z)
			localNormal = float3(sign(localP.x), 0, 0);
		else if (toFace.y < toFace.z)
			localNormal = float3(0, sign(localP.y), 0);
		else
			localNormal = float3(0, 0, sign(localP.z));
		dist = -min(toFace.x, min(toFace.y, toFace.z));
	}

	// Transform back to world space
	normal = RotateByQuat(localNormal, box.Rotation);
	distance = dist;
	return box.Center + RotateByQuat(clamped, box.Rotation);
}

void GetConvexSurfaceInfo(
	float3 pos,
	FGPUCollisionConvex convex,
	StructuredBuffer<FGPUConvexPlane> planes,
	out float distance,
	out float3 normal,
	out float3 surfacePoint)
{
	float3 toCenter = pos - convex.Center;
	float centerLen = length(toCenter);
	float3 boundNormal = centerLen > 0.0001f ? toCenter / centerLen : float3(0, 0, 1);
	float boundDistance = centerLen - convex.BoundingRadius;

	float maxPlaneDistance = -1e10f;
	float3 planeNormal = boundNormal;

	if (convex.PlaneCount > 0)
	{
		const int planeStart = convex.PlaneStartIndex;
		for (int pi = 0; pi < convex.PlaneCount; ++pi)
		{
			FGPUConvexPlane plane = planes[planeStart + pi];
			float planeDistance = dot(pos, plane.Normal) - plane.Distance;
			if (planeDistance > maxPlaneDistance)
			{
				maxPlaneDistance = planeDistance;
				planeNormal = plane.Normal;
			}
		}

		bool bUseBound = boundDistance > maxPlaneDistance;
		distance = bUseBound ? boundDistance : maxPlaneDistance;
		normal = bUseBound ? boundNormal : planeNormal;
		surfacePoint = pos - normal * distance;
	}
	else
	{
		distance = boundDistance;
		normal = boundNormal;
		surfacePoint = convex.Center + normal * convex.BoundingRadius;
	}
}

//=============================================================================
// Adhesion Compute Shader - Check and create attachments
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void AdhesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount || bEnableAdhesion == 0)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];
	FGPUParticleAttachment attachment = Attachments[idx];

	float3 pos = particle.Position;

	// If already attached, skip adhesion check (handled by UpdateAttachedPositions)
	if (attachment.PrimitiveType >= 0)
	{
		return;
	}

	// Skip if just detached this frame
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED))
	{
		return;
	}

	// Find closest primitive for potential attachment
	float closestDist = AdhesionRadius;
	int closestPrimType = -1;
	int closestPrimIndex = -1;
	int closestBoneIndex = -1;
	float3 closestPoint = float3(0, 0, 0);
	float3 closestNormal = float3(0, 0, 1);

	// Check spheres
	for (int si = 0; si < SphereCount; ++si)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[si];
		if (sphere.BoneIndex < 0) continue;  // Skip primitives without bone tracking

		float3 normal;
		float distance;
		float3 surfacePoint = GetClosestPointOnSphere(pos, sphere, normal, distance);

		if (distance < closestDist && distance < AdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_SPHERE;
			closestPrimIndex = si;
			closestBoneIndex = sphere.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = normal;
		}
	}

	// Check capsules
	for (int ci = 0; ci < CapsuleCount; ++ci)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[ci];
		if (capsule.BoneIndex < 0) continue;

		float3 normal;
		float distance;
		float3 surfacePoint = GetClosestPointOnCapsule(pos, capsule, normal, distance);

		if (distance < closestDist && distance < AdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_CAPSULE;
			closestPrimIndex = ci;
			closestBoneIndex = capsule.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = normal;
		}
	}

	// Check boxes
	for (int bi = 0; bi < BoxCount; ++bi)
	{
		FGPUCollisionBox box = CollisionBoxes[bi];
		if (box.BoneIndex < 0) continue;

		float3 normal;
		float distance;
		float3 surfacePoint = GetClosestPointOnBox(pos, box, normal, distance);

		if (distance < closestDist && distance < AdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_BOX;
			closestPrimIndex = bi;
			closestBoneIndex = box.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = normal;
		}
	}

	// Check convexes
	for (int cxi = 0; cxi < ConvexCount; ++cxi)
	{
		FGPUCollisionConvex convex = CollisionConvexes[cxi];
		if (convex.BoneIndex < 0) continue;

		float distance;
		float3 surfaceNormal;
		float3 surfacePoint;
		GetConvexSurfaceInfo(pos, convex, ConvexPlanes, distance, surfaceNormal, surfacePoint);

		if (distance < closestDist && distance < AdhesionRadius)
		{
			closestDist = distance;
			closestPrimType = PRIM_TYPE_CONVEX;
			closestPrimIndex = cxi;
			closestBoneIndex = convex.BoneIndex;
			closestPoint = surfacePoint;
			closestNormal = surfaceNormal;
		}
	}

	// Create attachment if close enough
	if (closestPrimType >= 0 && closestBoneIndex >= 0 && closestBoneIndex < BoneCount)
	{
		FGPUBoneTransform bone = BoneTransforms[closestBoneIndex];

		// Store attachment info
		attachment.PrimitiveType = closestPrimType;
		attachment.PrimitiveIndex = closestPrimIndex;
		attachment.BoneIndex = closestBoneIndex;
		attachment.AdhesionStrength = AdhesionStrength;
		attachment.LocalOffset = WorldToBoneLocal(pos, bone);
		attachment.AttachmentTime = CurrentTime;

		// Set attached flag on particle
		particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);

		Particles[idx] = particle;
		Attachments[idx] = attachment;
	}
}

//=============================================================================
// Update Attached Positions Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateAttachedPositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUParticleAttachment attachment = Attachments[idx];

	// Skip non-attached particles
	if (attachment.PrimitiveType < 0 || attachment.BoneIndex < 0 || attachment.BoneIndex >= BoneCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];
	FGPUBoneTransform bone = BoneTransforms[attachment.BoneIndex];

	// Calculate new world position from bone transform
	float3 newPos = BoneLocalToWorld(attachment.LocalOffset, bone);

	// Check if we should detach
	bool bShouldDetach = false;

	// Detach if moved too far from primitive surface
	float surfaceDistance = 0;

	if (attachment.PrimitiveType == PRIM_TYPE_SPHERE && attachment.PrimitiveIndex < SphereCount)
	{
		FGPUCollisionSphere sphere = CollisionSpheres[attachment.PrimitiveIndex];
		surfaceDistance = abs(length(newPos - sphere.Center) - sphere.Radius);
	}
	else if (attachment.PrimitiveType == PRIM_TYPE_CAPSULE && attachment.PrimitiveIndex < CapsuleCount)
	{
		FGPUCollisionCapsule capsule = CollisionCapsules[attachment.PrimitiveIndex];
		float3 ab = capsule.End - capsule.Start;
		float t = saturate(dot(newPos - capsule.Start, ab) / dot(ab, ab));
		float3 closestOnAxis = capsule.Start + t * ab;
		surfaceDistance = abs(length(newPos - closestOnAxis) - capsule.Radius);
	}
	else if (attachment.PrimitiveType == PRIM_TYPE_BOX && attachment.PrimitiveIndex < BoxCount)
	{
		FGPUCollisionBox box = CollisionBoxes[attachment.PrimitiveIndex];
		surfaceDistance = abs(sdBox(newPos, box.Center, box.Extent, box.Rotation));
	}
	else if (attachment.PrimitiveType == PRIM_TYPE_CONVEX && attachment.PrimitiveIndex < ConvexCount)
	{
		FGPUCollisionConvex convex = CollisionConvexes[attachment.PrimitiveIndex];
		float signedDistance;
		float3 tmpNormal;
		float3 tmpPoint;
		GetConvexSurfaceInfo(newPos, convex, ConvexPlanes, signedDistance, tmpNormal, tmpPoint);
		surfaceDistance = abs(signedDistance);
	}

	if (surfaceDistance > DetachDistanceThreshold)
	{
		bShouldDetach = true;
	}

	// Calculate bone velocity and check acceleration-based detachment
	float3 boneVelocity = CalcBoneVelocity(attachment.LocalOffset, bone, DeltaTime);
	float acceleration = length(boneVelocity - particle.Velocity) / max(DeltaTime, 0.0001f);
	if (acceleration > DetachAccelThreshold)
	{
		bShouldDetach = true;
	}

	if (bShouldDetach)
	{
		// Detach: clear attachment, give particle bone velocity
		attachment.PrimitiveType = -1;
		attachment.PrimitiveIndex = -1;
		attachment.BoneIndex = -1;
		attachment.AdhesionStrength = 0;
		attachment.LocalOffset = float3(0, 0, 0);

		particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED);
		particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);

		// Clamp and dampen velocity on detach to prevent particles flying too far
		const float MaxDetachVelocity = 500.0f;  // cm/s (5 m/s max)
		const float DetachVelocityDamping = 0.3f; // 30% of bone velocity
		float3 clampedVelocity = boneVelocity * DetachVelocityDamping;
		float velMag = length(clampedVelocity);
		if (velMag > MaxDetachVelocity)
		{
			clampedVelocity = clampedVelocity * (MaxDetachVelocity / velMag);
		}
		particle.Velocity = clampedVelocity;
	}
	else
	{
		// === Gravity-based surface sliding ===
		// Calculate surface normal at current position
		float3 surfaceNormal = float3(0, 0, 1);
		float3 surfacePoint = newPos;

		if (attachment.PrimitiveType == PRIM_TYPE_SPHERE && attachment.PrimitiveIndex < SphereCount)
		{
			FGPUCollisionSphere sphere = CollisionSpheres[attachment.PrimitiveIndex];
			float3 toParticle = newPos - sphere.Center;
			float dist = length(toParticle);
			surfaceNormal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
			surfacePoint = sphere.Center + surfaceNormal * sphere.Radius;
		}
		else if (attachment.PrimitiveType == PRIM_TYPE_CAPSULE && attachment.PrimitiveIndex < CapsuleCount)
		{
			FGPUCollisionCapsule capsule = CollisionCapsules[attachment.PrimitiveIndex];
			float3 ab = capsule.End - capsule.Start;
			float t = saturate(dot(newPos - capsule.Start, ab) / dot(ab, ab));
			float3 closestOnAxis = capsule.Start + t * ab;
			float3 toParticle = newPos - closestOnAxis;
			float dist = length(toParticle);
			surfaceNormal = dist > 0.0001f ? toParticle / dist : float3(0, 0, 1);
			surfacePoint = closestOnAxis + surfaceNormal * capsule.Radius;
		}
		else if (attachment.PrimitiveType == PRIM_TYPE_BOX && attachment.PrimitiveIndex < BoxCount)
		{
			FGPUCollisionBox box = CollisionBoxes[attachment.PrimitiveIndex];
			float dummy;
			surfacePoint = GetClosestPointOnBox(newPos, box, surfaceNormal, dummy);
		}
		else if (attachment.PrimitiveType == PRIM_TYPE_CONVEX && attachment.PrimitiveIndex < ConvexCount)
		{
			FGPUCollisionConvex convex = CollisionConvexes[attachment.PrimitiveIndex];
			float signedDistance;
			GetConvexSurfaceInfo(newPos, convex, ConvexPlanes, signedDistance, surfaceNormal, surfacePoint);
		}

		// Calculate tangential gravity component (gravity projected onto surface)
		// tangentGravity = gravity - (gravity Â· normal) * normal
		float gravityNormalComponent = dot(Gravity, surfaceNormal);
		float3 tangentGravity = Gravity - gravityNormalComponent * surfaceNormal;

		// Apply sliding only if gravity has tangential component (surface is not horizontal)
		float tangentMagnitude = length(tangentGravity);
		if (tangentMagnitude > 0.1f && GravitySlidingScale > 0.0f)
		{
			// Calculate sliding velocity with friction
			// slidingAccel = tangentGravity * (1 - friction)
			float effectiveFriction = saturate(SlidingFriction);
			float3 slidingAccel = tangentGravity * (1.0f - effectiveFriction) * GravitySlidingScale;

			// Apply sliding displacement in world space
			float3 slidingDisplacement = slidingAccel * DeltaTime * DeltaTime * 0.5f;

			// Convert displacement to bone local space and update LocalOffset
			float3 newWorldPos = newPos + slidingDisplacement;

			// Re-project onto surface to prevent drifting away
			float3 toNewPos = newWorldPos - surfacePoint;
			float distToSurface = dot(toNewPos, surfaceNormal);
			newWorldPos = newWorldPos - distToSurface * surfaceNormal;

			// Update local offset for next frame
			attachment.LocalOffset = WorldToBoneLocal(newWorldPos, bone);

			// Update particle position
			particle.Position = newWorldPos;
			particle.PredictedPosition = newWorldPos;
			particle.Velocity = boneVelocity + slidingAccel * DeltaTime;
		}
		else
		{
			// No sliding - just follow bone
			particle.Position = newPos;
			particle.PredictedPosition = newPos;
			particle.Velocity = boneVelocity;
		}
	}

	Particles[idx] = particle;
	Attachments[idx] = attachment;
}

//=============================================================================
// Clear Just Detached Flag (run at end of frame)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearDetachedFlagCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];
	particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);
	Particles[idx] = particle;
}
