// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Collision Primitives - SDF Functions
// Provides signed distance functions for collision primitives

#ifndef FLUID_COLLISION_PRIMITIVES_USH
#define FLUID_COLLISION_PRIMITIVES_USH

//=============================================================================
// Primitive Structures (must match C++ definitions)
//=============================================================================

struct FGPUCollisionSphere
{
	float3 Center;
	float Radius;
	float Friction;
	float Restitution;
	int BoneIndex;     // Index into bone transform buffer (-1 = no bone)
	float Padding1;
};

struct FGPUCollisionCapsule
{
	float3 Start;
	float Radius;
	float3 End;
	float Friction;
	float Restitution;
	int BoneIndex;     // Index into bone transform buffer (-1 = no bone)
	float Padding1;
	float Padding2;
};

struct FGPUCollisionBox
{
	float3 Center;
	float Friction;
	float3 Extent;
	float Restitution;
	float4 Rotation;  // Quaternion (x, y, z, w)
	int BoneIndex;    // Index into bone transform buffer (-1 = no bone)
	float3 Padding;
};

struct FGPUCollisionConvex
{
	float3 Center;
	float BoundingRadius;
	int PlaneStartIndex;
	int PlaneCount;
	float Friction;
	float Restitution;
	int BoneIndex;    // Index into bone transform buffer (-1 = no bone)
	float Padding;
};

struct FGPUConvexPlane
{
	float3 Normal;
	float Distance;
};

//=============================================================================
// Bone Transform Structure (must match C++ FGPUBoneTransform)
//=============================================================================

struct FGPUBoneTransform
{
	float3 Position;      // Bone world position
	float Scale;          // Uniform scale
	float4 Rotation;      // Quaternion (x, y, z, w)
	float3 PreviousPos;   // Previous frame position
	float Padding1;
	float4 PreviousRot;   // Previous frame rotation
};

//=============================================================================
// Particle Attachment Structure (must match C++ FGPUParticleAttachment)
//=============================================================================

struct FGPUParticleAttachment
{
	int PrimitiveType;      // 0=Sphere, 1=Capsule, 2=Box, 3=Convex, -1=None
	int PrimitiveIndex;     // Index in primitive buffer
	int BoneIndex;          // Index in bone transform buffer
	float AdhesionStrength; // Current adhesion strength
	float3 LocalOffset;     // Position in bone-local space
	float AttachmentTime;   // Time when attached
};

//=============================================================================
// Quaternion Utilities (must be defined before Bone Transform Utilities)
//=============================================================================

// Rotate vector by quaternion
float3 RotateByQuat(float3 v, float4 q)
{
	float3 t = 2.0f * cross(q.xyz, v);
	return v + q.w * t + cross(q.xyz, t);
}

// Inverse rotate vector by quaternion
float3 InverseRotateByQuat(float3 v, float4 q)
{
	// Conjugate of quaternion: (x,y,z,w) -> (-x,-y,-z,w)
	return RotateByQuat(v, float4(-q.xyz, q.w));
}

//=============================================================================
// Bone Transform Utilities
//=============================================================================

// Transform position from bone-local to world space
float3 BoneLocalToWorld(float3 localPos, FGPUBoneTransform bone)
{
	float3 scaled = localPos * bone.Scale;
	float3 rotated = RotateByQuat(scaled, bone.Rotation);
	return rotated + bone.Position;
}

// Transform position from world to bone-local space
float3 WorldToBoneLocal(float3 worldPos, FGPUBoneTransform bone)
{
	float3 relative = worldPos - bone.Position;
	float3 rotated = InverseRotateByQuat(relative, bone.Rotation);
	return rotated / bone.Scale;
}

// Calculate bone velocity at a local position
float3 CalcBoneVelocity(float3 localPos, FGPUBoneTransform bone, float deltaTime)
{
	if (deltaTime < 0.0001f) return float3(0, 0, 0);

	// Current world position
	float3 currentWorld = BoneLocalToWorld(localPos, bone);

	// Previous world position (using previous bone transform)
	FGPUBoneTransform prevBone;
	prevBone.Position = bone.PreviousPos;
	prevBone.Rotation = bone.PreviousRot;
	prevBone.Scale = bone.Scale;
	float3 prevWorld = BoneLocalToWorld(localPos, prevBone);

	return (currentWorld - prevWorld) / deltaTime;
}

//=============================================================================
// SDF Functions
//=============================================================================

// Sphere SDF
float sdSphere(float3 p, float3 center, float radius)
{
	return length(p - center) - radius;
}

// Capsule SDF (line segment with radius)
float sdCapsule(float3 p, float3 a, float3 b, float radius)
{
	float3 pa = p - a;
	float3 ba = b - a;
	float h = saturate(dot(pa, ba) / dot(ba, ba));
	return length(pa - ba * h) - radius;
}

// Axis-aligned box SDF (in local space)
float sdBoxLocal(float3 p, float3 halfExtent)
{
	float3 q = abs(p) - halfExtent;
	return length(max(q, 0.0f)) + min(max(q.x, max(q.y, q.z)), 0.0f);
}

// Oriented box SDF
float sdBox(float3 p, float3 center, float3 halfExtent, float4 rotation)
{
	// Transform point to local space
	float3 localP = InverseRotateByQuat(p - center, rotation);
	return sdBoxLocal(localP, halfExtent);
}

// Convex hull SDF (intersection of half-spaces)
float sdConvex(
	float3 p,
	float3 center,
	float boundingRadius,
	int planeStart,
	int planeCount,
	StructuredBuffer<FGPUConvexPlane> planes)
{
	// Early out with bounding sphere
	float boundDist = length(p - center) - boundingRadius;
	if (boundDist > 0.0f)
	{
		return boundDist;
	}

	// Find maximum signed distance to all planes
	float maxDist = -1e10f;
	for (int i = 0; i < planeCount; ++i)
	{
		FGPUConvexPlane plane = planes[planeStart + i];
		float dist = dot(p, plane.Normal) - plane.Distance;
		maxDist = max(maxDist, dist);
	}
	return maxDist;
}

//=============================================================================
// Collision Response
//=============================================================================

struct FCollisionResult
{
	bool bHit;
	float Distance;
	float3 Normal;
	float Friction;
	float Restitution;
};

// Calculate gradient (normal) from SDF
float3 CalcSDFGradient(float3 p, float sdfValue, float3 center)
{
	// Simple approximation: direction from center to point
	float3 dir = p - center;
	float len = length(dir);
	return len > 0.0001f ? dir / len : float3(0, 0, 1);
}

// Numerical gradient for more accurate normal
float3 CalcNumericalGradient_Sphere(float3 p, float3 center, float radius)
{
	const float eps = 0.1f;
	float3 gradient;
	gradient.x = sdSphere(p + float3(eps, 0, 0), center, radius)
	           - sdSphere(p - float3(eps, 0, 0), center, radius);
	gradient.y = sdSphere(p + float3(0, eps, 0), center, radius)
	           - sdSphere(p - float3(0, eps, 0), center, radius);
	gradient.z = sdSphere(p + float3(0, 0, eps), center, radius)
	           - sdSphere(p - float3(0, 0, eps), center, radius);
	return normalize(gradient);
}

float3 CalcNumericalGradient_Capsule(float3 p, float3 a, float3 b, float radius)
{
	const float eps = 0.1f;
	float3 gradient;
	gradient.x = sdCapsule(p + float3(eps, 0, 0), a, b, radius)
	           - sdCapsule(p - float3(eps, 0, 0), a, b, radius);
	gradient.y = sdCapsule(p + float3(0, eps, 0), a, b, radius)
	           - sdCapsule(p - float3(0, eps, 0), a, b, radius);
	gradient.z = sdCapsule(p + float3(0, 0, eps), a, b, radius)
	           - sdCapsule(p - float3(0, 0, eps), a, b, radius);
	return normalize(gradient);
}

float3 CalcNumericalGradient_Box(float3 p, float3 center, float3 extent, float4 rotation)
{
	const float eps = 0.1f;
	float3 gradient;
	gradient.x = sdBox(p + float3(eps, 0, 0), center, extent, rotation)
	           - sdBox(p - float3(eps, 0, 0), center, extent, rotation);
	gradient.y = sdBox(p + float3(0, eps, 0), center, extent, rotation)
	           - sdBox(p - float3(0, eps, 0), center, extent, rotation);
	gradient.z = sdBox(p + float3(0, 0, eps), center, extent, rotation)
	           - sdBox(p - float3(0, 0, eps), center, extent, rotation);
	return normalize(gradient);
}

/**
 * Apply position-level friction (Unified Particle Physics, Macklin et al. 2014)
 *
 * This function applies friction at the position level rather than velocity level.
 * This is critical for PBF because FinalizePositions overwrites velocity with:
 *   v = (x* - x) / dt
 *
 * By modifying the position displacement, we ensure friction is preserved.
 *
 * Static friction:  |Δx_t| < μs * d → Δx_t = 0 (particle stops)
 * Kinetic friction: Δx_t *= min(μk * d / |Δx_t|, 1) (sliding with resistance)
 *
 * @param predictedPos - Predicted position (will be modified)
 * @param originalPos - Original position before this timestep
 * @param normal - Collision surface normal (pointing outward)
 * @param penetration - Penetration depth (positive value)
 * @param staticFriction - Static friction coefficient (μs)
 * @param kineticFriction - Kinetic friction coefficient (μk), typically same as friction param
 */
void ApplyPositionLevelFriction(
	inout float3 predictedPos,
	float3 originalPos,
	float3 normal,
	float penetration,
	float staticFriction,
	float kineticFriction)
{
	// Push out of collision first
	predictedPos += normal * (penetration + 0.1f);

	// Calculate total displacement from original position
	float3 deltaX = predictedPos - originalPos;

	// Decompose into normal and tangent components
	float deltaXNormal = dot(deltaX, normal);
	float3 deltaXNormalVec = deltaXNormal * normal;
	float3 deltaXTangent = deltaX - deltaXNormalVec;

	float tangentLength = length(deltaXTangent);

	// Apply friction only if there's tangent movement
	if (tangentLength > SMALL_NUMBER)
	{
		// d = penetration depth (contact distance)
		// Using penetration as the reference for friction force scaling
		float d = max(penetration, 0.1f);

		// Static friction threshold
		float staticThreshold = staticFriction * d;

		if (tangentLength < staticThreshold)
		{
			// Static friction: stop tangent movement completely
			deltaXTangent = float3(0, 0, 0);
		}
		else
		{
			// Kinetic friction: reduce tangent displacement
			float frictionScale = min(kineticFriction * d / tangentLength, 1.0f);
			deltaXTangent *= (1.0f - frictionScale);
		}
	}

	// Reconstruct position with friction-adjusted displacement
	predictedPos = originalPos + deltaXNormalVec + deltaXTangent;
}

/**
 * Apply collision response with position-level friction
 *
 * @param predictedPos - Predicted position (will be modified for push-out and friction)
 * @param originalPos - Original position before this timestep (for friction calculation)
 * @param velocity - Velocity (only used for restitution direction check, modified for bounce)
 * @param normal - Collision surface normal
 * @param penetration - Penetration depth
 * @param friction - Friction coefficient (used for both static and kinetic)
 * @param restitution - Bounce coefficient
 */
void ApplyCollisionResponseWithFriction(
	inout float3 predictedPos,
	float3 originalPos,
	inout float3 velocity,
	float3 normal,
	float penetration,
	float friction,
	float restitution)
{
	// Apply position-level friction (handles push-out internally)
	ApplyPositionLevelFriction(predictedPos, originalPos, normal, penetration, friction, friction);

	// Apply restitution to velocity for bounce effect
	// This affects the NEXT timestep's prediction, not current position
	float velNormal = dot(velocity, normal);
	if (velNormal < 0.0f)
	{
		// Reflect normal velocity component
		velocity -= (1.0f + restitution) * velNormal * normal;
	}
}

// Legacy: Apply collision response to velocity (kept for compatibility)
// WARNING: This approach doesn't work correctly with PBF because FinalizePositions
// overwrites velocity. Use ApplyCollisionResponseWithFriction instead.
void ApplyCollisionResponse(
	inout float3 position,
	inout float3 velocity,
	float3 normal,
	float penetration,
	float friction,
	float restitution)
{
	// Push out of collision
	position += normal * (penetration + 0.1f);

	// Velocity response
	float velNormal = dot(velocity, normal);
	if (velNormal < 0.0f)
	{
		float3 velNormalVec = velNormal * normal;
		float3 velTangent = velocity - velNormalVec;

		// Reflect with restitution
		velNormalVec = -velNormalVec * restitution;

		// Apply friction
		velTangent *= (1.0f - friction);

		velocity = velNormalVec + velTangent;
	}
}

#endif // FLUID_COLLISION_PRIMITIVES_USH
