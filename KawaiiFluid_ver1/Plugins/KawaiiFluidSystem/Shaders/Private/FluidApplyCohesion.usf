// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Apply Surface Tension Pass (OPTIMIZED)
// Implements Akinci et al. 2013 "Versatile Surface Tension and Adhesion for SPH Fluids"
//
// Optimizations:
// 1. rsqrt: Uses fast inverse square root instead of length()
// 2. Loop Unroll: Explicit 27-cell unrolling for cellRadius=1 case
//
// Key components:
// 1. Cohesion force with repulsion for close particles (Eq. 1-2)
// 2. Curvature minimization force for surface area minimization (Eq. 3)
// 3. K_ij correction factor for particle deficiency (Eq. 4)
// 4. Combined surface tension force (Eq. 5)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

int ParticleCount;
float SmoothingRadius;
float CohesionStrength;      // γ in paper (surface tension coefficient)
float CellSize;

// Akinci 2013 parameters
float DeltaTime;
float RestDensity;
float Poly6Coeff;              // For normal calculation
float MaxSurfaceTensionForce;  // Force clamping for stability

//=============================================================================
// Unrolled 27-Cell Normal Calculation Macro (Pass 1)
//=============================================================================
#define PROCESS_NORMAL_CELL(DX, DY, DZ) \
{ \
	int3 neighborCell = centerCell + int3(DX, DY, DZ); \
	uint hash = HashCell(neighborCell); \
	uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL); \
	uint startIdx = hash * MAX_PARTICLES_PER_CELL; \
	for (uint i = 0; i < count; ++i) \
	{ \
		uint neighborIdx = ParticleIndices[startIdx + i]; \
		if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue; \
		FGPUFluidParticle neighbor = Particles[neighborIdx]; \
		if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue; \
		float3 r_cm = pos - neighbor.PredictedPosition; \
		float r2_cm = dot(r_cm, r_cm); \
		if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm) continue; \
		float rLenInv_cm = rsqrt(r2_cm); \
		float dist_cm = r2_cm * rLenInv_cm; \
		float dist_m = dist_cm * CM_TO_M; \
		float r2_m = dist_m * dist_m; \
		float diff = h2 - r2_m; \
		if (diff > 0.0f && neighbor.Density > SMALL_NUMBER) \
		{ \
			float3 gradDir = r_cm * rLenInv_cm; \
			float gradMag = -6.0f * Poly6Coeff * diff * diff * dist_m; \
			float volumeContrib = neighbor.Mass / neighbor.Density; \
			normal += volumeContrib * gradMag * gradDir; \
		} \
	} \
}

//=============================================================================
// Unrolled 27-Cell Force Calculation Macro (Pass 2)
//=============================================================================
#define PROCESS_FORCE_CELL(DX, DY, DZ) \
{ \
	int3 neighborCell = centerCell + int3(DX, DY, DZ); \
	uint hash = HashCell(neighborCell); \
	uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL); \
	uint startIdx = hash * MAX_PARTICLES_PER_CELL; \
	for (uint i = 0; i < count; ++i) \
	{ \
		uint neighborIdx = ParticleIndices[startIdx + i]; \
		if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue; \
		FGPUFluidParticle neighbor = Particles[neighborIdx]; \
		if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue; \
		float3 r_cm = pos - neighbor.PredictedPosition; \
		float r2_cm = dot(r_cm, r_cm); \
		if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm) continue; \
		float rLenInv_cm = rsqrt(r2_cm); \
		float dist_cm = r2_cm * rLenInv_cm; \
		float dist_m = dist_cm * CM_TO_M; \
		float m_j = neighbor.Mass; \
		float rho_j = neighbor.Density; \
		float3 gradDir = r_cm * rLenInv_cm; \
		float K_ij = 1.0f; \
		if (rho_i > SMALL_NUMBER && rho_j > SMALL_NUMBER) \
		{ \
			K_ij = (2.0f * RestDensity) / (rho_i + rho_j); \
			K_ij = clamp(K_ij, 0.5f, 2.0f); \
		} \
		float cohesionWeight = CohesionKernel(dist_m, h_m); \
		if (abs(cohesionWeight) > SMALL_NUMBER * 0.001f) \
		{ \
			float3 direction = -gradDir; \
			float forceMag = m_i * m_j * cohesionWeight; \
			cohesionForce += K_ij * forceMag * direction; \
		} \
		float r2_m = dist_m * dist_m; \
		float diff = h2 - r2_m; \
		if (diff > 0.0f && rho_j > SMALL_NUMBER) \
		{ \
			float3 gradDir_j = -gradDir; \
			float gradMag = -6.0f * Poly6Coeff * diff * diff * dist_m; \
			float3 n_j = (m_j / rho_j) * gradMag * gradDir_j * h_m; \
			curvatureForce += K_ij * (-m_i * (n_i - n_j)) * 0.5f; \
		} \
	} \
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyCohesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Skip if surface tension is disabled
	if (CohesionStrength <= 0.0f)
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float h_m = SmoothingRadius * CM_TO_M;  // Smoothing radius in meters
	float h2 = h_m * h_m;
	float rho_i = particle.Density;
	float m_i = particle.Mass;
	float smoothingRadiusSq_cm = SmoothingRadius * SmoothingRadius;

	// Get cell coordinate for this particle
	int3 centerCell = WorldToCell(pos, CellSize);
	int cellRadius = (int)ceil(SmoothingRadius / CellSize);

	//=========================================================================
	// Pass 1: Compute surface normal for this particle
	// n_i = h * Σ_j (m_j / ρ_j) * ∇W(|x_i - x_j|)
	//=========================================================================
	float3 normal = float3(0.0f, 0.0f, 0.0f);

	if (cellRadius == 1)
	{
		// Unrolled 27-cell neighbor search
		PROCESS_NORMAL_CELL(-1, -1, -1)
		PROCESS_NORMAL_CELL( 0, -1, -1)
		PROCESS_NORMAL_CELL( 1, -1, -1)
		PROCESS_NORMAL_CELL(-1,  0, -1)
		PROCESS_NORMAL_CELL( 0,  0, -1)
		PROCESS_NORMAL_CELL( 1,  0, -1)
		PROCESS_NORMAL_CELL(-1,  1, -1)
		PROCESS_NORMAL_CELL( 0,  1, -1)
		PROCESS_NORMAL_CELL( 1,  1, -1)
		PROCESS_NORMAL_CELL(-1, -1,  0)
		PROCESS_NORMAL_CELL( 0, -1,  0)
		PROCESS_NORMAL_CELL( 1, -1,  0)
		PROCESS_NORMAL_CELL(-1,  0,  0)
		PROCESS_NORMAL_CELL( 0,  0,  0)
		PROCESS_NORMAL_CELL( 1,  0,  0)
		PROCESS_NORMAL_CELL(-1,  1,  0)
		PROCESS_NORMAL_CELL( 0,  1,  0)
		PROCESS_NORMAL_CELL( 1,  1,  0)
		PROCESS_NORMAL_CELL(-1, -1,  1)
		PROCESS_NORMAL_CELL( 0, -1,  1)
		PROCESS_NORMAL_CELL( 1, -1,  1)
		PROCESS_NORMAL_CELL(-1,  0,  1)
		PROCESS_NORMAL_CELL( 0,  0,  1)
		PROCESS_NORMAL_CELL( 1,  0,  1)
		PROCESS_NORMAL_CELL(-1,  1,  1)
		PROCESS_NORMAL_CELL( 0,  1,  1)
		PROCESS_NORMAL_CELL( 1,  1,  1)
	}
	else
	{
		// Fallback for cellRadius > 1
		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint hash = HashCell(neighborCell);
					uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
					uint startIdx = hash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < count; ++i)
					{
						uint neighborIdx = ParticleIndices[startIdx + i];
						if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue;

						FGPUFluidParticle neighbor = Particles[neighborIdx];
						if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue;

						float3 r_cm = pos - neighbor.PredictedPosition;
						float r2_cm = dot(r_cm, r_cm);
						if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm) continue;

						float rLenInv_cm = rsqrt(r2_cm);
						float dist_cm = r2_cm * rLenInv_cm;
						float dist_m = dist_cm * CM_TO_M;
						float r2_m = dist_m * dist_m;
						float diff = h2 - r2_m;

						if (diff > 0.0f && neighbor.Density > SMALL_NUMBER)
						{
							float3 gradDir = r_cm * rLenInv_cm;
							float gradMag = -6.0f * Poly6Coeff * diff * diff * dist_m;
							float volumeContrib = neighbor.Mass / neighbor.Density;
							normal += volumeContrib * gradMag * gradDir;
						}
					}
				}
			}
		}
	}

	// Scale by h to make normal scale-independent
	float3 n_i = normal * h_m;

	//=========================================================================
	// Pass 2: Compute cohesion and curvature forces
	//=========================================================================
	float3 cohesionForce = float3(0.0f, 0.0f, 0.0f);
	float3 curvatureForce = float3(0.0f, 0.0f, 0.0f);

	if (cellRadius == 1)
	{
		// Unrolled 27-cell neighbor search
		PROCESS_FORCE_CELL(-1, -1, -1)
		PROCESS_FORCE_CELL( 0, -1, -1)
		PROCESS_FORCE_CELL( 1, -1, -1)
		PROCESS_FORCE_CELL(-1,  0, -1)
		PROCESS_FORCE_CELL( 0,  0, -1)
		PROCESS_FORCE_CELL( 1,  0, -1)
		PROCESS_FORCE_CELL(-1,  1, -1)
		PROCESS_FORCE_CELL( 0,  1, -1)
		PROCESS_FORCE_CELL( 1,  1, -1)
		PROCESS_FORCE_CELL(-1, -1,  0)
		PROCESS_FORCE_CELL( 0, -1,  0)
		PROCESS_FORCE_CELL( 1, -1,  0)
		PROCESS_FORCE_CELL(-1,  0,  0)
		PROCESS_FORCE_CELL( 0,  0,  0)
		PROCESS_FORCE_CELL( 1,  0,  0)
		PROCESS_FORCE_CELL(-1,  1,  0)
		PROCESS_FORCE_CELL( 0,  1,  0)
		PROCESS_FORCE_CELL( 1,  1,  0)
		PROCESS_FORCE_CELL(-1, -1,  1)
		PROCESS_FORCE_CELL( 0, -1,  1)
		PROCESS_FORCE_CELL( 1, -1,  1)
		PROCESS_FORCE_CELL(-1,  0,  1)
		PROCESS_FORCE_CELL( 0,  0,  1)
		PROCESS_FORCE_CELL( 1,  0,  1)
		PROCESS_FORCE_CELL(-1,  1,  1)
		PROCESS_FORCE_CELL( 0,  1,  1)
		PROCESS_FORCE_CELL( 1,  1,  1)
	}
	else
	{
		// Fallback for cellRadius > 1
		for (int dz = -cellRadius; dz <= cellRadius; ++dz)
		{
			for (int dy = -cellRadius; dy <= cellRadius; ++dy)
			{
				for (int dx = -cellRadius; dx <= cellRadius; ++dx)
				{
					int3 neighborCell = centerCell + int3(dx, dy, dz);
					uint hash = HashCell(neighborCell);
					uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
					uint startIdx = hash * MAX_PARTICLES_PER_CELL;

					for (uint i = 0; i < count; ++i)
					{
						uint neighborIdx = ParticleIndices[startIdx + i];
						if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount) continue;

						FGPUFluidParticle neighbor = Particles[neighborIdx];
						if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED)) continue;

						float3 r_cm = pos - neighbor.PredictedPosition;
						float r2_cm = dot(r_cm, r_cm);
						if (r2_cm < SMALL_NUMBER || r2_cm > smoothingRadiusSq_cm) continue;

						float rLenInv_cm = rsqrt(r2_cm);
						float dist_cm = r2_cm * rLenInv_cm;
						float dist_m = dist_cm * CM_TO_M;
						float m_j = neighbor.Mass;
						float rho_j = neighbor.Density;
						float3 gradDir = r_cm * rLenInv_cm;

						// K_ij correction factor
						float K_ij = 1.0f;
						if (rho_i > SMALL_NUMBER && rho_j > SMALL_NUMBER)
						{
							K_ij = (2.0f * RestDensity) / (rho_i + rho_j);
							K_ij = clamp(K_ij, 0.5f, 2.0f);
						}

						// Cohesion force
						float cohesionWeight = CohesionKernel(dist_m, h_m);
						if (abs(cohesionWeight) > SMALL_NUMBER * 0.001f)
						{
							float3 direction = -gradDir;
							float forceMag = m_i * m_j * cohesionWeight;
							cohesionForce += K_ij * forceMag * direction;
						}

						// Curvature force
						float r2_m = dist_m * dist_m;
						float diff = h2 - r2_m;
						if (diff > 0.0f && rho_j > SMALL_NUMBER)
						{
							float3 gradDir_j = -gradDir;
							float gradMag = -6.0f * Poly6Coeff * diff * diff * dist_m;
							float3 n_j = (m_j / rho_j) * gradMag * gradDir_j * h_m;
							curvatureForce += K_ij * (-m_i * (n_i - n_j)) * 0.5f;
						}
					}
				}
			}
		}
	}

	//=========================================================================
	// Combined Surface Tension Force
	//=========================================================================
	float3 totalForce = CohesionStrength * (cohesionForce + curvatureForce);

	// Convert force to acceleration: a = F / m
	float3 acceleration = totalForce / max(m_i, SMALL_NUMBER);

	// Clamp maximum acceleration for stability
	if (MaxSurfaceTensionForce > 0.0f)
	{
		float maxAccel = MaxSurfaceTensionForce / max(m_i, SMALL_NUMBER);
		float accelMag = length(acceleration);
		if (accelMag > maxAccel && accelMag > SMALL_NUMBER)
		{
			acceleration = acceleration * (maxAccel / accelMag);
		}
	}

	// Apply to velocity with DeltaTime
	// IMPORTANT: Acceleration is in meters, Velocity is in cm/s
	#define M_TO_CM 100.0f
	particle.Velocity += acceleration * DeltaTime * M_TO_CM;

	Particles[idx] = particle;
}
