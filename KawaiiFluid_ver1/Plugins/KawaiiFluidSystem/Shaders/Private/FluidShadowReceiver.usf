// Copyright KawaiiFluid Team. All Rights Reserved.
//
// Fluid Shadow Receiver Shader
//
// Applies VSM (Variance Shadow Map) shadows from fluid onto the scene.
// Uses Chebyshev's inequality for soft shadow calculation.

#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

// Scene textures (prefixed to avoid conflicts with engine globals)
Texture2D ShadowReceiverSceneColor;
Texture2D ShadowReceiverSceneDepth;
SamplerState ShadowReceiverColorSampler;
SamplerState ShadowReceiverDepthSampler;

// Fluid VSM texture (depth, depth²)
Texture2D<float2> FluidVSMTexture;
SamplerState FluidVSMSampler;

// Transform matrices
float4x4 InvViewProjectionMatrix;
float4x4 LightViewProjectionMatrix;

// Shadow parameters
float ShadowIntensity;      // 0-1, how dark the shadow is
float ShadowBias;           // Depth bias to prevent self-shadowing
float MinVariance;          // Minimum variance to prevent division by zero
float LightBleedReduction;  // Reduces light bleeding artifacts (0-1)

// Texture dimensions
float2 ViewportSize;
float2 VSMTextureSize;

/**
 * Reconstruct world position from screen UV and depth.
 */
float3 ReconstructWorldPosition(float2 ScreenUV, float DeviceZ)
{
	// Convert to NDC (-1 to 1)
	float2 NDC = ScreenUV * 2.0f - 1.0f;
	NDC.y = -NDC.y; // Flip Y for UE convention

	// Create clip space position
	float4 ClipPos = float4(NDC, DeviceZ, 1.0f);

	// Transform to world space
	float4 WorldPos = mul(ClipPos, InvViewProjectionMatrix);
	return WorldPos.xyz / WorldPos.w;
}

/**
 * Transform world position to light clip space.
 */
float3 WorldToLightClip(float3 WorldPos)
{
	float4 LightClip = mul(float4(WorldPos, 1.0f), LightViewProjectionMatrix);
	return LightClip.xyz / LightClip.w;
}

/**
 * Convert light clip space to shadow map UV.
 */
float2 LightClipToShadowUV(float3 LightClip)
{
	// Convert from [-1,1] to [0,1]
	float2 ShadowUV = LightClip.xy * 0.5f + 0.5f;
	ShadowUV.y = 1.0f - ShadowUV.y; // Flip Y
	return ShadowUV;
}

/**
 * Calculate shadow factor using Chebyshev's inequality.
 *
 * VSM stores: M1 = E(depth), M2 = E(depth²)
 * Variance = M2 - M1²
 * P(x >= t) <= Variance / (Variance + (t - M1)²)  [Upper bound]
 *
 * Returns 1.0 = fully lit, 0.0 = fully shadowed
 */
float CalculateVSMShadow(float2 Moments, float ReceiverDepth)
{
	// If receiver is closer than mean depth, it's lit
	float Mean = Moments.x;
	if (ReceiverDepth <= Mean + ShadowBias)
	{
		return 1.0f;
	}

	// Calculate variance
	float Variance = max(Moments.y - Mean * Mean, MinVariance);

	// Chebyshev's inequality
	float Diff = ReceiverDepth - Mean;
	float PMax = Variance / (Variance + Diff * Diff);

	// Light bleed reduction (optional)
	// Reduces artifacts where occluded regions receive too much light
	PMax = saturate((PMax - LightBleedReduction) / (1.0f - LightBleedReduction));

	return PMax;
}

/**
 * Fullscreen triangle vertex shader.
 * Generates positions for a fullscreen triangle from SV_VertexID.
 */
void MainVS(
	uint VertexId : SV_VertexID,
	out float4 OutPosition : SV_Position)
{
	// Generate fullscreen triangle positions
	// VertexId 0: (-1, -1) -> bottom-left
	// VertexId 1: (-1,  3) -> top-left (extends beyond screen)
	// VertexId 2: ( 3, -1) -> bottom-right (extends beyond screen)
	float2 UV = float2((VertexId << 1) & 2, VertexId & 2);
	OutPosition = float4(UV * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f), 0.0f, 1.0f);
}

/**
 * Main pixel shader for shadow receiving.
 */
void MainPS(
	float4 SvPosition : SV_Position,
	out float4 OutColor : SV_Target0)
{
	float2 ScreenUV = SvPosition.xy / ViewportSize;

#if DEBUG_VISUALIZATION
	// Debug mode: show VSM texture in top-left quadrant
	if (ScreenUV.x < 0.25f && ScreenUV.y < 0.25f)
	{
		// Top-left: Show VSM depth (M1) - white = data exists
		float2 VSM_UV = ScreenUV * 4.0f;
		float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, VSM_UV);
		OutColor = float4(Moments.x, Moments.x, Moments.x, 1.0f);
		return;
	}
	else if (ScreenUV.x >= 0.25f && ScreenUV.x < 0.5f && ScreenUV.y < 0.25f)
	{
		// Top-middle: Show VSM depth² (M2)
		float2 VSM_UV = (ScreenUV - float2(0.25f, 0.0f)) * 4.0f;
		float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, VSM_UV);
		OutColor = float4(Moments.y, Moments.y, Moments.y, 1.0f);
		return;
	}
	else if (ScreenUV.x >= 0.5f && ScreenUV.x < 0.75f && ScreenUV.y < 0.25f)
	{
		// Top-right: Show shadow UV coverage (red = out of bounds)
		float4 SceneColor = ShadowReceiverSceneColor.Sample(ShadowReceiverColorSampler, ScreenUV);
		float DeviceZ = ShadowReceiverSceneDepth.Sample(ShadowReceiverDepthSampler, ScreenUV).r;
		if (DeviceZ > 0.0001f)
		{
			float3 WorldPos = ReconstructWorldPosition(ScreenUV, DeviceZ);
			float3 LightClip = WorldToLightClip(WorldPos);
			float2 ShadowUV = LightClipToShadowUV(LightClip);
			bool bOutOfBounds = any(ShadowUV < 0.0f) || any(ShadowUV > 1.0f);
			OutColor = bOutOfBounds ? float4(1, 0, 0, 1) : float4(ShadowUV, 0, 1);
		}
		else
		{
			OutColor = float4(0, 0, 1, 1); // Blue = sky
		}
		return;
	}
	else if (ScreenUV.x >= 0.75f && ScreenUV.y < 0.25f)
	{
		// Far-right: Debug depth values
		float DeviceZ = ShadowReceiverSceneDepth.Sample(ShadowReceiverDepthSampler, ScreenUV).r;
		if (DeviceZ > 0.0001f)
		{
			float3 WorldPos = ReconstructWorldPosition(ScreenUV, DeviceZ);
			float3 LightClip = WorldToLightClip(WorldPos);
			float2 ShadowUV = LightClipToShadowUV(LightClip);
			float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, ShadowUV);

			// Debug: Show LightClip.z range
			// R = LightClip.z (may be negative or >1)
			// G = Moments.x
			// B = comparison result (1 if ReceiverDepth > Moments.x)
			float ReceiverDepth = LightClip.z;
			float bShouldBeShadowed = (ReceiverDepth > Moments.x + ShadowBias) ? 1.0f : 0.0f;

			// Visualize: saturate to see if values are out of 0-1 range
			OutColor = float4(
				saturate(ReceiverDepth),      // R: Receiver depth (should be 0-1)
				saturate(Moments.x),          // G: VSM depth
				bShouldBeShadowed,            // B: Should be shadowed? (blue = yes)
				1.0f);
		}
		else
		{
			OutColor = float4(0, 0, 1, 1); // Blue = sky
		}
		return;
	}
#endif

	// Sample scene color
	float4 SceneColor = ShadowReceiverSceneColor.Sample(ShadowReceiverColorSampler, ScreenUV);

	// Sample scene depth
	float DeviceZ = ShadowReceiverSceneDepth.Sample(ShadowReceiverDepthSampler, ScreenUV).r;

	// Skip sky pixels (far plane)
	if (DeviceZ <= 0.0001f)
	{
		OutColor = SceneColor;
		return;
	}

	// Reconstruct world position
	float3 WorldPos = ReconstructWorldPosition(ScreenUV, DeviceZ);

	// Transform to light space
	float3 LightClip = WorldToLightClip(WorldPos);

	// Get shadow map UV
	float2 ShadowUV = LightClipToShadowUV(LightClip);

	// Check if within shadow map bounds
	if (any(ShadowUV < 0.0f) || any(ShadowUV > 1.0f))
	{
		OutColor = SceneColor;
		return;
	}

	// Sample VSM (depth, depth²)
	float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, ShadowUV);

	// VSM stores fluid depth. If Moments.x is very high (close to 1.0), no fluid at this location.
	// Low values mean fluid is present (blocking light).
	// Skip if no fluid shadow data (background/far plane in VSM)
	if (Moments.x >= 0.999f)
	{
		OutColor = SceneColor;
		return;
	}

	// Calculate receiver depth in light space (0-1 range)
	float ReceiverDepth = LightClip.z;

	// Calculate shadow factor
	float ShadowFactor = CalculateVSMShadow(Moments, ReceiverDepth);

	// Apply shadow with intensity control
	float FinalShadow = lerp(1.0f - ShadowIntensity, 1.0f, ShadowFactor);

	// Apply to scene color (multiplicative shadow)
	OutColor = float4(SceneColor.rgb * FinalShadow, SceneColor.a);
}

/**
 * Debug visualization shader.
 * Shows the VSM texture and shadow calculation for debugging.
 */
void DebugPS(
	float4 SvPosition : SV_Position,
	out float4 OutColor : SV_Target0)
{
	float2 ScreenUV = SvPosition.xy / ViewportSize;

	// Show different debug modes based on screen quadrant
	if (ScreenUV.x < 0.25f && ScreenUV.y < 0.25f)
	{
		// Top-left: Show VSM depth (M1)
		float2 VSM_UV = ScreenUV * 4.0f;
		float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, VSM_UV);
		OutColor = float4(Moments.x, Moments.x, Moments.x, 1.0f);
	}
	else if (ScreenUV.x >= 0.25f && ScreenUV.x < 0.5f && ScreenUV.y < 0.25f)
	{
		// Top-middle: Show VSM depth² (M2)
		float2 VSM_UV = (ScreenUV - float2(0.25f, 0.0f)) * 4.0f;
		float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, VSM_UV);
		OutColor = float4(Moments.y, Moments.y, Moments.y, 1.0f);
	}
	else
	{
		// Rest: Normal shadow composite
		float4 SceneColor = ShadowReceiverSceneColor.Sample(ShadowReceiverColorSampler, ScreenUV);
		float DeviceZ = ShadowReceiverSceneDepth.Sample(ShadowReceiverDepthSampler, ScreenUV).r;

		if (DeviceZ <= 0.0001f)
		{
			OutColor = SceneColor;
			return;
		}

		float3 WorldPos = ReconstructWorldPosition(ScreenUV, DeviceZ);
		float3 LightClip = WorldToLightClip(WorldPos);
		float2 ShadowUV = LightClipToShadowUV(LightClip);

		if (any(ShadowUV < 0.0f) || any(ShadowUV > 1.0f))
		{
			OutColor = SceneColor;
			return;
		}

		float2 Moments = FluidVSMTexture.Sample(FluidVSMSampler, ShadowUV);

		if (Moments.x <= 0.0001f)
		{
			OutColor = SceneColor;
			return;
		}

		float ReceiverDepth = LightClip.z;
		float ShadowFactor = CalculateVSMShadow(Moments, ReceiverDepth);
		float FinalShadow = lerp(1.0f - ShadowIntensity, 1.0f, ShadowFactor);

		OutColor = float4(SceneColor.rgb * FinalShadow, SceneColor.a);
	}
}
