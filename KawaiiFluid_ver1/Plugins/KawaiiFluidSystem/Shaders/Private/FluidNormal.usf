// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "FluidCommon.ush"

// 깊이 버퍼로부터 법선(Normal) 재구성

Texture2D<float> InputDepthTexture;
SamplerState InputSampler;
RWTexture2D<float4> OutputNormalTexture;

float2 TextureSize;
float2 InverseTextureSize;

float4x4 ProjectionMatrix;
float4x4 InverseProjectionMatrix;

// 깊이값으로부터 뷰 공간 (View Space) 위치 재구성
float3 ReconstructViewPosition(float2 ScreenUV, float Depth)
{
    float4 ClipPos = float4(ScreenUV * 2.0 - 1.0, Depth, 1.0);
    // 클립 공간 -> 뷰 공간 (UE는 기본적으로 Reverse-Z를 사용하지만, 여기서는 저장된 깊이값을 그대로 사용한다고 가정)
    float4 ViewPos = mul(ClipPos, InverseProjectionMatrix);
    return ViewPos.xyz / ViewPos.w;
}

[numthreads(8, 8, 1)]
void ReconstructNormalCS(uint3 ThreadId : SV_DispatchThreadID)
{
    float2 PixelPos = float2(ThreadId.xy);
    if (PixelPos.x >= TextureSize.x || PixelPos.y >= TextureSize.y)
    {
        return;
    }

    float2 UV = (PixelPos + 0.5) * InverseTextureSize;
    float Depth = InputDepthTexture.SampleLevel(InputSampler, UV, 0);

    if (Depth <= 0.0 || Depth >= 1.0)
    {
        OutputNormalTexture[ThreadId.xy] = float4(0, 0, 0, 0);
        return;
    }

    // 법선 재구성을 위한 중앙 차분(Central Difference) 방식
    float2 TexelSize = InverseTextureSize;
    
    float DepthL = InputDepthTexture.SampleLevel(InputSampler, UV + float2(-TexelSize.x, 0), 0);
    float DepthR = InputDepthTexture.SampleLevel(InputSampler, UV + float2(TexelSize.x, 0), 0);
    float DepthT = InputDepthTexture.SampleLevel(InputSampler, UV + float2(0, -TexelSize.y), 0);
    float DepthB = InputDepthTexture.SampleLevel(InputSampler, UV + float2(0, TexelSize.y), 0);

    // 인접 픽셀이 유효하지 않으면 현재 깊이값 사용
    if (DepthL <= 0.0 || DepthL >= 1.0) DepthL = Depth;
    if (DepthR <= 0.0 || DepthR >= 1.0) DepthR = Depth;
    if (DepthT <= 0.0 || DepthT >= 1.0) DepthT = Depth;
    if (DepthB <= 0.0 || DepthB >= 1.0) DepthB = Depth;

    float3 Pos = ReconstructViewPosition(UV, Depth);
    float3 PosL = ReconstructViewPosition(UV + float2(-TexelSize.x, 0), DepthL);
    float3 PosR = ReconstructViewPosition(UV + float2(TexelSize.x, 0), DepthR);
    float3 PosT = ReconstructViewPosition(UV + float2(0, -TexelSize.y), DepthT);
    float3 PosB = ReconstructViewPosition(UV + float2(0, TexelSize.y), DepthB);

    float3 Horizontal = PosR - PosL;
    float3 Vertical = PosB - PosT;

    float3 Normal = normalize(cross(Horizontal, Vertical));
    
    // 필요한 경우 월드 공간으로 변환할 수 있으나, 보통 뷰 공간에서 셰이딩하거나 뷰 공간 법선을 사용함
    // 현재는 뷰 공간 법선을 저장함. 시각화를 위해 [-1, 1]을 [0, 1]로 변환할 수 있지만, 
    // 일반적으로 float16/32 텍스처에 저장하므로 그대로 둠.
    
    OutputNormalTexture[ThreadId.xy] = float4(Normal, 1.0);
}
