// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Private/Common.ush"

// IO Resources
Texture2D<float> InputTexture;
RWTexture2D<float> OutputTexture;

// Blur Params
float2 TextureSize;
float BlurRadius;
float BlurDepthFalloff;

// 배경 깊이 임계값 (Depth Pass의 Clear 값에 맞춰 설정해 둠)
#define BACKGROUND_DEPTH_THRESH 3.0e30f 

// 가우시안 가중치 계산 함수
float GetGaussianWeight(float Distance, float Sigma)
{
	// Zero Division 방지
	if (Sigma <= 0.0001)
	{
		return 0.0f;
	}

	float Exponent = -(Distance * Distance) / (2.0 * Sigma * Sigma);
	return exp(Exponent);
}

//=============================================================================
// 2D Bilateral Blur (9x9 kernel, 81 samples)
//=============================================================================

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void BilateralBlur2DCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// 유효 범위 검사
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	// 중심 픽셀의 깊이 Load
	int2 CenterCoord = int2(DispatchThreadId.xy);
	float CenterDepth = InputTexture.Load(int3(CenterCoord, 0));

	// 아주 큰 값이면 배경이므로 블러링 없이 그대로 출력
	if (CenterDepth > BACKGROUND_DEPTH_THRESH)
	{
		OutputTexture[CenterCoord] = CenterDepth;
		return;
	}

	// 양방향 필터 파라미터 설정
	const int KernelRadius = 4;  // 9x9 kernel (radius 4 = -4 to +4)
	const float SpatialSigma = BlurRadius / 2.5;  // 더 부드럽게
	const float DepthSigma = BlurDepthFalloff;

	float TotalWeight = 0.0;
	float TotalWeightedDepth = 0.0;

	// 2D 커널 영역 반복 수행 (9x9 = 81 samples)
	for (int OffsetY = -KernelRadius; OffsetY <= KernelRadius; ++OffsetY)
	{
		for (int OffsetX = -KernelRadius; OffsetX <= KernelRadius; ++OffsetX)
		{
			// 정수 좌표 계산 및 클램핑
			int2 SampleCoord = CenterCoord + int2(OffsetX, OffsetY);
			SampleCoord = clamp(SampleCoord, int2(0, 0), int2(TextureSize) - 1);

			// 주변 깊이 샘플링
			float SampleDepth = InputTexture.Load(int3(SampleCoord, 0));

			// 배경 픽셀은 건너뜀
			if (SampleDepth > BACKGROUND_DEPTH_THRESH)
			{
				continue;
			}

			// 공간적 가중치 계산 (2D 거리)
			float2 SpatialOffset = float2(OffsetX, OffsetY);
			float SpatialDistance = length(SpatialOffset);
			float SpatialWeight = GetGaussianWeight(SpatialDistance, SpatialSigma);

			// 범위 가중치 계산 (깊이 차이에 따른 가우시안)
			float DepthDifference = abs(SampleDepth - CenterDepth);
			float RangeWeight = GetGaussianWeight(DepthDifference, DepthSigma);

			// 최종 양방향 가중치 결합
			float CombinedWeight = SpatialWeight * RangeWeight;

			// 가중치가 적용된 깊이 누적
			TotalWeightedDepth += SampleDepth * CombinedWeight;
			TotalWeight += CombinedWeight;
		}
	}

	float FinalDepth = CenterDepth;

	// 정규화
	if (TotalWeight > 0.0)
	{
		FinalDepth = TotalWeightedDepth / TotalWeight;
	}

	// 결과 저장
    OutputTexture[CenterCoord] = FinalDepth;
}
