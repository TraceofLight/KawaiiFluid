// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Private/Common.ush"

// IO Resources
Texture2D<float> InputTexture;
RWTexture2D<float> OutputTexture;

// Blur Params
float2 TextureSize;
float BlurRadius;
float BlurDepthFalloff;
float ParticleRadius;  // For Narrow-Range Filter threshold calculation

// 배경 깊이 임계값 (Depth Pass의 Clear 값에 맞춰 설정해 둠)
#define BACKGROUND_DEPTH_THRESH 3.0e30f

// Narrow-Range Filter 파라미터 (에디터에서 설정)
float NarrowRangeThresholdRatio;  // threshold = ParticleRadius * ThresholdRatio
float NarrowRangeClampRatio;      // clamp = ParticleRadius * ClampRatio
float NarrowRangeGrazingBoost;    // Grazing angle boost (0 = none, 1 = 2x at grazing)

// 가우시안 가중치 계산 함수
float GetGaussianWeight(float Distance, float Sigma)
{
	// Zero Division 방지
	if (Sigma <= 0.0001)
	{
		return 0.0f;
	}

	float Exponent = -(Distance * Distance) / (2.0 * Sigma * Sigma);
	return exp(Exponent);
}

//=============================================================================
// 2D Bilateral Blur (9x9 kernel, 81 samples)
//=============================================================================

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void BilateralBlur2DCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// 유효 범위 검사
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	// 중심 픽셀의 깊이 Load
	int2 CenterCoord = int2(DispatchThreadId.xy);
	float CenterDepth = InputTexture.Load(int3(CenterCoord, 0));

	// 아주 큰 값이면 배경이므로 블러링 없이 그대로 출력
	if (CenterDepth > BACKGROUND_DEPTH_THRESH)
	{
		OutputTexture[CenterCoord] = CenterDepth;
		return;
	}

	// 양방향 필터 파라미터 설정
	const int KernelRadius = 4;  // 9x9 kernel (radius 4 = -4 to +4)
	const float SpatialSigma = BlurRadius / 2.5;  // 더 부드럽게
	const float DepthSigma = BlurDepthFalloff;

	float TotalWeight = 0.0;
	float TotalWeightedDepth = 0.0;

	// 2D 커널 영역 반복 수행 (9x9 = 81 samples)
	for (int OffsetY = -KernelRadius; OffsetY <= KernelRadius; ++OffsetY)
	{
		for (int OffsetX = -KernelRadius; OffsetX <= KernelRadius; ++OffsetX)
		{
			// 정수 좌표 계산 및 클램핑
			int2 SampleCoord = CenterCoord + int2(OffsetX, OffsetY);
			SampleCoord = clamp(SampleCoord, int2(0, 0), int2(TextureSize) - 1);

			// 주변 깊이 샘플링
			float SampleDepth = InputTexture.Load(int3(SampleCoord, 0));

			// 배경 픽셀은 건너뜀
			if (SampleDepth > BACKGROUND_DEPTH_THRESH)
			{
				continue;
			}

			// 공간적 가중치 계산 (2D 거리)
			float2 SpatialOffset = float2(OffsetX, OffsetY);
			float SpatialDistance = length(SpatialOffset);
			float SpatialWeight = GetGaussianWeight(SpatialDistance, SpatialSigma);

			// 범위 가중치 계산 (깊이 차이에 따른 가우시안)
			float DepthDifference = abs(SampleDepth - CenterDepth);
			float RangeWeight = GetGaussianWeight(DepthDifference, DepthSigma);

			// 최종 양방향 가중치 결합
			float CombinedWeight = SpatialWeight * RangeWeight;

			// 가중치가 적용된 깊이 누적
			TotalWeightedDepth += SampleDepth * CombinedWeight;
			TotalWeight += CombinedWeight;
		}
	}

	float FinalDepth = CenterDepth;

	// 정규화
	if (TotalWeight > 0.0)
	{
		FinalDepth = TotalWeightedDepth / TotalWeight;
	}

	// 결과 저장
    OutputTexture[CenterCoord] = FinalDepth;
}

//=============================================================================
// Narrow-Range Filter (Truong & Yuksel, i3D 2018)
// "A Narrow-Range Filter for Screen-Space Fluid Rendering"
//
// Key idea: Instead of continuous Gaussian range weighting (bilateral),
// use hard threshold with dynamic range expansion for better edge preservation
//=============================================================================

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void NarrowRangeFilterCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// Bounds check
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	int2 CenterCoord = int2(DispatchThreadId.xy);
	float CenterDepth = InputTexture.Load(int3(CenterCoord, 0));

	// Background: pass through
	if (CenterDepth > BACKGROUND_DEPTH_THRESH)
	{
		OutputTexture[CenterCoord] = CenterDepth;
		return;
	}

	// Sample neighbors to compute depth gradient for grazing angle detection
	float zL = InputTexture.Load(int3(clamp(CenterCoord + int2(-1, 0), int2(0,0), int2(TextureSize)-1), 0));
	float zR = InputTexture.Load(int3(clamp(CenterCoord + int2( 1, 0), int2(0,0), int2(TextureSize)-1), 0));
	float zT = InputTexture.Load(int3(clamp(CenterCoord + int2( 0,-1), int2(0,0), int2(TextureSize)-1), 0));
	float zB = InputTexture.Load(int3(clamp(CenterCoord + int2( 0, 1), int2(0,0), int2(TextureSize)-1), 0));

	// Replace background with center depth for gradient calculation
	zL = (zL > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zL;
	zR = (zR > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zR;
	zT = (zT > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zT;
	zB = (zB > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zB;

	// Compute depth gradient magnitude
	float zx = (zR - zL) * 0.5f;
	float zy = (zB - zT) * 0.5f;
	float GradMag = sqrt(zx * zx + zy * zy);

	// Grazing factor: large gradient = grazing angle
	float GrazingFactor = saturate(GradMag / (ParticleRadius * 2.0f));

	// Narrow-Range Filter parameters with grazing-aware threshold
	const int KernelRadius = int(BlurRadius);
	const float Sigma = BlurRadius / 3.0f;
	const float BaseThreshold = ParticleRadius * NarrowRangeThresholdRatio;
	const float Threshold = BaseThreshold * (1.0f + NarrowRangeGrazingBoost * GrazingFactor);
	const float ClampThreshold = ParticleRadius * NarrowRangeClampRatio * (1.0f + NarrowRangeGrazingBoost * GrazingFactor);

	// Dynamic range bounds - start from center depth
	float Upper = CenterDepth + Threshold;
	float Lower = CenterDepth - Threshold;

	float TotalWeight = 0.0f;
	float TotalWeightedDepth = 0.0f;

	// 2D kernel iteration
	for (int OffsetY = -KernelRadius; OffsetY <= KernelRadius; ++OffsetY)
	{
		for (int OffsetX = -KernelRadius; OffsetX <= KernelRadius; ++OffsetX)
		{
			int2 SampleCoord = CenterCoord + int2(OffsetX, OffsetY);
			SampleCoord = clamp(SampleCoord, int2(0, 0), int2(TextureSize) - 1);

			float SampleDepth = InputTexture.Load(int3(SampleCoord, 0));

			// Skip background
			if (SampleDepth > BACKGROUND_DEPTH_THRESH)
			{
				continue;
			}

			// Spatial Gaussian weight
			float SpatialDist = length(float2(OffsetX, OffsetY));
			float SpatialWeight = GetGaussianWeight(SpatialDist, Sigma);

			// Narrow-Range logic: hard threshold with dynamic expansion
			if (SampleDepth > Upper)
			{
				// Too far (behind): exclude completely
				continue;
			}
			else if (SampleDepth < Lower)
			{
				// Too close (in front): clamp to lower bound
				// This prevents holes but allows surface to extend forward
				SampleDepth = max(SampleDepth, CenterDepth - ClampThreshold);
			}
			else
			{
				// Within range: dynamically expand bounds
				Upper = max(Upper, SampleDepth + Threshold);
				Lower = min(Lower, SampleDepth - Threshold);
			}

			TotalWeightedDepth += SampleDepth * SpatialWeight;
			TotalWeight += SpatialWeight;
		}
	}

	float FinalDepth = CenterDepth;
	if (TotalWeight > 0.0f)
	{
		FinalDepth = TotalWeightedDepth / TotalWeight;
	}

	OutputTexture[CenterCoord] = FinalDepth;
}

//=============================================================================
// Separable Gaussian Blur for Thickness (Optimized)
//
// Split into Horizontal + Vertical passes for O(2n) instead of O(n²)
// 41x41 = 1,681 samples → 41+41 = 82 samples (20x faster)
//
// Unlike depth smoothing, thickness uses simple Gaussian blur because:
// 1. Thickness values are additive (no sharp edges to preserve)
// 2. Background is 0.0, not a large value
// 3. We want to smooth out individual particle profiles
//=============================================================================

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ThicknessGaussianBlurHorizontalCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	int2 CenterCoord = int2(DispatchThreadId.xy);

	const int KernelRadius = int(BlurRadius);
	const float Sigma = BlurRadius / 2.0f;

	float TotalWeight = 0.0f;
	float TotalWeightedThickness = 0.0f;

	// Horizontal 1D Gaussian blur
	for (int OffsetX = -KernelRadius; OffsetX <= KernelRadius; ++OffsetX)
	{
		int SampleX = clamp(CenterCoord.x + OffsetX, 0, int(TextureSize.x) - 1);
		float SampleThickness = InputTexture.Load(int3(SampleX, CenterCoord.y, 0));

		float Weight = GetGaussianWeight(abs(float(OffsetX)), Sigma);
		TotalWeightedThickness += SampleThickness * Weight;
		TotalWeight += Weight;
	}

	OutputTexture[CenterCoord] = (TotalWeight > 0.0f) ? (TotalWeightedThickness / TotalWeight) : 0.0f;
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ThicknessGaussianBlurVerticalCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	int2 CenterCoord = int2(DispatchThreadId.xy);

	const int KernelRadius = int(BlurRadius);
	const float Sigma = BlurRadius / 2.0f;

	float TotalWeight = 0.0f;
	float TotalWeightedThickness = 0.0f;

	// Vertical 1D Gaussian blur
	for (int OffsetY = -KernelRadius; OffsetY <= KernelRadius; ++OffsetY)
	{
		int SampleY = clamp(CenterCoord.y + OffsetY, 0, int(TextureSize.y) - 1);
		float SampleThickness = InputTexture.Load(int3(CenterCoord.x, SampleY, 0));

		float Weight = GetGaussianWeight(abs(float(OffsetY)), Sigma);
		TotalWeightedThickness += SampleThickness * Weight;
		TotalWeight += Weight;
	}

	OutputTexture[CenterCoord] = (TotalWeight > 0.0f) ? (TotalWeightedThickness / TotalWeight) : 0.0f;
}

//=============================================================================
// Mean Curvature Flow Smoothing
// Based on "Screen Space Fluid Rendering with Curvature Flow" (van der Laan et al.)
//
// Key insight: Diffuses depth based on mean curvature, which naturally:
// - Smooths bumpy surfaces (high curvature regions)
// - Preserves flat areas and sharp edges
// - Reduces grazing angle artifacts by smoothing surface normals
//
// Mean Curvature H = div(∇z / ||∇z||)
// Update: z_new = z + dt * H
//=============================================================================

// Curvature Flow parameters
float CurvatureFlowDt;           // Time step for diffusion
float CurvatureFlowThreshold;    // Depth discontinuity threshold
float CurvatureFlowGrazingBoost; // Grazing angle boost (0 = none, 1 = 2x at grazing)

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CurvatureFlowCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// Bounds check
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	int2 CenterCoord = int2(DispatchThreadId.xy);
	float CenterDepth = InputTexture.Load(int3(CenterCoord, 0));

	// Background: pass through
	if (CenterDepth > BACKGROUND_DEPTH_THRESH)
	{
		OutputTexture[CenterCoord] = CenterDepth;
		return;
	}

	// Sample neighbors for gradient and curvature computation
	// Use 3x3 stencil for second-order derivatives
	float zL = InputTexture.Load(int3(clamp(CenterCoord + int2(-1, 0), int2(0,0), int2(TextureSize)-1), 0));
	float zR = InputTexture.Load(int3(clamp(CenterCoord + int2( 1, 0), int2(0,0), int2(TextureSize)-1), 0));
	float zT = InputTexture.Load(int3(clamp(CenterCoord + int2( 0,-1), int2(0,0), int2(TextureSize)-1), 0));
	float zB = InputTexture.Load(int3(clamp(CenterCoord + int2( 0, 1), int2(0,0), int2(TextureSize)-1), 0));

	// Diagonal neighbors for mixed derivative
	float zTL = InputTexture.Load(int3(clamp(CenterCoord + int2(-1,-1), int2(0,0), int2(TextureSize)-1), 0));
	float zTR = InputTexture.Load(int3(clamp(CenterCoord + int2( 1,-1), int2(0,0), int2(TextureSize)-1), 0));
	float zBL = InputTexture.Load(int3(clamp(CenterCoord + int2(-1, 1), int2(0,0), int2(TextureSize)-1), 0));
	float zBR = InputTexture.Load(int3(clamp(CenterCoord + int2( 1, 1), int2(0,0), int2(TextureSize)-1), 0));

	// Check for depth discontinuities (silhouette edges)
	// Don't smooth across large depth jumps
	float MaxDepthDiff = max(max(abs(zL - CenterDepth), abs(zR - CenterDepth)),
	                        max(abs(zT - CenterDepth), abs(zB - CenterDepth)));

	if (MaxDepthDiff > CurvatureFlowThreshold)
	{
		// Near silhouette edge - use bilateral fallback or skip
		OutputTexture[CenterCoord] = CenterDepth;
		return;
	}

	// Replace background samples with center depth to avoid edge artifacts
	zL = (zL > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zL;
	zR = (zR > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zR;
	zT = (zT > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zT;
	zB = (zB > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zB;
	zTL = (zTL > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zTL;
	zTR = (zTR > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zTR;
	zBL = (zBL > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zBL;
	zBR = (zBR > BACKGROUND_DEPTH_THRESH) ? CenterDepth : zBR;

	// First derivatives (for grazing angle detection)
	float zx = (zR - zL) * 0.5f;
	float zy = (zB - zT) * 0.5f;
	float GradMag = sqrt(zx * zx + zy * zy);

	// Second derivatives (Laplacian components)
	float zxx = zL - 2.0f * CenterDepth + zR;
	float zyy = zT - 2.0f * CenterDepth + zB;

	// Laplacian-based curvature flow (practical SSFR approach)
	// This is the standard approach used in van der Laan et al. and NVIDIA FleX
	float Laplacian = zxx + zyy;

	// Grazing-aware time step:
	// At grazing angles, depth gradient is large -> boost smoothing strength
	// GrazingFactor: 0 at normal view, approaches 1 at grazing angles
	// The gradient magnitude correlates with view angle - larger at grazing
	float GrazingFactor = saturate(GradMag / (ParticleRadius * 2.0f));
	float AdaptiveDt = CurvatureFlowDt * (1.0f + CurvatureFlowGrazingBoost * GrazingFactor);

	// Curvature flow update: z_new = z + dt * Laplacian
	float NewDepth = CenterDepth + AdaptiveDt * Laplacian;

	// Clamp to prevent extreme changes (stability)
	float MaxChange = ParticleRadius * 0.5f;
	NewDepth = clamp(NewDepth, CenterDepth - MaxChange, CenterDepth + MaxChange);

	OutputTexture[CenterCoord] = NewDepth;
}
