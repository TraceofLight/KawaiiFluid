// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Boundary Adhesion Pass
// Applies adhesion forces between fluid particles and boundary particles
// Based on Akinci 2012 "Versatile Rigid-Fluid Coupling"
// Optimized with Spatial Hash for O(N) complexity

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Structures (must match C++ definitions)
//=============================================================================

struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass"
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Fluid particles
RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// Boundary particles
StructuredBuffer<FGPUBoundaryParticle> BoundaryParticles;
int BoundaryParticleCount;

// Boundary Spatial Hash
StructuredBuffer<uint> BoundaryCellCounts;
StructuredBuffer<uint> BoundaryParticleIndices;
float BoundaryCellSize;

// Parameters
float AdhesionStrength;
float AdhesionRadius;
float CohesionStrength;
float SmoothingRadius;
float DeltaTime;
float RestDensity;
float Poly6Coeff;

//=============================================================================
// SPH Kernels for Adhesion (Akinci 2013)
// Note: AdhesionKernel and CohesionKernel are defined in FluidGPUPhysics.ush
//=============================================================================

//=============================================================================
// Pass 1: Clear Boundary Hash
//=============================================================================

RWStructuredBuffer<uint> RWBoundaryCellCounts;
RWStructuredBuffer<uint> RWBoundaryParticleIndices;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearBoundaryHashCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint cellIdx = DispatchThreadId.x;
	if (cellIdx >= SPATIAL_HASH_SIZE)
	{
		return;
	}
	RWBoundaryCellCounts[cellIdx] = 0;
}

//=============================================================================
// Pass 2: Build Boundary Hash
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BuildBoundaryHashCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint particleIdx = DispatchThreadId.x;
	if (particleIdx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	float3 pos = BoundaryParticles[particleIdx].Position;
	int3 cellCoord = WorldToCell(pos, BoundaryCellSize);
	uint cellHash = HashCell(cellCoord);

	uint slot;
	InterlockedAdd(RWBoundaryCellCounts[cellHash], 1, slot);

	if (slot < MAX_PARTICLES_PER_CELL)
	{
		uint baseOffset = cellHash * MAX_PARTICLES_PER_CELL;
		RWBoundaryParticleIndices[baseOffset + slot] = particleIdx;
	}
}

//=============================================================================
// Pass 3: Boundary Adhesion (Force-based, Akinci 2013)
// Applies adhesion and cohesion forces from boundary particles to fluid
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundaryAdhesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip if already attached to primitive (existing adhesion system handles this)
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	int3 cellCoord = WorldToCell(pos, BoundaryCellSize);

	float3 adhesionForce = float3(0, 0, 0);
	float3 cohesionForce = float3(0, 0, 0);

	float h = SmoothingRadius;

	// Search neighboring cells in boundary spatial hash
	for (int dx = -1; dx <= 1; ++dx)
	{
		for (int dy = -1; dy <= 1; ++dy)
		{
			for (int dz = -1; dz <= 1; ++dz)
			{
				int3 neighborCell = cellCoord + int3(dx, dy, dz);
				uint cellHash = HashCell(neighborCell);
				uint cellCount = min(BoundaryCellCounts[cellHash], MAX_PARTICLES_PER_CELL);
				uint baseOffset = cellHash * MAX_PARTICLES_PER_CELL;

				for (uint i = 0; i < cellCount; ++i)
				{
					uint bi = BoundaryParticleIndices[baseOffset + i];
					if (bi >= (uint)BoundaryParticleCount) continue;

					FGPUBoundaryParticle boundary = BoundaryParticles[bi];
					float3 r_vec = pos - boundary.Position;
					float r = length(r_vec);

					if (r > 0.0001f && r < h)
					{
						float3 r_normalized = r_vec / r;

						// Adhesion force (Akinci 2013)
						// F_adhesion = -beta * m_i * psi_b * A(r,h) * r_normalized
						float A = AdhesionKernel(r, h);
						adhesionForce -= AdhesionStrength * particle.Mass * boundary.Psi * A * r_normalized;

						// Cohesion force (surface tension at boundary)
						// F_cohesion = -gamma * m_i * psi_b * C(r,h) * r_normalized
						float C = CohesionKernel(r, h);
						cohesionForce -= CohesionStrength * particle.Mass * boundary.Psi * C * r_normalized;
					}
				}
			}
		}
	}

	// Apply forces to velocity
	float3 totalForce = adhesionForce + cohesionForce;

	// Clamp force magnitude to prevent instability
	float forceMag = length(totalForce);
	float maxForce = 10000.0f;  // Maximum force magnitude
	if (forceMag > maxForce)
	{
		totalForce = totalForce * (maxForce / forceMag);
	}

	// Apply as velocity change (F = ma, dv = F/m * dt)
	particle.Velocity += totalForce / particle.Mass * DeltaTime;

	Particles[idx] = particle;
}
