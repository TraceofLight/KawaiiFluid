// Copyright KawaiiFluid Team. All Rights Reserved.
//
// VSM (Variance Shadow Map) Blur Compute Shader
//
// Applies separable Gaussian blur to VSM texture.
// VSM can be safely blurred because it stores statistical moments (depth, depth²),
// and the variance calculation remains valid after filtering.

#include "/Engine/Private/Common.ush"

// Input/Output VSM textures
Texture2D<float2> InputVSM;
RWTexture2D<float2> OutputVSM;

// Blur parameters
float2 TextureSize;
float2 BlurDirection; // (1,0) for horizontal, (0,1) for vertical
float BlurRadius;

// Kernel size (must match C++ side)
#define MAX_KERNEL_RADIUS 16

// Precomputed Gaussian weights packed into float4 array (set from C++)
// Each float4 contains 4 weights: weights[0-3] in x/y/z/w of first vector, etc.
float4 GaussianWeights[GAUSSIAN_WEIGHTS_VECTOR_COUNT];
int KernelRadius;

// Helper function to get Gaussian weight from packed array
float GetGaussianWeight(int Index)
{
    int VecIndex = Index / 4;
    int CompIndex = Index % 4;
    return GaussianWeights[VecIndex][CompIndex];
}

/**
 * Separable Gaussian blur for VSM.
 *
 * Blurs both depth and depth² channels simultaneously.
 * Uses precomputed Gaussian weights for performance.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void VSMBlurCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    // Bounds check
    if (any(DispatchThreadId.xy >= uint2(TextureSize)))
    {
        return;
    }

    int2 CenterCoord = int2(DispatchThreadId.xy);

    // Accumulate weighted samples
    float2 WeightedSum = float2(0, 0);
    float TotalWeight = 0;

    // Sample along blur direction
    for (int i = -KernelRadius; i <= KernelRadius; ++i)
    {
        int2 SampleCoord = CenterCoord + int2(BlurDirection * i);

        // Clamp to texture bounds
        SampleCoord = clamp(SampleCoord, int2(0, 0), int2(TextureSize) - 1);

        // Get Gaussian weight (symmetric, so use abs(i))
        float Weight = GetGaussianWeight(abs(i));

        // Sample VSM (depth, depth²)
        float2 Sample = InputVSM.Load(int3(SampleCoord, 0));

        // Accumulate
        WeightedSum += Sample * Weight;
        TotalWeight += Weight;
    }

    // Normalize and output
    float2 Result = WeightedSum / max(TotalWeight, 0.0001f);
    OutputVSM[CenterCoord] = Result;
}

/**
 * Simple box blur fallback for VSM.
 * Used when Gaussian weights are not available.
 */
[numthreads(THREADGROUP_SIZE_X, THREADGROUP_SIZE_Y, 1)]
void VSMBoxBlurCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId.xy >= uint2(TextureSize)))
    {
        return;
    }

    int2 CenterCoord = int2(DispatchThreadId.xy);
    int Radius = int(BlurRadius);

    float2 Sum = float2(0, 0);
    int Count = 0;

    for (int i = -Radius; i <= Radius; ++i)
    {
        int2 SampleCoord = CenterCoord + int2(BlurDirection * i);
        SampleCoord = clamp(SampleCoord, int2(0, 0), int2(TextureSize) - 1);

        Sum += InputVSM.Load(int3(SampleCoord, 0));
        Count++;
    }

    OutputVSM[CenterCoord] = Sum / float(Count);
}
