// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Morton Code (Z-Order Curve) Computation
//
// Morton Code encodes 3D spatial coordinates into a 1D integer that preserves spatial locality.
// Particles sorted by Morton Code will have spatially close particles also close in memory.
//
// Configuration:
//   MORTON_GRID_AXIS_BITS = 7 (defined by C++ GPUFluidSimulatorShaders.h)
//   Grid Resolution = 2^7 = 128 per axis
//   Morton Code = 21 bits (7 × 3)
//   Max Cells = 128^3 = 2,097,152
//
// This matches the Preset's GridAxisBits and provides optimal cell size = SmoothingRadius.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

// IMPORTANT: Use full particle structure to access PredictedPosition
// This must match the Solver which uses PredictedPosition for neighbor search
StructuredBuffer<FGPUFluidParticle> Particles;
RWStructuredBuffer<uint> MortonCodes;    // Output: Morton codes for sorting
RWStructuredBuffer<uint> ParticleIndices; // Output: Particle indices (0, 1, 2, ... N-1)

int ParticleCount;
float3 BoundsMin;      // Simulation bounds minimum
float3 BoundsExtent;   // Simulation bounds extent (Max - Min)
float CellSize;        // Grid cell size (= SmoothingRadius)

//=============================================================================
// Z-Order Sorting Configuration
// CRITICAL: Must match GPUFluidSimulatorShaders.h and FluidCellStartEnd.usf
//
// Default: 7 bits per axis → 21-bit Morton code → 2M cells
// The Morton code IS the Cell ID (no truncation needed)
//=============================================================================
#ifndef MORTON_GRID_AXIS_BITS
#define MORTON_GRID_AXIS_BITS 7  // 7 bits per axis (from GPUFluidSimulatorShaders.h)
#endif

#define MORTON_GRID_SIZE (1 << MORTON_GRID_AXIS_BITS)  // 128 (2^7)
#define MORTON_MAX_VALUE (MORTON_GRID_SIZE - 1)        // 127 (7-bit max)
#define MAX_CELLS (MORTON_GRID_SIZE * MORTON_GRID_SIZE * MORTON_GRID_SIZE)  // 2,097,152

//=============================================================================
// Morton Code Encoding Functions
// Interleaves bits: x0y0z0 x1y1z1 x2y2z2 ...
// For 7-bit input: produces 21-bit Morton code
//=============================================================================

// Expand 7-bit integer to 21-bit with 2-bit gaps between each bit
// Input:  0000 0000 0000 0000 0000 000x xxxx xx (7 bits, 0-127)
// Output: 0x0 0x00 x00x 00x0 0x00 x00x 00x (21 bits, spread out)
uint ExpandBits7(uint v)
{
    // Clamp to 7 bits first
    v = v & 0x7Fu;  // 127 max

    // Bit manipulation to spread 7 bits across 21 bits (with 2-bit gaps)
    // Similar algorithm to 10-bit version but adjusted for 7 bits
    v = (v | (v << 8)) & 0x0000F00Fu;  // 0000 0000 0000 0000 xxxx 0000 0000 xxxx
    v = (v | (v << 4)) & 0x000C30C3u;  // 0000 0000 0000 xx00 00xx 00xx 00xx 00xx
    v = (v | (v << 2)) & 0x00249249u;  // 0000 0000 00x0 0x00 x00x 00x0 0x00 x00x
    return v;
}

// Compute 21-bit Morton Code for 3D point
// Each coordinate is quantized to 7 bits (0-127)
uint Morton3D_7bit(uint x, uint y, uint z)
{
    // Clamp to 7 bits (0-127)
    x = min(x, MORTON_MAX_VALUE);
    y = min(y, MORTON_MAX_VALUE);
    z = min(z, MORTON_MAX_VALUE);

    // Interleave bits: z takes highest bits, then y, then x
    // Result: z6y6x6 z5y5x5 z4y4x4 ... z0y0x0 (21 bits total)
    uint xx = ExpandBits7(x);
    uint yy = ExpandBits7(y);
    uint zz = ExpandBits7(z);

    return (zz << 2) | (yy << 1) | xx;
}

// Legacy 10-bit version (for reference, not used)
uint ExpandBits10(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint Morton3D_10bit(uint x, uint y, uint z)
{
    x = min(x, 1023u);
    y = min(y, 1023u);
    z = min(z, 1023u);
    uint xx = ExpandBits10(x);
    uint yy = ExpandBits10(y);
    uint zz = ExpandBits10(z);
    return (zz << 2) | (yy << 1) | xx;
}

//=============================================================================
// Alternative: Cell-based Morton Code
// Uses cell coordinates instead of normalized positions
// Better for spatial hash grid alignment
//=============================================================================

int3 WorldToCell(float3 WorldPos, float CellSz)
{
    return int3(floor(WorldPos / CellSz));
}

uint Morton3DFromCell(int3 CellCoord, int3 GridMin)
{
    // Offset to make all coordinates positive (relative to grid min)
    int3 offset = CellCoord - GridMin;

    // Clamp negative values to 0 (particles outside bounds)
    // This must match FluidSolveDensityPressure.usf's GetMortonCellIDFromCellCoord
    uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
    uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));

    return Morton3D_7bit(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Main Compute Shader: Compute Morton Codes (Legacy - not recommended)
// Uses normalized position quantization
//=============================================================================

#define THREAD_GROUP_SIZE 256

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    // Read particle position
    float3 pos = Particles[idx].xyz;

    // Normalize position to [0, 1] range within simulation bounds
    float3 normalizedPos = saturate((pos - BoundsMin) / BoundsExtent);

    // Quantize to 7-bit integer (0-127) - matches MORTON_GRID_SIZE
    uint3 quantized = uint3(normalizedPos * float(MORTON_MAX_VALUE));

    // Compute 21-bit Morton code (IS the Cell ID)
    uint mortonCode = Morton3D_7bit(quantized.x, quantized.y, quantized.z);

    // Output Morton code and initial particle index
    MortonCodes[idx] = mortonCode;
    ParticleIndices[idx] = idx;
}

//=============================================================================
// Cell-based Morton Code Computation (RECOMMENDED)
// Uses cell coordinates for better grid alignment with SPH
//
// Key change from 10-bit version:
//   - 7-bit per axis → 21-bit Morton code = Cell ID (NO truncation needed!)
//   - Morton code directly maps to cell buffer index
//   - CellSize = SmoothingRadius for optimal SPH neighbor search
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeMortonCodesCellBasedCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    // IMPORTANT: Use PredictedPosition for Morton code calculation!
    // This MUST match the Solver which uses PredictedPosition for centerCell lookup.
    // Using Position here would cause mismatch: Morton codes based on old position,
    // but Solver searches neighbors based on predicted (new) position.
    float3 pos = Particles[idx].PredictedPosition;

    // Convert to cell coordinate
    int3 cellCoord = WorldToCell(pos, CellSize);

    // Compute grid minimum cell (based on bounds)
    int3 gridMin = int3(floor(BoundsMin / CellSize));

    // Compute 21-bit Morton code from cell coordinate
    // With 7-bit per axis: Morton code = Cell ID (no truncation needed!)
    uint mortonCode = Morton3DFromCell(cellCoord, gridMin);

    // Output Morton code as sort key (21-bit = Cell ID directly)
    // No truncation needed since MAX_CELLS = 128^3 = 2,097,152 < 2^21
    MortonCodes[idx] = mortonCode;
    ParticleIndices[idx] = idx;
}
