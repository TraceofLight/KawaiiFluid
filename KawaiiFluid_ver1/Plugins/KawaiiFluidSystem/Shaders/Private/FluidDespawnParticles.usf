// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// ===================================================================================
// Struct Definitions (Must match C++)
// ===================================================================================

struct FGPUFluidParticle
{
	float3 Position;           // 12 bytes
	float Mass;                // 4 bytes
	float3 PredictedPosition;  // 12 bytes
	float Density;             // 4 bytes
	float3 Velocity;           // 12 bytes
	float Lambda;              // 4 bytes
	int ParticleID;            // 4 bytes
	int SourceID;              // 4 bytes
	uint Flags;                // 4 bytes
	uint NeighborCount;        // 4 bytes
};

struct FGPUDespawnRequest
{
    float3 Position;
    float Radius;
};

// ===================================================================================
// Parameter Definitions
// ===================================================================================

// Shared Parameters
StructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;

// MarkDespawnCS Parameters
StructuredBuffer<FGPUDespawnRequest> DespawnRequests;
RWStructuredBuffer<uint> OutAliveMask;
int DespawnRequestCount;

// CompactParticlesCS Parameters
StructuredBuffer<uint> MarkedFlags;
StructuredBuffer<uint> PrefixSums;
RWStructuredBuffer<FGPUFluidParticle> CompactedParticles;

// WriteTotalCountCS Parameters
RWStructuredBuffer<uint> OutTotalCount;

// ===================================================================================
// Kernel: MarkDespawnCS
// ===================================================================================
[numthreads(256, 1, 1)]
void MarkDespawnCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;

	if (Index >= (uint)ParticleCount)
		return;

	// 1. Get particle position
	const float3 ParticlePos = Particles[Index].Position;

	// 2. Default state: Alive
	bool bIsAlive = true;

	// 3. Check against all despawn requests
	for (int i = 0; i < DespawnRequestCount; ++i)
	{
		FGPUDespawnRequest Request = DespawnRequests[i];

		float3 Diff = ParticlePos - Request.Position;
		float DistSq = dot(Diff, Diff);
		float RadiusSq = Request.Radius * Request.Radius;

		if (DistSq < RadiusSq)
		{
			bIsAlive = false;
			break;
		}
	}
	
	// 4. Write result (1=Alive, 0=Dead)
	OutAliveMask[Index] = bIsAlive ? 1 : 0;
}

// ===================================================================================
// Kernel: CompactParticlesCS
// ===================================================================================
[numthreads(256, 1, 1)]
void CompactParticlesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	const uint Index = DispatchThreadId.x;

	if (Index >= (uint)ParticleCount)
		return;

	// Copy only alive particles
	if (MarkedFlags[Index] == 1)
	{
		// PrefixSum value is the new index
		uint NewIndex = PrefixSums[Index];
		
		// Copy entire particle data
		CompactedParticles[NewIndex] = Particles[Index];
	}
}

// ===================================================================================
// Kernel: WriteTotalCountCS
// ===================================================================================
[numthreads(1, 1, 1)]
void WriteTotalCountCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// Calculate total alive count from the last particle's PrefixSum
	// Assumes Inclusive Scan: Last PrefixSum value = Total Count
	if (ParticleCount > 0)
	{
		uint LastIndex = ParticleCount - 1;
		uint TotalAlive = PrefixSums[LastIndex] + MarkedFlags[LastIndex];
		
		OutTotalCount[0] = ParticleCount - TotalAlive;
	}
	else
	{
		OutTotalCount[0] = 0;
	}
}
