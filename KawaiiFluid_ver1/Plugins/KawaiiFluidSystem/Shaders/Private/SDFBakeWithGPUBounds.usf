// Copyright KawaiiFluid Team. All Rights Reserved.
// SDF Volume Bake Compute Shader (Dynamic Search Range Version)
// Removes external dependencies + Applies dynamic search range

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

//=============================================================================
// 1. Structs and Helper Functions
//=============================================================================

struct FKawaiiRenderParticle
{
    float3 Position;
    float3 Velocity;
    float Radius;
    float Padding;
};

uint HashCell(int3 Cell)
{
    const uint p1 = 73856093;
    const uint p2 = 19349663;
    const uint p3 = 83492791;
    uint n = p1 * (uint)Cell.x ^ p2 * (uint)Cell.y ^ p3 * (uint)Cell.z;
    return n % 65536; 
}

float smin(float a, float b, float k)
{
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

//=============================================================================
// 2. Parameters
//=============================================================================

#if USE_SOA_BUFFERS
    StructuredBuffer<float3> RenderPositions;
#else
    StructuredBuffer<FKawaiiRenderParticle> RenderParticles;
#endif

int ParticleCount;
float ParticleRadius;
float SDFSmoothness;

#if USE_SPATIAL_HASH
    StructuredBuffer<uint2> CellData;
    StructuredBuffer<uint> SpatialHashParticleIndices;
    float SpatialHashCellSize;
#endif

StructuredBuffer<float3> BoundsBuffer;
int3 VolumeResolution;
RWTexture3D<float> SDFVolume;

//=============================================================================
// 3. Main Kernel (Dynamic Loop)
//=============================================================================

[numthreads(8, 8, 8)]
void SDFBakeWithGPUBoundsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId >= uint3(VolumeResolution))) return;

    float3 VolumeMin = BoundsBuffer[0];
    float3 VolumeMax = BoundsBuffer[1];
    
    if ((VolumeMax.x - VolumeMin.x) <= 0) 
    {
        SDFVolume[DispatchThreadId] = 1e10;
        return;
    }

    float3 uvw = (float3(DispatchThreadId) + 0.5) / float3(VolumeResolution);
    float3 worldPos = lerp(VolumeMin, VolumeMax, uvw);

    if (ParticleCount <= 0)
    {
        SDFVolume[DispatchThreadId] = 1e10;
        return;
    }

    float minSdf = 1e10;

#if USE_SPATIAL_HASH
    if (SpatialHashCellSize > 0.0)
    {
        int3 CenterCell = floor(worldPos / SpatialHashCellSize);

        // Core Logic: Dynamic Search Range Calculation
        float MaxInteractionDist = ParticleRadius + (SDFSmoothness * 2.0f);
        
        int Range = (int)ceil(MaxInteractionDist / SpatialHashCellSize);

        for (int dz = -Range; dz <= Range; ++dz)
        {
            for (int dy = -Range; dy <= Range; ++dy)
            {
                for (int dx = -Range; dx <= Range; ++dx)
                {
                    int3 NeighborCell = CenterCell + int3(dx, dy, dz);
                    uint Hash = HashCell(NeighborCell);
                    uint2 Cell = CellData[Hash];
                    uint StartIndex = Cell.x;
                    uint Count = Cell.y;

                    for (uint i = 0; i < Count; ++i)
                    {
                        uint ParticleIdx = SpatialHashParticleIndices[StartIndex + i];
                        if (ParticleIdx >= (uint)ParticleCount) continue;

                        float3 P;
                        #if USE_SOA_BUFFERS
                            P = RenderPositions[ParticleIdx];
                        #else
                            P = RenderParticles[ParticleIdx].Position;
                        #endif

                        float d = length(worldPos - P) - ParticleRadius;
                        
                        // SDF Calculation
                        if (minSdf > 1e9) minSdf = d;
                        else minSdf = smin(minSdf, d, SDFSmoothness);
                    }
                }
            }
        }

        // Safe Clamping
        float SafeDistance = (float)Range * SpatialHashCellSize;
        SDFVolume[DispatchThreadId] = min(minSdf, SafeDistance);
        return;
    }
#endif

    // [Fallback] Brute Force
    #if USE_SOA_BUFFERS
    {
        float3 P0 = RenderPositions[0];
        minSdf = length(worldPos - P0) - ParticleRadius;
        for (int i = 1; i < ParticleCount; ++i) {
            float d = length(worldPos - RenderPositions[i]) - ParticleRadius;
            minSdf = smin(minSdf, d, SDFSmoothness);
        }
    }
    #else
    {
        float3 P0 = RenderParticles[0].Position;
        minSdf = length(worldPos - P0) - ParticleRadius;
        for (int i = 1; i < ParticleCount; ++i) {
            float d = length(worldPos - RenderParticles[i].Position) - ParticleRadius;
            minSdf = smin(minSdf, d, SDFSmoothness);
        }
    }
    #endif

    SDFVolume[DispatchThreadId] = minSdf;
}